
bladeRF_nios.elf:     file format elf32-littlenios2
bladeRF_nios.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000414c

Program Header:
    LOAD off    0x00001000 vaddr 0x00004000 paddr 0x00004000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00004020 paddr 0x00004020 align 2**12
         filesz 0x000030f8 memsz 0x000030f8 flags r-x
    LOAD off    0x00004118 vaddr 0x00007118 paddr 0x00007134 align 2**12
         filesz 0x0000001c memsz 0x0000001c flags rw-
    LOAD off    0x00004150 vaddr 0x00007150 paddr 0x00007150 align 2**12
         filesz 0x00000000 memsz 0x00000434 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00004000  00004000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000012c  00004020  00004020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00002f40  0000414c  0000414c  0000114c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000008c  0000708c  0000708c  0000408c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000001c  00007118  00007134  00004118  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000434  00007150  00007150  00004150  2**2
                  ALLOC, SMALL_DATA
  6 .ram          00000000  00007584  00007584  00004134  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  00004134  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000428  00000000  00000000  00004158  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00007022  00000000  00000000  00004580  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002726  00000000  00000000  0000b5a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00002b06  00000000  00000000  0000dcc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000aec  00000000  00000000  000107d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001a78  00000000  00000000  000112bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00004be8  00000000  00000000  00012d34  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000040  00000000  00000000  0001791c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000578  00000000  00000000  00017960  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  000199ca  2**0
                  CONTENTS, READONLY
 18 .cpu          00000005  00000000  00000000  000199cd  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  000199d2  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  000199d3  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   00000009  00000000  00000000  000199d4  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    00000009  00000000  00000000  000199dd  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   00000009  00000000  00000000  000199e6  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 0000000b  00000000  00000000  000199ef  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000002e  00000000  00000000  000199fa  2**0
                  CONTENTS, READONLY
 26 .jdi          0000726d  00000000  00000000  00019a28  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     000b8c34  00000000  00000000  00020c95  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00004000 l    d  .entry	00000000 .entry
00004020 l    d  .exceptions	00000000 .exceptions
0000414c l    d  .text	00000000 .text
0000708c l    d  .rodata	00000000 .rodata
00007118 l    d  .rwdata	00000000 .rwdata
00007150 l    d  .bss	00000000 .bss
00007584 l    d  .ram	00000000 .ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../bladeRF_nios_bsp//obj/HAL/src/crt0.o
00004184 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
00004094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 bladeRF_nios.c
0000708c l     O .rodata	00000070 pkt_handlers
00000000 l    df *ABS*	00000000 devices.c
0000444c l     F .text	00000038 si5338_complete_transfer
00004484 l     F .text	00000038 command_uart_isr
00004528 l     F .text	00000088 vctcxo_tamer_set_tune_mode.part.0
00004648 l     F .text	00000098 vctcxo_tamer_isr
00000000 l    df *ABS*	00000000 devices_sim.c
00000000 l    df *ABS*	00000000 pkt_32x32.c
00000000 l    df *ABS*	00000000 pkt_8x16.c
00000000 l    df *ABS*	00000000 pkt_8x32.c
00000000 l    df *ABS*	00000000 pkt_8x64.c
00000000 l    df *ABS*	00000000 pkt_8x8.c
00000000 l    df *ABS*	00000000 pkt_legacy.c
00005540 l     F .text	0000004c lookup_param
000070fc l     O .rodata	0000001a config_params
00007128 l     O .rwdata	00000004 param.3741
00007168 l     O .bss	00000001 n.3739
00007124 l     O .rwdata	00000004 last_param.3742
00007160 l     O .bss	00000008 payload.3740
0000715c l     O .bss	00000001 n.3782
00007120 l     O .rwdata	00000004 param.3783
0000711c l     O .rwdata	00000004 last_param.3784
00007154 l     O .bss	00000008 payload.3781
00000000 l    df *ABS*	00000000 pkt_retune.c
00005a28 l     F .text	00000064 reset_queue
00005a8c l     F .text	0000007c retune_isr
00005b08 l     F .text	0000002c retune_tx
0000717c l     O .bss	00000184 tx_queue
00005b34 l     F .text	0000002c retune_rx
00007300 l     O .bss	00000184 rx_queue
00005b60 l     F .text	00000118 perform_work
00000000 l    df *ABS*	00000000 band_select.c
00000000 l    df *ABS*	00000000 lms.c
00006124 l     F .text	000000cc vtune_low_to_norm
000061f0 l     F .text	000000d8 vtune_high_to_norm
000062c8 l     F .text	00000108 wait_for_vtune_value
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00006ec8 g     F .text	0000002c alt_main
00007484 g     O .bss	00000100 alt_irq
00007134 g       *ABS*	00000000 __flash_rwdata_start
00004bc8 g     F .text	0000000c tx_trigger_ctl_read
00004758 g     F .text	000000cc bladerf_nios_init
00004824 g     F .text	00000020 spi_arbiter_lock
00007130 g     O .rwdata	00000004 jtag_uart
00007084 g     F .text	00000008 altera_nios2_gen2_irq_init
00004000 g     F .entry	0000000c __reset
00004020 g       *ABS*	00000000 __flash_exceptions_start
00007174 g     O .bss	00000004 alt_argv
0000f118 g       *ABS*	00000000 _gp
00006ef4 g     F .text	00000004 usleep
00006420 g     F .text	00000084 lms_select_pa
00006cac g     F .text	00000028 memcpy
00006bc8 g     F .text	00000064 .hidden __udivsi3
000044bc g     F .text	0000002c vctcxo_tamer_enable_isr
00004be4 g     F .text	0000000c rx_trigger_ctl_read
0000558c g     F .text	0000049c pkt_legacy
00004000 g       *ABS*	00000000 __alt_mem_ram
00007150 g     O .bss	00000001 vctcxo_tamer_ctrl_reg
00007584 g       *ABS*	00000000 __bss_end
00006d80 g     F .text	00000068 alt_iic_isr_register
00005374 g     F .text	000001cc pkt_8x8
00004b90 g     F .text	00000028 iqbal_set_phase
00006d68 g     F .text	00000018 alt_ic_irq_enabled
0000716c g     O .bss	00000004 alt_irq_active
000044e8 g     F .text	00000014 vctcxo_tamer_clear_isr
000040ec g     F .exceptions	00000060 alt_irq_handler
000045e0 g     F .text	00000068 vctcxo_tamer_read_count
00004980 g     F .text	0000008c si5338_write
0000707c g     F .text	00000004 alt_dcache_flush_all
00004ae0 g     F .text	00000054 adf4351_write
00007134 g       *ABS*	00000000 __ram_rwdata_end
000046e0 g     F .text	00000014 vctcxo_tamer_read
00007118 g       *ABS*	00000000 __ram_rodata_end
00006a90 g     F .text	00000040 .hidden __lshrdi3
00006c2c g     F .text	00000058 .hidden __umodsi3
00004a54 g     F .text	0000008c vctcxo_trim_dac_read
00004b74 g     F .text	0000001c iqbal_get_phase
00007584 g       *ABS*	00000000 end
00008000 g       *ABS*	00000000 __alt_stack_pointer
00004854 g     F .text	00000040 lms6_read
0000414c g     F .text	0000003c _start
00006f1c g     F .text	000000e8 alt_avalon_spi_command
00006f18 g     F .text	00000004 alt_sys_init
00007118 g     O .rwdata	00000002 vctcxo_trim_dac_value
000064a4 g     F .text	000000e0 lms_get_loopback_mode
0000661c g     F .text	00000474 lms_set_precalculated_frequency
00006c84 g     F .text	00000028 .hidden __mulsi3
00007118 g       *ABS*	00000000 __ram_rwdata_start
0000708c g       *ABS*	00000000 __ram_rodata_start
000044fc g     F .text	0000002c vctcxo_tamer_reset_counters
00007004 g     F .text	00000078 alt_busy_sleep
00007584 g       *ABS*	00000000 __alt_stack_base
000045b0 g     F .text	00000010 vctcxo_tamer_set_tune_mode
000063d0 g     F .text	00000050 lms_select_lna
00004844 g     F .text	00000010 spi_arbiter_unlock
00004708 g     F .text	00000050 tamer_schedule
00007150 g       *ABS*	00000000 __bss_start
00006cd4 g     F .text	00000020 memset
00004188 g     F .text	000002c4 main
00007170 g     O .bss	00000004 alt_envp
00004c6c g     F .text	0000007c time_tamer_read
000048e0 g     F .text	000000a0 si5338_read
00006ad0 g     F .text	00000084 .hidden __divsi3
0000521c g     F .text	00000158 pkt_8x64
0000708c g       *ABS*	00000000 __flash_rodata_start
00006ef8 g     F .text	00000020 alt_irq_init
00004e6c g     F .text	000001e8 pkt_8x16
00005d0c g     F .text	000003a0 pkt_retune
00007178 g     O .bss	00000004 alt_argc
00006584 g     F .text	00000098 lms_select_band
00004020 g       .exceptions	00000000 alt_irq_entry
000046f4 g     F .text	00000014 vctcxo_tamer_write
00004020 g       *ABS*	00000000 __ram_exceptions_start
00005c78 g     F .text	00000064 pkt_retune_init
00006cf4 g     F .text	00000004 alt_ic_isr_register
00007134 g       *ABS*	00000000 _edata
00004bd4 g     F .text	00000010 rx_trigger_ctl_write
00007584 g       *ABS*	00000000 _end
00004bf0 g     F .text	0000007c agc_dc_corr_write
0000414c g       *ABS*	00000000 __ram_exceptions_end
00006d30 g     F .text	00000038 alt_ic_irq_disable
00004b34 g     F .text	00000018 iqbal_get_gain
00005054 g     F .text	000001c8 pkt_8x32
00006b54 g     F .text	00000074 .hidden __modsi3
00008000 g       *ABS*	00000000 __alt_data_end
00004020 g     F .exceptions	00000000 alt_exception
00004bb8 g     F .text	00000010 tx_trigger_ctl_write
0000400c g       .entry	00000000 _exit
00004894 g     F .text	0000004c lms6_write
00004ce8 g     F .text	00000184 pkt_32x32
00007080 g     F .text	00000004 alt_icache_flush_all
0000712c g     O .rwdata	00000004 alt_priority_mask
000060ac g     F .text	00000078 band_select
00004a0c g     F .text	00000048 vctcxo_trim_dac_write
00006cf8 g     F .text	00000038 alt_ic_irq_enable
000045c0 g     F .text	00000020 vctcxo_tamer_get_tune_mode
00005cdc g     F .text	00000030 pkt_retune_work
00004b4c g     F .text	00000028 iqbal_set_gain
00006de8 g     F .text	000000e0 alt_load



Disassembly of section .entry:

00004000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    4000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    4004:	08505314 	ori	at,at,16716
    jmp r1
    4008:	0800683a 	jmp	at

0000400c <_exit>:
	...

Disassembly of section .exceptions:

00004020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
    4020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
    4024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
    4028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
    402c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
    4030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
    4034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
    4038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
    403c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
    4040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
    4044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
    4048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
    404c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
    4050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
    4054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
    4058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
    405c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
    4060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
    4064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
    4068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
    406c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    4070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
    4074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
    4078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
    407c:	10000326 	beq	r2,zero,408c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
    4080:	20000226 	beq	r4,zero,408c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
    4084:	00040ec0 	call	40ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
    4088:	00000306 	br	4098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
    408c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
    4090:	e8bfff17 	ldw	r2,-4(ea)

00004094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
    4094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
    4098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
    409c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
    40a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
    40a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
    40a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
    40ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
    40b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
    40b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
    40b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
    40bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
    40c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
    40c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
    40c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
    40cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
    40d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
    40d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
    40d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
    40dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
    40e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
    40e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
    40e8:	ef80083a 	eret

000040ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
    40ec:	defffe04 	addi	sp,sp,-8
    40f0:	dfc00115 	stw	ra,4(sp)
    40f4:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
    40f8:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    40fc:	04000034 	movhi	r16,0
    4100:	841d2104 	addi	r16,r16,29828

  active = alt_irq_pending ();

  do
  {
    i = 0;
    4104:	0005883a 	mov	r2,zero
    mask = 1;
    4108:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    410c:	20ca703a 	and	r5,r4,r3
    4110:	28000b26 	beq	r5,zero,4140 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    4114:	100490fa 	slli	r2,r2,3
    4118:	8085883a 	add	r2,r16,r2
    411c:	10c00017 	ldw	r3,0(r2)
    4120:	11000117 	ldw	r4,4(r2)
    4124:	183ee83a 	callr	r3
    4128:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
    412c:	203ff51e 	bne	r4,zero,4104 <_gp+0xffff4fec>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
    4130:	dfc00117 	ldw	ra,4(sp)
    4134:	dc000017 	ldw	r16,0(sp)
    4138:	dec00204 	addi	sp,sp,8
    413c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
    4140:	18c7883a 	add	r3,r3,r3
      i++;
    4144:	10800044 	addi	r2,r2,1

    } while (1);
    4148:	003ff006 	br	410c <_gp+0xffff4ff4>

Disassembly of section .text:

0000414c <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    414c:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    4150:	dee00014 	ori	sp,sp,32768
    movhi gp, %hi(_gp)
    4154:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    4158:	d6bc4614 	ori	gp,gp,61720
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    415c:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    4160:	109c5414 	ori	r2,r2,29008

    movhi r3, %hi(__bss_end)
    4164:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    4168:	18dd6114 	ori	r3,r3,30084

    beq r2, r3, 1f
    416c:	10c00326 	beq	r2,r3,417c <_start+0x30>

0:
    stw zero, (r2)
    4170:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    4174:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    4178:	10fffd36 	bltu	r2,r3,4170 <_gp+0xffff5058>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    417c:	0006de80 	call	6de8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    4180:	0006ec80 	call	6ec8 <alt_main>

00004184 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    4184:	003fff06 	br	4184 <_gp+0xffff506c>

00004188 <main>:
    FINE_TUNE,
    DO_NOTHING
} state_t;

int main(void)
{
    4188:	deffe404 	addi	sp,sp,-112
    trimdac_cal_line.y_intercept = 0;

    /* Sanity check */
    ASSERT(PKT_MAGIC_IDX == 0);

    memset(&pkt, 0, sizeof(pkt));
    418c:	01800844 	movi	r6,33
    4190:	000b883a 	mov	r5,zero
    4194:	d809883a 	mov	r4,sp
    FINE_TUNE,
    DO_NOTHING
} state_t;

int main(void)
{
    4198:	dfc01b15 	stw	ra,108(sp)
    419c:	dc801415 	stw	r18,80(sp)
    41a0:	dc401315 	stw	r17,76(sp)
    41a4:	dc001215 	stw	r16,72(sp)
    41a8:	df001a15 	stw	fp,104(sp)
    41ac:	ddc01915 	stw	r23,100(sp)
    41b0:	dd801815 	stw	r22,96(sp)
    41b4:	dd401715 	stw	r21,92(sp)
    41b8:	dd001615 	stw	r20,88(sp)
    41bc:	dcc01515 	stw	r19,84(sp)

    /* Marked volatile to ensure we actually read the byte populated by
     * the UART ISR */
    const volatile uint8_t *magic = &pkt.req[PKT_MAGIC_IDX];

    volatile bool have_request = false;
    41c0:	d8001005 	stb	zero,64(sp)
    trimdac_cal_line.y_intercept = 0;

    /* Sanity check */
    ASSERT(PKT_MAGIC_IDX == 0);

    memset(&pkt, 0, sizeof(pkt));
    41c4:	0006cd40 	call	6cd4 <memset>
    pkt.ready = false;
    bladerf_nios_init(&pkt, &vctcxo_tamer_pkt);
    41c8:	d9400904 	addi	r5,sp,36
    41cc:	d809883a 	mov	r4,sp
    41d0:	04000034 	movhi	r16,0

    /* Sanity check */
    ASSERT(PKT_MAGIC_IDX == 0);

    memset(&pkt, 0, sizeof(pkt));
    pkt.ready = false;
    41d4:	d8000805 	stb	zero,32(sp)
    41d8:	841c2404 	addi	r16,r16,28816
    bladerf_nios_init(&pkt, &vctcxo_tamer_pkt);
    41dc:	00047580 	call	4758 <bladerf_nios_init>

    /* Initialize packet handlers */
    for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    41e0:	0023883a 	mov	r17,zero
    41e4:	048001c4 	movi	r18,7
        if (pkt_handlers[i].init != NULL) {
    41e8:	80800017 	ldw	r2,0(r16)
    41ec:	10000126 	beq	r2,zero,41f4 <main+0x6c>
            pkt_handlers[i].init();
    41f0:	103ee83a 	callr	r2
    memset(&pkt, 0, sizeof(pkt));
    pkt.ready = false;
    bladerf_nios_init(&pkt, &vctcxo_tamer_pkt);

    /* Initialize packet handlers */
    for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    41f4:	88800044 	addi	r2,r17,1
    41f8:	1023883a 	mov	r17,r2
    41fc:	10803fcc 	andi	r2,r2,255
    4200:	84000404 	addi	r16,r16,16
    4204:	14bff81e 	bne	r2,r18,41e8 <_gp+0xffff50d0>
    4208:	04c00034 	movhi	r19,0

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
        val = ((uint32_t)resp[i+0]) | (((uint32_t)resp[i+1])<<8) | (((uint32_t)resp[i+2])<<16) | (((uint32_t)resp[i+3])<<24) ;
    420c:	053ffff4 	movhi	r20,65535
    4210:	057ffff4 	movhi	r21,65535
    4214:	05bffff4 	movhi	r22,65535
    4218:	0023883a 	mov	r17,zero
    421c:	0025883a 	mov	r18,zero
    4220:	0021883a 	mov	r16,zero
    4224:	9cdc2304 	addi	r19,r19,28812
    4228:	a51bbc44 	addi	r20,r20,28401
    422c:	ad5bbc84 	addi	r21,r21,28402
    4230:	b59bbc04 	addi	r22,r22,28400
            pkt_handlers[i].init();
        }
    }

    while (run_nios) {
        have_request = HAVE_REQUEST();
    4234:	d8800803 	ldbu	r2,32(sp)
    4238:	d8801005 	stb	r2,64(sp)

        /* We have a command in the UART */
        if (have_request) {
    423c:	d8801003 	ldbu	r2,64(sp)
    4240:	10803fcc 	andi	r2,r2,255
    4244:	10002926 	beq	r2,zero,42ec <main+0x164>
            pkt.ready = false;
    4248:	d8000805 	stb	zero,32(sp)
    424c:	0007883a 	mov	r3,zero
            handler = NULL;
    4250:	000b883a 	mov	r5,zero

            /* Determine which packet handler should receive this message */
            for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    4254:	01801c04 	movi	r6,112
    4258:	1cc5883a 	add	r2,r3,r19
                if (pkt_handlers[i].magic == *magic) {
    425c:	d9000003 	ldbu	r4,0(sp)
    4260:	11c00003 	ldbu	r7,0(r2)
    4264:	21003fcc 	andi	r4,r4,255
    4268:	39000126 	beq	r7,r4,4270 <main+0xe8>
    426c:	2805883a 	mov	r2,r5
    4270:	18c00404 	addi	r3,r3,16
        if (have_request) {
            pkt.ready = false;
            handler = NULL;

            /* Determine which packet handler should receive this message */
            for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    4274:	19800226 	beq	r3,r6,4280 <main+0xf8>
    4278:	100b883a 	mov	r5,r2
    427c:	003ff606 	br	4258 <_gp+0xffff5140>
                if (pkt_handlers[i].magic == *magic) {
                    handler = &pkt_handlers[i];
                }
            }

            if (handler == NULL) {
    4280:	103fec26 	beq	r2,zero,4234 <_gp+0xffff511c>
            /* If building with RESET_RESPONSE_BUF defined, reset response buffer
             * contents to ensure unused values are known values. */
            RESET_RESPONSE_BUF();

            /* Process data and execute requested actions */
            handler->exec(&pkt);
    4284:	10800217 	ldw	r2,8(r2)
    4288:	d809883a 	mov	r4,sp
    428c:	103ee83a 	callr	r2
    4290:	01fffff4 	movhi	r7,65535
    4294:	00e44814 	movui	r3,37152
    4298:	39dbbcc4 	addi	r7,r7,28403
}

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
    429c:	01a44c14 	movui	r6,37168
    42a0:	d8c5883a 	add	r2,sp,r3
        val = ((uint32_t)resp[i+0]) | (((uint32_t)resp[i+1])<<8) | (((uint32_t)resp[i+2])<<16) | (((uint32_t)resp[i+3])<<24) ;
    42a4:	1509883a 	add	r4,r2,r20
        IOWR_32DIRECT(COMMAND_UART_BASE, i, val) ;
    42a8:	21000003 	ldbu	r4,0(r4)
    42ac:	200a923a 	slli	r5,r4,8

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
        val = ((uint32_t)resp[i+0]) | (((uint32_t)resp[i+1])<<8) | (((uint32_t)resp[i+2])<<16) | (((uint32_t)resp[i+3])<<24) ;
    42b0:	1549883a 	add	r4,r2,r21
        IOWR_32DIRECT(COMMAND_UART_BASE, i, val) ;
    42b4:	21000003 	ldbu	r4,0(r4)
    42b8:	2008943a 	slli	r4,r4,16
    42bc:	2908b03a 	or	r4,r5,r4

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
        val = ((uint32_t)resp[i+0]) | (((uint32_t)resp[i+1])<<8) | (((uint32_t)resp[i+2])<<16) | (((uint32_t)resp[i+3])<<24) ;
    42c0:	158b883a 	add	r5,r2,r22
    42c4:	11c5883a 	add	r2,r2,r7
        IOWR_32DIRECT(COMMAND_UART_BASE, i, val) ;
    42c8:	10800003 	ldbu	r2,0(r2)
    42cc:	29400003 	ldbu	r5,0(r5)
    42d0:	1004963a 	slli	r2,r2,24
    42d4:	2148b03a 	or	r4,r4,r5
    42d8:	2084b03a 	or	r2,r4,r2
    42dc:	18800035 	stwio	r2,0(r3)
    42e0:	18c00104 	addi	r3,r3,4
}

INLINE void command_uart_write_response(uint8_t *resp) {
    int i ;
    uint32_t val ;
    for( i = 0 ; i < 16 ; i+=4 ) {
    42e4:	19bfee1e 	bne	r3,r6,42a0 <_gp+0xffff5188>
    42e8:	003fd206 	br	4234 <_gp+0xffff511c>
            /* Write response to host */
            command_uart_write_response(pkt.resp);
        } else {

            /* Temporarily putting the VCTCXO Calibration stuff here. */
            if( vctcxo_tamer_pkt.ready ) {
    42ec:	d8800903 	ldbu	r2,36(sp)
    42f0:	10803fcc 	andi	r2,r2,255
    42f4:	10004626 	beq	r2,zero,4410 <main+0x288>

                vctcxo_tamer_pkt.ready = false;
    42f8:	d8000905 	stb	zero,36(sp)

                switch(tune_state) {
    42fc:	05c00044 	movi	r23,1
    4300:	85c00b26 	beq	r16,r23,4330 <main+0x1a8>
    4304:	80000526 	beq	r16,zero,431c <main+0x194>
    4308:	00800084 	movi	r2,2
    430c:	80800e26 	beq	r16,r2,4348 <main+0x1c0>
    4310:	008000c4 	movi	r2,3
    4314:	80801b26 	beq	r16,r2,4384 <main+0x1fc>
    4318:	00003906 	br	4400 <main+0x278>

                case COARSE_TUNE_MIN:

                    /* Tune to the minimum DAC value */
                    vctcxo_trim_dac_write( 0x08, trimdac_min );
    431c:	014a3d44 	movi	r5,10485
    4320:	01000204 	movi	r4,8
    4324:	0004a0c0 	call	4a0c <vctcxo_trim_dac_write>

                    /* State to enter upon the next interrupt */
                    tune_state = COARSE_TUNE_MAX;
    4328:	b821883a 	mov	r16,r23

                    break;
    432c:	00003406 	br	4400 <main+0x278>
                    /* We have the error from the minimum DAC setting, store it
                     * as the 'x' coordinate for the first point */
                    trimdac_cal_line.point[0].x = vctcxo_tamer_pkt.pps_1s_error;

                    /* Tune to the maximum DAC value */
                    vctcxo_trim_dac_write( 0x08, trimdac_max );
    4330:	017d70d4 	movui	r5,62915
    4334:	01000204 	movi	r4,8

                case COARSE_TUNE_MAX:

                    /* We have the error from the minimum DAC setting, store it
                     * as the 'x' coordinate for the first point */
                    trimdac_cal_line.point[0].x = vctcxo_tamer_pkt.pps_1s_error;
    4338:	dc800a17 	ldw	r18,40(sp)

                    /* Tune to the maximum DAC value */
                    vctcxo_trim_dac_write( 0x08, trimdac_max );

                    /* State to enter upon the next interrupt */
                    tune_state = COARSE_TUNE_DONE;
    433c:	04000084 	movi	r16,2
                    /* We have the error from the minimum DAC setting, store it
                     * as the 'x' coordinate for the first point */
                    trimdac_cal_line.point[0].x = vctcxo_tamer_pkt.pps_1s_error;

                    /* Tune to the maximum DAC value */
                    vctcxo_trim_dac_write( 0x08, trimdac_max );
    4340:	0004a0c0 	call	4a0c <vctcxo_trim_dac_write>

                    /* State to enter upon the next interrupt */
                    tune_state = COARSE_TUNE_DONE;

                    break;
    4344:	00002e06 	br	4400 <main+0x278>

                case COARSE_TUNE_DONE:

                    /* We have the error from the maximum DAC setting, store it
                     * as the 'x' coordinate for the second point */
                    trimdac_cal_line.point[1].x = vctcxo_tamer_pkt.pps_1s_error;
    4348:	d9400a17 	ldw	r5,40(sp)

                    /* We now have two points, so we can calculate the equation
                     * for a line plotted with DAC counts on the Y axis and
                     * error on the X axis. We want a PPM of zero, which ideally
                     * corresponds to the y-intercept of the line. */
                    trimdac_cal_line.slope = ( (trimdac_cal_line.point[1].y - trimdac_cal_line.point[0].y) /
    434c:	01333394 	movui	r4,52430

                    /* Set the trim DAC count to the y-intercept */
                    vctcxo_trim_dac_write( 0x08, trimdac_cal_line.y_intercept );

                    /* State to enter upon the next interrupt */
                    tune_state = FINE_TUNE;
    4350:	040000c4 	movi	r16,3

                    /* We now have two points, so we can calculate the equation
                     * for a line plotted with DAC counts on the Y axis and
                     * error on the X axis. We want a PPM of zero, which ideally
                     * corresponds to the y-intercept of the line. */
                    trimdac_cal_line.slope = ( (trimdac_cal_line.point[1].y - trimdac_cal_line.point[0].y) /
    4354:	2c8bc83a 	sub	r5,r5,r18
    4358:	0006ad00 	call	6ad0 <__divsi3>
                                               (trimdac_cal_line.point[1].x - trimdac_cal_line.point[0].x) );
                    trimdac_cal_line.y_intercept = ( trimdac_cal_line.point[0].y -
                                                     (trimdac_cal_line.slope * trimdac_cal_line.point[0].x) );

                    /* Set the trim DAC count to the y-intercept */
                    vctcxo_trim_dac_write( 0x08, trimdac_cal_line.y_intercept );
    435c:	900b883a 	mov	r5,r18
    4360:	1009883a 	mov	r4,r2

                    /* We now have two points, so we can calculate the equation
                     * for a line plotted with DAC counts on the Y axis and
                     * error on the X axis. We want a PPM of zero, which ideally
                     * corresponds to the y-intercept of the line. */
                    trimdac_cal_line.slope = ( (trimdac_cal_line.point[1].y - trimdac_cal_line.point[0].y) /
    4364:	1023883a 	mov	r17,r2
                                               (trimdac_cal_line.point[1].x - trimdac_cal_line.point[0].x) );
                    trimdac_cal_line.y_intercept = ( trimdac_cal_line.point[0].y -
                                                     (trimdac_cal_line.slope * trimdac_cal_line.point[0].x) );

                    /* Set the trim DAC count to the y-intercept */
                    vctcxo_trim_dac_write( 0x08, trimdac_cal_line.y_intercept );
    4368:	0006c840 	call	6c84 <__mulsi3>
    436c:	014a3d44 	movi	r5,10485
    4370:	288bc83a 	sub	r5,r5,r2
    4374:	297fffcc 	andi	r5,r5,65535
    4378:	01000204 	movi	r4,8
    437c:	0004a0c0 	call	4a0c <vctcxo_trim_dac_write>

                    /* State to enter upon the next interrupt */
                    tune_state = FINE_TUNE;

                    break;
    4380:	00001f06 	br	4400 <main+0x278>
                    /* Check the magnitude of the errors starting with the
                     * one second count. If an error is greater than the maxium
                     * tolerated error, adjust the trim DAC by the error (Hz)
                     * multiplied by the slope (in counts/Hz) and scale the
                     * result by the precision interval (e.g. 1s, 10s, 100s). */
                    if( vctcxo_tamer_pkt.pps_1s_error_flag ) {
    4384:	d8800b03 	ldbu	r2,44(sp)
    4388:	10803fcc 	andi	r2,r2,255
    438c:	10000626 	beq	r2,zero,43a8 <main+0x220>
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_1s_error * trimdac_cal_line.slope)/1)) );
    4390:	d9000a17 	ldw	r4,40(sp)
                     * one second count. If an error is greater than the maxium
                     * tolerated error, adjust the trim DAC by the error (Hz)
                     * multiplied by the slope (in counts/Hz) and scale the
                     * result by the precision interval (e.g. 1s, 10s, 100s). */
                    if( vctcxo_tamer_pkt.pps_1s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
    4394:	880b883a 	mov	r5,r17
    4398:	0006c840 	call	6c84 <__mulsi3>
    439c:	d160000b 	ldhu	r5,-32768(gp)
    43a0:	288bc83a 	sub	r5,r5,r2
    43a4:	00001306 	br	43f4 <main+0x26c>
                            ((vctcxo_tamer_pkt.pps_1s_error * trimdac_cal_line.slope)/1)) );
                    } else if( vctcxo_tamer_pkt.pps_10s_error_flag ) {
    43a8:	d8800d03 	ldbu	r2,52(sp)
    43ac:	10803fcc 	andi	r2,r2,255
    43b0:	10000526 	beq	r2,zero,43c8 <main+0x240>
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_10s_error * trimdac_cal_line.slope)/10)) );
    43b4:	d9400c17 	ldw	r5,48(sp)
                     * result by the precision interval (e.g. 1s, 10s, 100s). */
                    if( vctcxo_tamer_pkt.pps_1s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_1s_error * trimdac_cal_line.slope)/1)) );
                    } else if( vctcxo_tamer_pkt.pps_10s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
    43b8:	8809883a 	mov	r4,r17
    43bc:	0006c840 	call	6c84 <__mulsi3>
    43c0:	017ffd84 	movi	r5,-10
    43c4:	00000706 	br	43e4 <main+0x25c>
                            ((vctcxo_tamer_pkt.pps_10s_error * trimdac_cal_line.slope)/10)) );
                    } else if( vctcxo_tamer_pkt.pps_100s_error_flag ) {
    43c8:	d8800f03 	ldbu	r2,60(sp)
    43cc:	10803fcc 	andi	r2,r2,255
    43d0:	10000b26 	beq	r2,zero,4400 <main+0x278>
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_100s_error * trimdac_cal_line.slope)/100)) );
    43d4:	d9400e17 	ldw	r5,56(sp)
                            ((vctcxo_tamer_pkt.pps_1s_error * trimdac_cal_line.slope)/1)) );
                    } else if( vctcxo_tamer_pkt.pps_10s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
                            ((vctcxo_tamer_pkt.pps_10s_error * trimdac_cal_line.slope)/10)) );
                    } else if( vctcxo_tamer_pkt.pps_100s_error_flag ) {
                        vctcxo_trim_dac_write( 0x08, (vctcxo_trim_dac_value -
    43d8:	8809883a 	mov	r4,r17
    43dc:	0006c840 	call	6c84 <__mulsi3>
    43e0:	017fe704 	movi	r5,-100
    43e4:	1009883a 	mov	r4,r2
    43e8:	0006ad00 	call	6ad0 <__divsi3>
    43ec:	d160000b 	ldhu	r5,-32768(gp)
    43f0:	114b883a 	add	r5,r2,r5
    43f4:	297fffcc 	andi	r5,r5,65535
    43f8:	01000204 	movi	r4,8
    43fc:	0004a0c0 	call	4a0c <vctcxo_trim_dac_write>
                    break;

                } /* switch */

                /* Take PPS counters out of reset */
                vctcxo_tamer_reset_counters( false );
    4400:	0009883a 	mov	r4,zero
    4404:	00044fc0 	call	44fc <vctcxo_tamer_reset_counters>

                /* Enable interrupts */
                vctcxo_tamer_enable_isr( true );
    4408:	01000044 	movi	r4,1
    440c:	00044bc0 	call	44bc <vctcxo_tamer_enable_isr>
    4410:	05c00034 	movhi	r23,0
    4414:	bddc2604 	addi	r23,r23,28824

            } /* VCTCXO Tamer interrupt */

            for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    4418:	0039883a 	mov	fp,zero
    441c:	00c001c4 	movi	r3,7
                if (pkt_handlers[i].do_work != NULL) {
    4420:	b8800017 	ldw	r2,0(r23)
    4424:	10000326 	beq	r2,zero,4434 <main+0x2ac>
                    pkt_handlers[i].do_work();
    4428:	d8c01115 	stw	r3,68(sp)
    442c:	103ee83a 	callr	r2
    4430:	d8c01117 	ldw	r3,68(sp)
                /* Enable interrupts */
                vctcxo_tamer_enable_isr( true );

            } /* VCTCXO Tamer interrupt */

            for (i = 0; i < ARRAY_SIZE(pkt_handlers); i++) {
    4434:	e0800044 	addi	r2,fp,1
    4438:	1039883a 	mov	fp,r2
    443c:	10803fcc 	andi	r2,r2,255
    4440:	bdc00404 	addi	r23,r23,16
    4444:	10fff61e 	bne	r2,r3,4420 <_gp+0xffff5308>
    4448:	003f7a06 	br	4234 <_gp+0xffff511c>

0000444c <si5338_complete_transfer>:
    alt_ic_irq_enable(VCTCXO_TAMER_0_IRQ_INTERRUPT_CONTROLLER_ID, VCTCXO_TAMER_0_IRQ);
}

static void si5338_complete_transfer(uint8_t check_rxack)
{
    if ((IORD_8DIRECT(I2C, OC_I2C_CMD_STATUS) & OC_I2C_TIP) == 0) {
    444c:	00a43d14 	movui	r2,37108
    4450:	10c00023 	ldbuio	r3,0(r2)
    4454:	18c0008c 	andi	r3,r3,2
    4458:	183ffd26 	beq	r3,zero,4450 <_gp+0xffff5338>
        while ( (IORD_8DIRECT(I2C, OC_I2C_CMD_STATUS) & OC_I2C_TIP) == 0);
    }

    while (IORD_8DIRECT(I2C, OC_I2C_CMD_STATUS) & OC_I2C_TIP);
    445c:	10c00023 	ldbuio	r3,0(r2)
    4460:	18c0008c 	andi	r3,r3,2
    4464:	183ffd1e 	bne	r3,zero,445c <_gp+0xffff5344>

    while (check_rxack && (IORD_8DIRECT(I2C, OC_I2C_CMD_STATUS) & OC_I2C_RXACK));
    4468:	21003fcc 	andi	r4,r4,255
    446c:	00e43d14 	movui	r3,37108
    4470:	20000326 	beq	r4,zero,4480 <si5338_complete_transfer+0x34>
    4474:	18800023 	ldbuio	r2,0(r3)
    4478:	1080200c 	andi	r2,r2,128
    447c:	103ffc1e 	bne	r2,zero,4470 <_gp+0xffff5358>
    4480:	f800283a 	ret

00004484 <command_uart_isr>:
    uint32_t val = enable ? 1 : 0 ;
    IOWR_32DIRECT(COMMAND_UART_BASE, 16, val) ;
    return ;
}

static void command_uart_isr(void *context) {
    4484:	2005883a 	mov	r2,r4
    struct pkt_buf *pkt = (struct pkt_buf *)context ;

    /* Reading the request should clear the interrupt */
    command_uart_read_request((uint8_t *)pkt->req) ;
    4488:	00e44814 	movui	r3,37152
}

INLINE void command_uart_read_request(uint8_t *req) {
    int i, x ;
    uint32_t val ;
    for( x = 0 ; x < 16 ; x+=4 ) {
    448c:	01a44c14 	movui	r6,37168
        val = IORD_32DIRECT(COMMAND_UART_BASE, x) ;
    4490:	19400037 	ldwio	r5,0(r3)
    4494:	11c00104 	addi	r7,r2,4
        for( i = 0 ; i < 4 ; i++ ) {
            req[x+i] = val&0xff ;
    4498:	11400005 	stb	r5,0(r2)
    449c:	10800044 	addi	r2,r2,1
            val >>= 8 ;
    44a0:	280ad23a 	srli	r5,r5,8
INLINE void command_uart_read_request(uint8_t *req) {
    int i, x ;
    uint32_t val ;
    for( x = 0 ; x < 16 ; x+=4 ) {
        val = IORD_32DIRECT(COMMAND_UART_BASE, x) ;
        for( i = 0 ; i < 4 ; i++ ) {
    44a4:	11fffc1e 	bne	r2,r7,4498 <_gp+0xffff5380>
    44a8:	18c00104 	addi	r3,r3,4
}

INLINE void command_uart_read_request(uint8_t *req) {
    int i, x ;
    uint32_t val ;
    for( x = 0 ; x < 16 ; x+=4 ) {
    44ac:	19bff81e 	bne	r3,r6,4490 <_gp+0xffff5378>

    /* Tell the main loop that there is a request pending */
    pkt->ready = true ;
    44b0:	00800044 	movi	r2,1
    44b4:	20800805 	stb	r2,32(r4)
    44b8:	f800283a 	ret

000044bc <vctcxo_tamer_enable_isr>:

    return;
}

void vctcxo_tamer_enable_isr(bool enable) {
    if( enable ) {
    44bc:	21003fcc 	andi	r4,r4,255
    44c0:	d0a00e03 	ldbu	r2,-32712(gp)
    44c4:	20000226 	beq	r4,zero,44d0 <vctcxo_tamer_enable_isr+0x14>
        vctcxo_tamer_ctrl_reg |= VT_CTRL_IRQ_EN;
    44c8:	10800414 	ori	r2,r2,16
    44cc:	00000106 	br	44d4 <vctcxo_tamer_enable_isr+0x18>
    } else {
        vctcxo_tamer_ctrl_reg &= ~VT_CTRL_IRQ_EN;
    44d0:	10803bcc 	andi	r2,r2,239
    44d4:	d0a00e05 	stb	r2,-32712(gp)
uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
}

void vctcxo_tamer_write(uint8_t addr, uint8_t data) {
    IOWR_8DIRECT(VCTCXO_TAMER_0_BASE, addr, data);
    44d8:	d0e00e03 	ldbu	r3,-32712(gp)
    44dc:	00a4c014 	movui	r2,37632
    44e0:	10c00025 	stbio	r3,0(r2)
    44e4:	f800283a 	ret

000044e8 <vctcxo_tamer_clear_isr>:
    44e8:	d0a00e03 	ldbu	r2,-32712(gp)
    44ec:	00e4c014 	movui	r3,37632
    44f0:	10800814 	ori	r2,r2,32
    44f4:	18800025 	stbio	r2,0(r3)
    44f8:	f800283a 	ret

000044fc <vctcxo_tamer_reset_counters>:
    vctcxo_tamer_write(VT_CTRL_ADDR, vctcxo_tamer_ctrl_reg | VT_CTRL_IRQ_CLR);
    return;
}

void vctcxo_tamer_reset_counters(bool reset) {
    if( reset ) {
    44fc:	21003fcc 	andi	r4,r4,255
    4500:	d0a00e03 	ldbu	r2,-32712(gp)
    4504:	20000226 	beq	r4,zero,4510 <vctcxo_tamer_reset_counters+0x14>
        vctcxo_tamer_ctrl_reg |= VT_CTRL_RESET;
    4508:	10800054 	ori	r2,r2,1
    450c:	00000106 	br	4514 <vctcxo_tamer_reset_counters+0x18>
    } else {
        vctcxo_tamer_ctrl_reg &= ~VT_CTRL_RESET;
    4510:	10803f8c 	andi	r2,r2,254
    4514:	d0a00e05 	stb	r2,-32712(gp)
uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
}

void vctcxo_tamer_write(uint8_t addr, uint8_t data) {
    IOWR_8DIRECT(VCTCXO_TAMER_0_BASE, addr, data);
    4518:	d0e00e03 	ldbu	r3,-32712(gp)
    451c:	00a4c014 	movui	r2,37632
    4520:	10c00025 	stbio	r3,0(r2)
    4524:	f800283a 	ret

00004528 <vctcxo_tamer_set_tune_mode.part.0>:

    vctcxo_tamer_write(VT_CTRL_ADDR, vctcxo_tamer_ctrl_reg);
    return;
}

void vctcxo_tamer_set_tune_mode(bladerf_vctcxo_tamer_mode mode) {
    4528:	defffd04 	addi	sp,sp,-12
    452c:	dc000015 	stw	r16,0(sp)
    4530:	2021883a 	mov	r16,r4

    switch (mode) {
        case BLADERF_VCTCXO_TAMER_DISABLED:
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            vctcxo_tamer_enable_isr(false);
    4534:	0009883a 	mov	r4,zero

    vctcxo_tamer_write(VT_CTRL_ADDR, vctcxo_tamer_ctrl_reg);
    return;
}

void vctcxo_tamer_set_tune_mode(bladerf_vctcxo_tamer_mode mode) {
    4538:	dfc00215 	stw	ra,8(sp)
    453c:	dc400115 	stw	r17,4(sp)

    switch (mode) {
        case BLADERF_VCTCXO_TAMER_DISABLED:
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            vctcxo_tamer_enable_isr(false);
    4540:	00044bc0 	call	44bc <vctcxo_tamer_enable_isr>
            return;
    }

    /* Set tuning mode */
    vctcxo_tamer_ctrl_reg &= ~VT_CTRL_TUNE_MODE;
    vctcxo_tamer_ctrl_reg |= (((uint8_t) mode) << 6);
    4544:	80803fcc 	andi	r2,r16,255
    4548:	100691ba 	slli	r3,r2,6
    454c:	d0a00e03 	ldbu	r2,-32712(gp)
    4550:	10800fcc 	andi	r2,r2,63
    4554:	1884b03a 	or	r2,r3,r2
    4558:	d0a00e05 	stb	r2,-32712(gp)
uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
}

void vctcxo_tamer_write(uint8_t addr, uint8_t data) {
    IOWR_8DIRECT(VCTCXO_TAMER_0_BASE, addr, data);
    455c:	00e4c014 	movui	r3,37632
    4560:	18800025 	stbio	r2,0(r3)
    vctcxo_tamer_ctrl_reg &= ~VT_CTRL_TUNE_MODE;
    vctcxo_tamer_ctrl_reg |= (((uint8_t) mode) << 6);
    vctcxo_tamer_write(VT_CTRL_ADDR, vctcxo_tamer_ctrl_reg);

    /* Reset the counters */
    vctcxo_tamer_reset_counters( true );
    4564:	04400044 	movi	r17,1
    4568:	8809883a 	mov	r4,r17
    456c:	00044fc0 	call	44fc <vctcxo_tamer_reset_counters>

    /* Take counters out of reset if tuning mode is not DISABLED */
    if( mode != 0x00 ) {
    4570:	80000a26 	beq	r16,zero,459c <vctcxo_tamer_set_tune_mode.part.0+0x74>
        vctcxo_tamer_reset_counters( false );
    4574:	0009883a 	mov	r4,zero
    }

    switch (mode) {
    4578:	843fffc4 	addi	r16,r16,-1
    /* Reset the counters */
    vctcxo_tamer_reset_counters( true );

    /* Take counters out of reset if tuning mode is not DISABLED */
    if( mode != 0x00 ) {
        vctcxo_tamer_reset_counters( false );
    457c:	00044fc0 	call	44fc <vctcxo_tamer_reset_counters>
    }

    switch (mode) {
    4580:	8c000636 	bltu	r17,r16,459c <vctcxo_tamer_set_tune_mode.part.0+0x74>
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            vctcxo_tamer_enable_isr(true);
    4584:	8809883a 	mov	r4,r17
            /* Leave ISR disabled otherwise */
            break;
    }

    return;
}
    4588:	dfc00217 	ldw	ra,8(sp)
    458c:	dc400117 	ldw	r17,4(sp)
    4590:	dc000017 	ldw	r16,0(sp)
    4594:	dec00304 	addi	sp,sp,12
    }

    switch (mode) {
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            vctcxo_tamer_enable_isr(true);
    4598:	00044bc1 	jmpi	44bc <vctcxo_tamer_enable_isr>
            /* Leave ISR disabled otherwise */
            break;
    }

    return;
}
    459c:	dfc00217 	ldw	ra,8(sp)
    45a0:	dc400117 	ldw	r17,4(sp)
    45a4:	dc000017 	ldw	r16,0(sp)
    45a8:	dec00304 	addi	sp,sp,12
    45ac:	f800283a 	ret

000045b0 <vctcxo_tamer_set_tune_mode>:
    return;
}

void vctcxo_tamer_set_tune_mode(bladerf_vctcxo_tamer_mode mode) {

    switch (mode) {
    45b0:	00800084 	movi	r2,2
    45b4:	11000136 	bltu	r2,r4,45bc <vctcxo_tamer_set_tune_mode+0xc>
            /* Leave ISR disabled otherwise */
            break;
    }

    return;
}
    45b8:	00045281 	jmpi	4528 <vctcxo_tamer_set_tune_mode.part.0>
    45bc:	f800283a 	ret

000045c0 <vctcxo_tamer_get_tune_mode>:

    return value;
}

uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
    45c0:	00a4c014 	movui	r2,37632
    45c4:	10800023 	ldbuio	r2,0(r2)
bladerf_vctcxo_tamer_mode vctcxo_tamer_get_tune_mode()
{
    uint8_t tmp = vctcxo_tamer_read(VT_CTRL_ADDR);
    tmp = (tmp & VT_CTRL_TUNE_MODE) >> 6;

    switch (tmp) {
    45c8:	00c00084 	movi	r3,2
}

bladerf_vctcxo_tamer_mode vctcxo_tamer_get_tune_mode()
{
    uint8_t tmp = vctcxo_tamer_read(VT_CTRL_ADDR);
    tmp = (tmp & VT_CTRL_TUNE_MODE) >> 6;
    45cc:	10803fcc 	andi	r2,r2,255

    switch (tmp) {
    45d0:	1004d1ba 	srli	r2,r2,6
    45d4:	1880012e 	bgeu	r3,r2,45dc <vctcxo_tamer_get_tune_mode+0x1c>
        case BLADERF_VCTCXO_TAMER_1_PPS:
        case BLADERF_VCTCXO_TAMER_10_MHZ:
            return (bladerf_vctcxo_tamer_mode) tmp;

        default:
            return BLADERF_VCTCXO_TAMER_INVALID;
    45d8:	00bfffc4 	movi	r2,-1
    }
}
    45dc:	f800283a 	ret

000045e0 <vctcxo_tamer_read_count>:
int32_t vctcxo_tamer_read_count(uint8_t addr) {
    uint32_t base = VCTCXO_TAMER_0_BASE;
    uint8_t offset = addr;
    int32_t value = 0;

    value  = IORD_8DIRECT(base, offset++);
    45e0:	20803fcc 	andi	r2,r4,255
    45e4:	0164c014 	movui	r5,37632
    45e8:	1145883a 	add	r2,r2,r5
    45ec:	10800023 	ldbuio	r2,0(r2)
    45f0:	11803fcc 	andi	r6,r2,255
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 8;
    45f4:	20800044 	addi	r2,r4,1
    45f8:	10803fcc 	andi	r2,r2,255
    45fc:	1145883a 	add	r2,r2,r5
    4600:	10800023 	ldbuio	r2,0(r2)
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 16;
    4604:	20c00084 	addi	r3,r4,2
    4608:	18c03fcc 	andi	r3,r3,255
    uint32_t base = VCTCXO_TAMER_0_BASE;
    uint8_t offset = addr;
    int32_t value = 0;

    value  = IORD_8DIRECT(base, offset++);
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 8;
    460c:	10803fcc 	andi	r2,r2,255
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 16;
    4610:	1947883a 	add	r3,r3,r5
    4614:	18c00023 	ldbuio	r3,0(r3)
    4618:	18c03fcc 	andi	r3,r3,255
    461c:	1806943a 	slli	r3,r3,16
    4620:	1004923a 	slli	r2,r2,8
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 24;
    4624:	210000c4 	addi	r4,r4,3
    4628:	21003fcc 	andi	r4,r4,255
    uint8_t offset = addr;
    int32_t value = 0;

    value  = IORD_8DIRECT(base, offset++);
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 8;
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 16;
    462c:	10c4b03a 	or	r2,r2,r3
    4630:	1184b03a 	or	r2,r2,r6
    value |= ((int32_t) IORD_8DIRECT(base, offset++)) << 24;
    4634:	2149883a 	add	r4,r4,r5
    4638:	20c00023 	ldbuio	r3,0(r4)

    return value;
    463c:	1806963a 	slli	r3,r3,24
}
    4640:	1884b03a 	or	r2,r3,r2
    4644:	f800283a 	ret

00004648 <vctcxo_tamer_isr>:
    pkt->ready = true ;

    return ;
}

static void vctcxo_tamer_isr(void *context) {
    4648:	defffd04 	addi	sp,sp,-12
    464c:	dc000015 	stw	r16,0(sp)
    4650:	2021883a 	mov	r16,r4
    struct vctcxo_tamer_pkt_buf *pkt = (struct vctcxo_tamer_pkt_buf *)context;
    uint8_t error_status = 0x00;

    /* Disable interrupts */
    vctcxo_tamer_enable_isr( false );
    4654:	0009883a 	mov	r4,zero
    pkt->ready = true ;

    return ;
}

static void vctcxo_tamer_isr(void *context) {
    4658:	dfc00215 	stw	ra,8(sp)
    465c:	dc400115 	stw	r17,4(sp)
    struct vctcxo_tamer_pkt_buf *pkt = (struct vctcxo_tamer_pkt_buf *)context;
    uint8_t error_status = 0x00;

    /* Disable interrupts */
    vctcxo_tamer_enable_isr( false );
    4660:	00044bc0 	call	44bc <vctcxo_tamer_enable_isr>

    /* Reset (stop) the counters */
    vctcxo_tamer_reset_counters( true );
    4664:	04400044 	movi	r17,1
    4668:	8809883a 	mov	r4,r17
    466c:	00044fc0 	call	44fc <vctcxo_tamer_reset_counters>

    /* Read the current count values */
    pkt->pps_1s_error   = vctcxo_tamer_read_count(VT_ERR_1S_ADDR);
    4670:	01000104 	movi	r4,4
    4674:	00045e00 	call	45e0 <vctcxo_tamer_read_count>
    4678:	80800115 	stw	r2,4(r16)
    pkt->pps_10s_error  = vctcxo_tamer_read_count(VT_ERR_10S_ADDR);
    467c:	01000304 	movi	r4,12
    4680:	00045e00 	call	45e0 <vctcxo_tamer_read_count>
    4684:	80800315 	stw	r2,12(r16)
    pkt->pps_100s_error = vctcxo_tamer_read_count(VT_ERR_100S_ADDR);
    4688:	01000504 	movi	r4,20
    468c:	00045e00 	call	45e0 <vctcxo_tamer_read_count>
    4690:	80800515 	stw	r2,20(r16)

    return value;
}

uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
    4694:	00a4c054 	movui	r2,37633
    4698:	10c00023 	ldbuio	r3,0(r2)
    469c:	18c03fcc 	andi	r3,r3,255
    46a0:	18803fcc 	andi	r2,r3,255

    /* Read the error status register */
    error_status = vctcxo_tamer_read(VT_STAT_ADDR);

    /* Set the appropriate flags in the packet buffer */
    pkt->pps_1s_error_flag   = (error_status & VT_STAT_ERR_1S)   ? true : false;
    46a4:	1c46703a 	and	r3,r3,r17
    46a8:	80c00205 	stb	r3,8(r16)
    pkt->pps_10s_error_flag  = (error_status & VT_STAT_ERR_10S)  ? true : false;
    46ac:	1446d83a 	srl	r3,r2,r17
    pkt->pps_100s_error_flag = (error_status & VT_STAT_ERR_100S) ? true : false;
    46b0:	1004d0ba 	srli	r2,r2,2
    /* Read the error status register */
    error_status = vctcxo_tamer_read(VT_STAT_ADDR);

    /* Set the appropriate flags in the packet buffer */
    pkt->pps_1s_error_flag   = (error_status & VT_STAT_ERR_1S)   ? true : false;
    pkt->pps_10s_error_flag  = (error_status & VT_STAT_ERR_10S)  ? true : false;
    46b4:	1c46703a 	and	r3,r3,r17
    46b8:	80c00405 	stb	r3,16(r16)
    pkt->pps_100s_error_flag = (error_status & VT_STAT_ERR_100S) ? true : false;
    46bc:	1444703a 	and	r2,r2,r17
    46c0:	80800605 	stb	r2,24(r16)

    /* Clear interrupt */
    vctcxo_tamer_clear_isr();
    46c4:	00044e80 	call	44e8 <vctcxo_tamer_clear_isr>

    /* Tell the main loop that there is a request pending */
    pkt->ready = true;
    46c8:	84400005 	stb	r17,0(r16)

    return;
}
    46cc:	dfc00217 	ldw	ra,8(sp)
    46d0:	dc400117 	ldw	r17,4(sp)
    46d4:	dc000017 	ldw	r16,0(sp)
    46d8:	dec00304 	addi	sp,sp,12
    46dc:	f800283a 	ret

000046e0 <vctcxo_tamer_read>:

    return value;
}

uint8_t vctcxo_tamer_read(uint8_t addr) {
    return (uint8_t)IORD_8DIRECT(VCTCXO_TAMER_0_BASE, addr);
    46e0:	00a4c014 	movui	r2,37632
    46e4:	21003fcc 	andi	r4,r4,255
    46e8:	2089883a 	add	r4,r4,r2
}
    46ec:	20800023 	ldbuio	r2,0(r4)
    46f0:	f800283a 	ret

000046f4 <vctcxo_tamer_write>:

void vctcxo_tamer_write(uint8_t addr, uint8_t data) {
    IOWR_8DIRECT(VCTCXO_TAMER_0_BASE, addr, data);
    46f4:	00a4c014 	movui	r2,37632
    46f8:	21003fcc 	andi	r4,r4,255
    46fc:	2089883a 	add	r4,r4,r2
    4700:	21400025 	stbio	r5,0(r4)
    4704:	f800283a 	ret

00004708 <tamer_schedule>:
}

void tamer_schedule(bladerf_module m, uint64_t time) {
    uint32_t base = (m == BLADERF_MODULE_RX) ? RX_TAMER_BASE : TX_TAMER_BASE ;
    4708:	20000226 	beq	r4,zero,4714 <tamer_schedule+0xc>
    470c:	00a45014 	movui	r2,37184
    4710:	00000106 	br	4718 <tamer_schedule+0x10>
    4714:	00a45814 	movui	r2,37216

    /* Set the holding time */
    IOWR_8DIRECT(base, 0, (time>> 0)&0xff) ;
    4718:	11400025 	stbio	r5,0(r2)
    IOWR_8DIRECT(base, 1, (time>> 8)&0xff) ;
    471c:	2806d23a 	srli	r3,r5,8
    4720:	10c00065 	stbio	r3,1(r2)
    IOWR_8DIRECT(base, 2, (time>>16)&0xff) ;
    4724:	2806d43a 	srli	r3,r5,16
    4728:	10c000a5 	stbio	r3,2(r2)
    IOWR_8DIRECT(base, 3, (time>>24)&0xff) ;
    472c:	280ad63a 	srli	r5,r5,24
    4730:	114000e5 	stbio	r5,3(r2)
    IOWR_8DIRECT(base, 4, (time>>32)&0xff) ;
    4734:	11800125 	stbio	r6,4(r2)
    IOWR_8DIRECT(base, 5, (time>>40)&0xff) ;
    4738:	3006d23a 	srli	r3,r6,8
    473c:	10c00165 	stbio	r3,5(r2)
    IOWR_8DIRECT(base, 6, (time>>48)&0xff) ;
    4740:	3006d43a 	srli	r3,r6,16
    4744:	10c001a5 	stbio	r3,6(r2)
    IOWR_8DIRECT(base, 7, (time>>54)&0xff) ;
    4748:	300cd5ba 	srli	r6,r6,22
    474c:	118001e5 	stbio	r6,7(r2)

    /* Commit it and arm the comparison */
    IOWR_8DIRECT(base, 8, 0) ;
    4750:	10000225 	stbio	zero,8(r2)
    4754:	f800283a 	ret

00004758 <bladerf_nios_init>:

    return ;
}

void bladerf_nios_init(struct pkt_buf *pkt, struct vctcxo_tamer_pkt_buf *vctcxo_tamer_pkt) {
    4758:	defffc04 	addi	sp,sp,-16
    475c:	dc400215 	stw	r17,8(sp)
    4760:	dfc00315 	stw	ra,12(sp)
    4764:	dc000115 	stw	r16,4(sp)
    4768:	2823883a 	mov	r17,r5
    /* Set the prescaler for 400kHz with an 80MHz clock:
     *      (prescaler = clock / (5*desired) - 1)
     */
    IOWR_16DIRECT(I2C, OC_I2C_PRESCALER, 39);
    476c:	00a43c14 	movui	r2,37104
    4770:	00c009c4 	movi	r3,39
    4774:	10c0002d 	sthio	r3,0(r2)
    IOWR_8DIRECT(I2C, OC_I2C_CTRL, OC_I2C_ENABLE);
    4778:	00a43c94 	movui	r2,37106
    477c:	00ffe004 	movi	r3,-128
    4780:	10c00025 	stbio	r3,0(r2)

    /* Set the IQ Correction parameters to 0 */
    IOWR_ALTERA_AVALON_PIO_DATA(IQ_CORR_RX_PHASE_GAIN_BASE, DEFAULT_CORRECTION);
    4784:	00840004 	movi	r2,4096
    4788:	00e43414 	movui	r3,37072
    478c:	18800035 	stwio	r2,0(r3)
    IOWR_ALTERA_AVALON_PIO_DATA(IQ_CORR_TX_PHASE_GAIN_BASE, DEFAULT_CORRECTION);
    4790:	00e43014 	movui	r3,37056
    4794:	18800035 	stwio	r2,0(r3)

    /* Disable all triggering */
    IOWR_ALTERA_AVALON_PIO_DATA(TX_TRIGGER_CTL_BASE, 0x00);
    4798:	0005883a 	mov	r2,zero
    479c:	00e50814 	movui	r3,37920
    47a0:	18800035 	stwio	r2,0(r3)
    IOWR_ALTERA_AVALON_PIO_DATA(RX_TRIGGER_CTL_BASE, 0x00);
    47a4:	00e50014 	movui	r3,37888
    47a8:	18800035 	stwio	r2,0(r3)

    /* Register Command UART ISR */
    alt_ic_isr_register(
    47ac:	040001c4 	movi	r16,7
    47b0:	01800034 	movhi	r6,0
    47b4:	200f883a 	mov	r7,r4
    47b8:	800b883a 	mov	r5,r16
    47bc:	d8000015 	stw	zero,0(sp)
    47c0:	31912104 	addi	r6,r6,17540
    47c4:	0009883a 	mov	r4,zero
    47c8:	0006cf40 	call	6cf4 <alt_ic_isr_register>
        pkt,
        NULL
    ) ;

    /* Register the VCTCXO Tamer ISR */
    alt_ic_isr_register(
    47cc:	01800034 	movhi	r6,0
    47d0:	880f883a 	mov	r7,r17
    47d4:	31919204 	addi	r6,r6,17992
    47d8:	000b883a 	mov	r5,zero
    47dc:	d8000015 	stw	zero,0(sp)
    47e0:	0009883a 	mov	r4,zero
    47e4:	0006cf40 	call	6cf4 <alt_ic_isr_register>
    47e8:	0009883a 	mov	r4,zero
    47ec:	00045280 	call	4528 <vctcxo_tamer_set_tune_mode.part.0>
/* Define a cached version of the VCTCXO tamer control register */
uint8_t vctcxo_tamer_ctrl_reg = 0x00;

static void command_uart_enable_isr(bool enable) {
    uint32_t val = enable ? 1 : 0 ;
    IOWR_32DIRECT(COMMAND_UART_BASE, 16, val) ;
    47f0:	00a44c14 	movui	r2,37168
    47f4:	00c00044 	movi	r3,1
    47f8:	10c00035 	stwio	r3,0(r2)
    /* Default VCTCXO Tamer and its interrupts to be disabled. */
    vctcxo_tamer_set_tune_mode(BLADERF_VCTCXO_TAMER_DISABLED);

    /* Enable interrupts */
    command_uart_enable_isr(true) ;
    alt_ic_irq_enable(COMMAND_UART_IRQ_INTERRUPT_CONTROLLER_ID, COMMAND_UART_IRQ);
    47fc:	800b883a 	mov	r5,r16
    4800:	0009883a 	mov	r4,zero
    4804:	0006cf80 	call	6cf8 <alt_ic_irq_enable>
    alt_ic_irq_enable(VCTCXO_TAMER_0_IRQ_INTERRUPT_CONTROLLER_ID, VCTCXO_TAMER_0_IRQ);
    4808:	000b883a 	mov	r5,zero
    480c:	0009883a 	mov	r4,zero
}
    4810:	dfc00317 	ldw	ra,12(sp)
    4814:	dc400217 	ldw	r17,8(sp)
    4818:	dc000117 	ldw	r16,4(sp)
    481c:	dec00404 	addi	sp,sp,16
    vctcxo_tamer_set_tune_mode(BLADERF_VCTCXO_TAMER_DISABLED);

    /* Enable interrupts */
    command_uart_enable_isr(true) ;
    alt_ic_irq_enable(COMMAND_UART_IRQ_INTERRUPT_CONTROLLER_ID, COMMAND_UART_IRQ);
    alt_ic_irq_enable(VCTCXO_TAMER_0_IRQ_INTERRUPT_CONTROLLER_ID, VCTCXO_TAMER_0_IRQ);
    4820:	0006cf81 	jmpi	6cf8 <alt_ic_irq_enable>

00004824 <spi_arbiter_lock>:

void spi_arbiter_lock()
{
    uint8_t data;

    IOWR_32DIRECT(ARBITER_0_BASE, 0, 1);
    4824:	00a54014 	movui	r2,38144
    4828:	00c00044 	movi	r3,1
    482c:	10c00035 	stwio	r3,0(r2)

    do {
        data = IORD_8DIRECT(ARBITER_0_BASE, 1);
    4830:	00e54054 	movui	r3,38145
    4834:	18800023 	ldbuio	r2,0(r3)
    } while((data & 1) == 0);
    4838:	1080004c 	andi	r2,r2,1
    483c:	103ffd26 	beq	r2,zero,4834 <_gp+0xffff571c>
}
    4840:	f800283a 	ret

00004844 <spi_arbiter_unlock>:

void spi_arbiter_unlock()
{
    IOWR_32DIRECT(ARBITER_0_BASE, 0, 2);
    4844:	00a54014 	movui	r2,38144
    4848:	00c00084 	movi	r3,2
    484c:	10c00035 	stwio	r3,0(r2)
    4850:	f800283a 	ret

00004854 <lms6_read>:
}

uint8_t lms6_read(uint8_t addr)
{
    4854:	defffe04 	addi	sp,sp,-8
    4858:	dc000015 	stw	r16,0(sp)
    485c:	dfc00115 	stw	ra,4(sp)
    4860:	2021883a 	mov	r16,r4
    uint8_t data;

    spi_arbiter_lock();
    4864:	00048240 	call	4824 <spi_arbiter_lock>
    data = IORD_8DIRECT(LMS_SPI_BASE, addr);
    4868:	81003fcc 	andi	r4,r16,255
    486c:	00a48014 	movui	r2,37376
    4870:	2089883a 	add	r4,r4,r2
    4874:	20800023 	ldbuio	r2,0(r4)
    } while((data & 1) == 0);
}

void spi_arbiter_unlock()
{
    IOWR_32DIRECT(ARBITER_0_BASE, 0, 2);
    4878:	00e54014 	movui	r3,38144
    487c:	01000084 	movi	r4,2
    4880:	19000035 	stwio	r4,0(r3)
    spi_arbiter_lock();
    data = IORD_8DIRECT(LMS_SPI_BASE, addr);
    spi_arbiter_unlock();

    return data;
}
    4884:	dfc00117 	ldw	ra,4(sp)
    4888:	dc000017 	ldw	r16,0(sp)
    488c:	dec00204 	addi	sp,sp,8
    4890:	f800283a 	ret

00004894 <lms6_write>:

void lms6_write(uint8_t addr, uint8_t data)
{
    4894:	defffd04 	addi	sp,sp,-12
    4898:	dc400115 	stw	r17,4(sp)
    489c:	dc000015 	stw	r16,0(sp)
    48a0:	dfc00215 	stw	ra,8(sp)
    48a4:	2021883a 	mov	r16,r4
    48a8:	2823883a 	mov	r17,r5
    spi_arbiter_lock();
    48ac:	00048240 	call	4824 <spi_arbiter_lock>
    IOWR_8DIRECT(LMS_SPI_BASE, addr, data);
    48b0:	81003fcc 	andi	r4,r16,255
    48b4:	00a48014 	movui	r2,37376
    48b8:	2089883a 	add	r4,r4,r2
    48bc:	24400025 	stbio	r17,0(r4)
    } while((data & 1) == 0);
}

void spi_arbiter_unlock()
{
    IOWR_32DIRECT(ARBITER_0_BASE, 0, 2);
    48c0:	00a54014 	movui	r2,38144
    48c4:	00c00084 	movi	r3,2
    48c8:	10c00035 	stwio	r3,0(r2)
void lms6_write(uint8_t addr, uint8_t data)
{
    spi_arbiter_lock();
    IOWR_8DIRECT(LMS_SPI_BASE, addr, data);
    spi_arbiter_unlock();
}
    48cc:	dfc00217 	ldw	ra,8(sp)
    48d0:	dc400117 	ldw	r17,4(sp)
    48d4:	dc000017 	ldw	r16,0(sp)
    48d8:	dec00304 	addi	sp,sp,12
    48dc:	f800283a 	ret

000048e0 <si5338_read>:

uint8_t si5338_read(uint8_t addr)
{
    48e0:	defffa04 	addi	sp,sp,-24
    48e4:	dd000415 	stw	r20,16(sp)
    48e8:	dc000015 	stw	r16,0(sp)
    48ec:	dfc00515 	stw	ra,20(sp)
    48f0:	dcc00315 	stw	r19,12(sp)
    48f4:	dc800215 	stw	r18,8(sp)
    48f8:	dc400115 	stw	r17,4(sp)
    48fc:	2029883a 	mov	r20,r4
    uint8_t data;

    /* Set the address to the Si5338 */
    IOWR_8DIRECT(I2C, OC_I2C_DATA, SI5338_I2C);
    4900:	04243cd4 	movui	r16,37107
    4904:	00bff804 	movi	r2,-32
    4908:	80800025 	stbio	r2,0(r16)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_STA | OC_I2C_WR);
    490c:	04ffe404 	movi	r19,-112
    4910:	04643d14 	movui	r17,37108
    4914:	8cc00025 	stbio	r19,0(r17)
    si5338_complete_transfer(1);
    4918:	04800044 	movi	r18,1
    491c:	9009883a 	mov	r4,r18
    4920:	000444c0 	call	444c <si5338_complete_transfer>

    IOWR_8DIRECT(I2C, OC_I2C_DATA, addr);
    4924:	85000025 	stbio	r20,0(r16)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    4928:	00801404 	movi	r2,80
    492c:	88800025 	stbio	r2,0(r17)
    si5338_complete_transfer(1) ;
    4930:	9009883a 	mov	r4,r18
    4934:	000444c0 	call	444c <si5338_complete_transfer>

    /* Next transfer is a read operation, so '1' in the read/write bit */
    IOWR_8DIRECT(I2C, OC_I2C_DATA, SI5338_I2C | 1);
    4938:	00bff844 	movi	r2,-31
    493c:	80800025 	stbio	r2,0(r16)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_STA | OC_I2C_WR);
    4940:	8cc00025 	stbio	r19,0(r17)
    si5338_complete_transfer(1) ;
    4944:	9009883a 	mov	r4,r18
    4948:	000444c0 	call	444c <si5338_complete_transfer>

    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_RD | OC_I2C_NACK | OC_I2C_STO);
    494c:	00801a04 	movi	r2,104
    4950:	88800025 	stbio	r2,0(r17)
    si5338_complete_transfer(0);
    4954:	0009883a 	mov	r4,zero
    4958:	000444c0 	call	444c <si5338_complete_transfer>

    data = IORD_8DIRECT(I2C, OC_I2C_DATA);
    return data;
}
    495c:	80800023 	ldbuio	r2,0(r16)
    4960:	dfc00517 	ldw	ra,20(sp)
    4964:	dd000417 	ldw	r20,16(sp)
    4968:	dcc00317 	ldw	r19,12(sp)
    496c:	dc800217 	ldw	r18,8(sp)
    4970:	dc400117 	ldw	r17,4(sp)
    4974:	dc000017 	ldw	r16,0(sp)
    4978:	dec00604 	addi	sp,sp,24
    497c:	f800283a 	ret

00004980 <si5338_write>:

void si5338_write(uint8_t addr, uint8_t data)
{
    4980:	defffa04 	addi	sp,sp,-24
    4984:	dd000415 	stw	r20,16(sp)
    4988:	dcc00315 	stw	r19,12(sp)
    498c:	dc400115 	stw	r17,4(sp)
    4990:	dfc00515 	stw	ra,20(sp)
    4994:	dc800215 	stw	r18,8(sp)
    4998:	dc000015 	stw	r16,0(sp)
    499c:	2029883a 	mov	r20,r4
    49a0:	2827883a 	mov	r19,r5
    /* Set the address to the Si5338 */
    IOWR_8DIRECT(I2C, OC_I2C_DATA, SI5338_I2C) ;
    49a4:	04643cd4 	movui	r17,37107
    49a8:	00bff804 	movi	r2,-32
    49ac:	88800025 	stbio	r2,0(r17)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_STA | OC_I2C_WR);
    49b0:	04243d14 	movui	r16,37108
    49b4:	00bfe404 	movi	r2,-112
    49b8:	80800025 	stbio	r2,0(r16)
    si5338_complete_transfer(1);
    49bc:	04800044 	movi	r18,1
    49c0:	9009883a 	mov	r4,r18
    49c4:	000444c0 	call	444c <si5338_complete_transfer>

    IOWR_8DIRECT(I2C, OC_I2C_DATA, addr);
    49c8:	8d000025 	stbio	r20,0(r17)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR);
    49cc:	00800404 	movi	r2,16
    49d0:	80800025 	stbio	r2,0(r16)
    si5338_complete_transfer(1);
    49d4:	9009883a 	mov	r4,r18
    49d8:	000444c0 	call	444c <si5338_complete_transfer>

    IOWR_8DIRECT(I2C, OC_I2C_DATA, data);
    49dc:	8cc00025 	stbio	r19,0(r17)
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    49e0:	00801404 	movi	r2,80
    49e4:	80800025 	stbio	r2,0(r16)
    si5338_complete_transfer(0);
    49e8:	0009883a 	mov	r4,zero
}
    49ec:	dfc00517 	ldw	ra,20(sp)
    49f0:	dd000417 	ldw	r20,16(sp)
    49f4:	dcc00317 	ldw	r19,12(sp)
    49f8:	dc800217 	ldw	r18,8(sp)
    49fc:	dc400117 	ldw	r17,4(sp)
    4a00:	dc000017 	ldw	r16,0(sp)
    4a04:	dec00604 	addi	sp,sp,24
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR);
    si5338_complete_transfer(1);

    IOWR_8DIRECT(I2C, OC_I2C_DATA, data);
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    si5338_complete_transfer(0);
    4a08:	000444c1 	jmpi	444c <si5338_complete_transfer>

00004a0c <vctcxo_trim_dac_write>:
}

void vctcxo_trim_dac_write(uint8_t cmd, uint16_t val)
{
    uint8_t data[3] = {
    4a0c:	2804d23a 	srli	r2,r5,8
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    si5338_complete_transfer(0);
}

void vctcxo_trim_dac_write(uint8_t cmd, uint16_t val)
{
    4a10:	defffb04 	addi	sp,sp,-20
    uint8_t data[3] = {
    4a14:	d9000305 	stb	r4,12(sp)
    4a18:	d9400385 	stb	r5,14(sp)
        (val >> 8) & 0xff,
        val & 0xff,
    };

    /* Update cached value of trim DAC setting */
    vctcxo_trim_dac_value = val;
    4a1c:	d160000d 	sth	r5,-32768(gp)

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 3, data, 0, 0, 0) ;
    4a20:	d8000215 	stw	zero,8(sp)
    4a24:	d8000115 	stw	zero,4(sp)
    4a28:	d8000015 	stw	zero,0(sp)
    4a2c:	d9c00304 	addi	r7,sp,12
    4a30:	018000c4 	movi	r6,3
    4a34:	000b883a 	mov	r5,zero
    4a38:	01241814 	movui	r4,36960
    IOWR_8DIRECT(I2C, OC_I2C_CMD_STATUS, OC_I2C_WR | OC_I2C_STO);
    si5338_complete_transfer(0);
}

void vctcxo_trim_dac_write(uint8_t cmd, uint16_t val)
{
    4a3c:	dfc00415 	stw	ra,16(sp)
    uint8_t data[3] = {
    4a40:	d8800345 	stb	r2,13(sp)
    };

    /* Update cached value of trim DAC setting */
    vctcxo_trim_dac_value = val;

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 3, data, 0, 0, 0) ;
    4a44:	0006f1c0 	call	6f1c <alt_avalon_spi_command>
}
    4a48:	dfc00417 	ldw	ra,16(sp)
    4a4c:	dec00504 	addi	sp,sp,20
    4a50:	f800283a 	ret

00004a54 <vctcxo_trim_dac_read>:

void vctcxo_trim_dac_read(uint8_t cmd, uint16_t *val)
{
    4a54:	defff804 	addi	sp,sp,-32
    4a58:	dc000515 	stw	r16,20(sp)
    uint8_t data[2];

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 1, &cmd, 0, 0, ALT_AVALON_SPI_COMMAND_MERGE);
    4a5c:	01800044 	movi	r6,1
    4a60:	04241814 	movui	r16,36960

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 3, data, 0, 0, 0) ;
}

void vctcxo_trim_dac_read(uint8_t cmd, uint16_t *val)
{
    4a64:	dc400615 	stw	r17,24(sp)
    4a68:	d9000405 	stb	r4,16(sp)
    4a6c:	2823883a 	mov	r17,r5
    uint8_t data[2];

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 1, &cmd, 0, 0, ALT_AVALON_SPI_COMMAND_MERGE);
    4a70:	d9800215 	stw	r6,8(sp)
    4a74:	d9c00404 	addi	r7,sp,16
    4a78:	8009883a 	mov	r4,r16
    4a7c:	d8000115 	stw	zero,4(sp)
    4a80:	d8000015 	stw	zero,0(sp)
    4a84:	000b883a 	mov	r5,zero

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 3, data, 0, 0, 0) ;
}

void vctcxo_trim_dac_read(uint8_t cmd, uint16_t *val)
{
    4a88:	dfc00715 	stw	ra,28(sp)
    uint8_t data[2];

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 1, &cmd, 0, 0, ALT_AVALON_SPI_COMMAND_MERGE);
    4a8c:	0006f1c0 	call	6f1c <alt_avalon_spi_command>
    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 0, 0, 0, 2, &data, 0);
    4a90:	d8800304 	addi	r2,sp,12
    4a94:	d8800115 	stw	r2,4(sp)
    4a98:	00800084 	movi	r2,2
    4a9c:	d8000215 	stw	zero,8(sp)
    4aa0:	d8800015 	stw	r2,0(sp)
    4aa4:	000f883a 	mov	r7,zero
    4aa8:	000d883a 	mov	r6,zero
    4aac:	000b883a 	mov	r5,zero
    4ab0:	8009883a 	mov	r4,r16
    4ab4:	0006f1c0 	call	6f1c <alt_avalon_spi_command>

    *val = (data[0] << 8) | data[1];
    4ab8:	d8800303 	ldbu	r2,12(sp)
    4abc:	1006923a 	slli	r3,r2,8
    4ac0:	d8800343 	ldbu	r2,13(sp)
    4ac4:	1884b03a 	or	r2,r3,r2
    4ac8:	8880000d 	sth	r2,0(r17)
}
    4acc:	dfc00717 	ldw	ra,28(sp)
    4ad0:	dc400617 	ldw	r17,24(sp)
    4ad4:	dc000517 	ldw	r16,20(sp)
    4ad8:	dec00804 	addi	sp,sp,32
    4adc:	f800283a 	ret

00004ae0 <adf4351_write>:

void adf4351_write(uint32_t val)
{
    4ae0:	defffb04 	addi	sp,sp,-20
        uint32_t val;
        uint8_t byte[4];
    } sval;

    uint8_t t;
    sval.val = val;
    4ae4:	d9000315 	stw	r4,12(sp)

    t = sval.byte[0];
    sval.byte[0] = sval.byte[3];
    4ae8:	d88003c3 	ldbu	r2,15(sp)
    sval.byte[3] = t;

    t = sval.byte[1];
    sval.byte[1] = sval.byte[2];
    4aec:	d8c00383 	ldbu	r3,14(sp)
    uint8_t t;
    sval.val = val;

    t = sval.byte[0];
    sval.byte[0] = sval.byte[3];
    sval.byte[3] = t;
    4af0:	d90003c5 	stb	r4,15(sp)

    uint8_t t;
    sval.val = val;

    t = sval.byte[0];
    sval.byte[0] = sval.byte[3];
    4af4:	d8800305 	stb	r2,12(sp)
    sval.byte[3] = t;

    t = sval.byte[1];
    4af8:	d8800343 	ldbu	r2,13(sp)
    sval.byte[1] = sval.byte[2];
    sval.byte[2] = t;

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 1, 4, (uint8_t*)&sval.val, 0, 0, 0);
    4afc:	d8000215 	stw	zero,8(sp)
    4b00:	d8000115 	stw	zero,4(sp)
    4b04:	d8000015 	stw	zero,0(sp)
    4b08:	d9c00304 	addi	r7,sp,12
    4b0c:	01800104 	movi	r6,4
    4b10:	01400044 	movi	r5,1
    4b14:	01241814 	movui	r4,36960

    *val = (data[0] << 8) | data[1];
}

void adf4351_write(uint32_t val)
{
    4b18:	dfc00415 	stw	ra,16(sp)
    t = sval.byte[0];
    sval.byte[0] = sval.byte[3];
    sval.byte[3] = t;

    t = sval.byte[1];
    sval.byte[1] = sval.byte[2];
    4b1c:	d8c00345 	stb	r3,13(sp)
    sval.byte[2] = t;
    4b20:	d8800385 	stb	r2,14(sp)

    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 1, 4, (uint8_t*)&sval.val, 0, 0, 0);
    4b24:	0006f1c0 	call	6f1c <alt_avalon_spi_command>
}
    4b28:	dfc00417 	ldw	ra,16(sp)
    4b2c:	dec00504 	addi	sp,sp,20
    4b30:	f800283a 	ret

00004b34 <iqbal_get_gain>:

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
    4b34:	20000226 	beq	r4,zero,4b40 <iqbal_get_gain+0xc>
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    } else {
        return IQ_CORR_TX_PHASE_GAIN_BASE;
    4b38:	00a43014 	movui	r2,37056
    4b3c:	00000106 	br	4b44 <iqbal_get_gain+0x10>
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    4b40:	00a43414 	movui	r2,37072
uint16_t iqbal_get_gain(bladerf_module m)
{
    const uint32_t base = module_to_iqcorr_base(m);
    const uint32_t regval = IORD_ALTERA_AVALON_PIO_DATA(base);
    return (uint16_t) regval;
}
    4b44:	10800037 	ldwio	r2,0(r2)
    4b48:	f800283a 	ret

00004b4c <iqbal_set_gain>:
    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 1, 4, (uint8_t*)&sval.val, 0, 0, 0);
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
    4b4c:	20000226 	beq	r4,zero,4b58 <iqbal_set_gain+0xc>
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    } else {
        return IQ_CORR_TX_PHASE_GAIN_BASE;
    4b50:	00e43014 	movui	r3,37056
    4b54:	00000106 	br	4b5c <iqbal_set_gain+0x10>
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    4b58:	00e43414 	movui	r3,37072
}

void iqbal_set_gain(bladerf_module m, uint16_t value)
{
    const uint32_t base = module_to_iqcorr_base(m);
    uint32_t regval = IORD_ALTERA_AVALON_PIO_DATA(base);
    4b5c:	18800037 	ldwio	r2,0(r3)

    regval &= 0xffff0000;
    4b60:	10bfffec 	andhi	r2,r2,65535
    regval |= value;

    IOWR_ALTERA_AVALON_PIO_DATA(base, regval);
    4b64:	297fffcc 	andi	r5,r5,65535
    4b68:	288ab03a 	or	r5,r5,r2
    4b6c:	19400035 	stwio	r5,0(r3)
    4b70:	f800283a 	ret

00004b74 <iqbal_get_phase>:

uint16_t iqbal_get_phase(bladerf_module m)
{
    uint32_t regval;

    if (m == BLADERF_MODULE_RX) {
    4b74:	2000021e 	bne	r4,zero,4b80 <iqbal_get_phase+0xc>
        regval = IORD_ALTERA_AVALON_PIO_DATA(IQ_CORR_RX_PHASE_GAIN_BASE);
    4b78:	00a43414 	movui	r2,37072
    4b7c:	00000106 	br	4b84 <iqbal_get_phase+0x10>
    } else {
        regval = IORD_ALTERA_AVALON_PIO_DATA(IQ_CORR_TX_PHASE_GAIN_BASE);
    4b80:	00a43014 	movui	r2,37056
    4b84:	10800037 	ldwio	r2,0(r2)
    }

    return (uint16_t) (regval >> 16);
}
    4b88:	1004d43a 	srli	r2,r2,16
    4b8c:	f800283a 	ret

00004b90 <iqbal_set_phase>:
    alt_avalon_spi_command(PERIPHERAL_SPI_BASE, 1, 4, (uint8_t*)&sval.val, 0, 0, 0);
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
    4b90:	20000226 	beq	r4,zero,4b9c <iqbal_set_phase+0xc>
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    } else {
        return IQ_CORR_TX_PHASE_GAIN_BASE;
    4b94:	00e43014 	movui	r3,37056
    4b98:	00000106 	br	4ba0 <iqbal_set_phase+0x10>
}

static inline uint32_t module_to_iqcorr_base(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        return IQ_CORR_RX_PHASE_GAIN_BASE;
    4b9c:	00e43414 	movui	r3,37072
}

void iqbal_set_phase(bladerf_module m, uint16_t value)
{
    const uint32_t base = module_to_iqcorr_base(m);
    uint32_t regval = IORD_ALTERA_AVALON_PIO_DATA(base);
    4ba0:	18800037 	ldwio	r2,0(r3)

    regval &= 0x0000ffff;
    regval |= ((uint32_t) value) << 16;

    IOWR_ALTERA_AVALON_PIO_DATA(base, regval);
    4ba4:	280a943a 	slli	r5,r5,16
void iqbal_set_phase(bladerf_module m, uint16_t value)
{
    const uint32_t base = module_to_iqcorr_base(m);
    uint32_t regval = IORD_ALTERA_AVALON_PIO_DATA(base);

    regval &= 0x0000ffff;
    4ba8:	10bfffcc 	andi	r2,r2,65535
    regval |= ((uint32_t) value) << 16;

    IOWR_ALTERA_AVALON_PIO_DATA(base, regval);
    4bac:	288ab03a 	or	r5,r5,r2
    4bb0:	19400035 	stwio	r5,0(r3)
    4bb4:	f800283a 	ret

00004bb8 <tx_trigger_ctl_write>:
}

void tx_trigger_ctl_write(uint8_t data)
{
  IOWR_ALTERA_AVALON_PIO_DATA(TX_TRIGGER_CTL_BASE, data);
    4bb8:	21003fcc 	andi	r4,r4,255
    4bbc:	00a50814 	movui	r2,37920
    4bc0:	11000035 	stwio	r4,0(r2)
    4bc4:	f800283a 	ret

00004bc8 <tx_trigger_ctl_read>:
}

uint8_t tx_trigger_ctl_read(void)
{
  return IORD_ALTERA_AVALON_PIO_DATA(TX_TRIGGER_CTL_BASE);
}
    4bc8:	00a50814 	movui	r2,37920
    4bcc:	10800037 	ldwio	r2,0(r2)
    4bd0:	f800283a 	ret

00004bd4 <rx_trigger_ctl_write>:

void rx_trigger_ctl_write(uint8_t data)
{
  IOWR_ALTERA_AVALON_PIO_DATA(RX_TRIGGER_CTL_BASE, data);
    4bd4:	21003fcc 	andi	r4,r4,255
    4bd8:	00a50014 	movui	r2,37888
    4bdc:	11000035 	stwio	r4,0(r2)
    4be0:	f800283a 	ret

00004be4 <rx_trigger_ctl_read>:
}

uint8_t rx_trigger_ctl_read(void)
{
  return IORD_ALTERA_AVALON_PIO_DATA(RX_TRIGGER_CTL_BASE);
}
    4be4:	00a50014 	movui	r2,37888
    4be8:	10800037 	ldwio	r2,0(r2)
    4bec:	f800283a 	ret

00004bf0 <agc_dc_corr_write>:

void agc_dc_corr_write(uint16_t addr, uint16_t value)
{
    if (addr == NIOS_PKT_8x16_ADDR_AGC_DC_Q_MAX)
    4bf0:	213fffcc 	andi	r4,r4,65535
    4bf4:	2000031e 	bne	r4,zero,4c04 <agc_dc_corr_write+0x14>
        IOWR_ALTERA_AVALON_PIO_DATA(AGC_DC_Q_MAX_BASE, value);
    4bf8:	297fffcc 	andi	r5,r5,65535
    4bfc:	00a58414 	movui	r2,38416
    4c00:	00001806 	br	4c64 <agc_dc_corr_write+0x74>
    else if (addr == NIOS_PKT_8x16_ADDR_AGC_DC_I_MAX)
    4c04:	00800044 	movi	r2,1
    4c08:	2080031e 	bne	r4,r2,4c18 <agc_dc_corr_write+0x28>
        IOWR_ALTERA_AVALON_PIO_DATA(AGC_DC_I_MAX_BASE, value);
    4c0c:	297fffcc 	andi	r5,r5,65535
    4c10:	00a58014 	movui	r2,38400
    4c14:	00001306 	br	4c64 <agc_dc_corr_write+0x74>
    else if (addr == NIOS_PKT_8x16_ADDR_AGC_DC_Q_MID)
    4c18:	00800084 	movi	r2,2
    4c1c:	2080031e 	bne	r4,r2,4c2c <agc_dc_corr_write+0x3c>
        IOWR_ALTERA_AVALON_PIO_DATA(AGC_DC_Q_MID_BASE, value);
    4c20:	297fffcc 	andi	r5,r5,65535
    4c24:	00a58c14 	movui	r2,38448
    4c28:	00000e06 	br	4c64 <agc_dc_corr_write+0x74>
    else if (addr == NIOS_PKT_8x16_ADDR_AGC_DC_I_MID)
    4c2c:	008000c4 	movi	r2,3
    4c30:	2080031e 	bne	r4,r2,4c40 <agc_dc_corr_write+0x50>
        IOWR_ALTERA_AVALON_PIO_DATA(AGC_DC_I_MID_BASE, value);
    4c34:	297fffcc 	andi	r5,r5,65535
    4c38:	00a58814 	movui	r2,38432
    4c3c:	00000906 	br	4c64 <agc_dc_corr_write+0x74>
    else if (addr == NIOS_PKT_8x16_ADDR_AGC_DC_Q_MIN)
    4c40:	00800104 	movi	r2,4
    4c44:	2080031e 	bne	r4,r2,4c54 <agc_dc_corr_write+0x64>
        IOWR_ALTERA_AVALON_PIO_DATA(AGC_DC_Q_MIN_BASE, value);
    4c48:	297fffcc 	andi	r5,r5,65535
    4c4c:	00a59414 	movui	r2,38480
    4c50:	00000406 	br	4c64 <agc_dc_corr_write+0x74>
    else if (addr == NIOS_PKT_8x16_ADDR_AGC_DC_I_MIN)
    4c54:	00800144 	movi	r2,5
    4c58:	2080031e 	bne	r4,r2,4c68 <agc_dc_corr_write+0x78>
        IOWR_ALTERA_AVALON_PIO_DATA(AGC_DC_I_MIN_BASE, value);
    4c5c:	297fffcc 	andi	r5,r5,65535
    4c60:	00a59014 	movui	r2,38464
    4c64:	11400035 	stwio	r5,0(r2)
    4c68:	f800283a 	ret

00004c6c <time_tamer_read>:
}

uint64_t time_tamer_read(bladerf_module m)
{
    uint32_t base = (m == BLADERF_MODULE_RX) ? RX_TAMER_BASE : TX_TAMER_BASE ;
    4c6c:	20000226 	beq	r4,zero,4c78 <time_tamer_read+0xc>
    4c70:	01245014 	movui	r4,37184
    4c74:	00000106 	br	4c7c <time_tamer_read+0x10>
    4c78:	01245814 	movui	r4,37216
    uint8_t offset = 0;
    uint64_t value = 0;

    value  = IORD_8DIRECT(base, offset++);
    4c7c:	20c00023 	ldbuio	r3,0(r4)
    4c80:	19403fcc 	andi	r5,r3,255
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 8;
    4c84:	20c00063 	ldbuio	r3,1(r4)
    4c88:	18c03fcc 	andi	r3,r3,255
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 16;
    4c8c:	208000a3 	ldbuio	r2,2(r4)
    4c90:	10803fcc 	andi	r2,r2,255
    4c94:	1806923a 	slli	r3,r3,8
    4c98:	1004943a 	slli	r2,r2,16
    4c9c:	1884b03a 	or	r2,r3,r2
    4ca0:	1146b03a 	or	r3,r2,r5
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 24;
    4ca4:	208000e3 	ldbuio	r2,3(r4)
    4ca8:	1004963a 	slli	r2,r2,24
    4cac:	10c4b03a 	or	r2,r2,r3
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 32;
    4cb0:	21800123 	ldbuio	r6,4(r4)
    4cb4:	31c03fcc 	andi	r7,r6,255
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 40;
    4cb8:	21400163 	ldbuio	r5,5(r4)
    4cbc:	29403fcc 	andi	r5,r5,255
    4cc0:	280a923a 	slli	r5,r5,8
    4cc4:	29ccb03a 	or	r6,r5,r7
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 48;
    4cc8:	214001a3 	ldbuio	r5,6(r4)
    4ccc:	29403fcc 	andi	r5,r5,255
    4cd0:	280a943a 	slli	r5,r5,16
    4cd4:	298ab03a 	or	r5,r5,r6
    value |= ((uint64_t) IORD_8DIRECT(base, offset++)) << 56;
    4cd8:	20c001e3 	ldbuio	r3,7(r4)

    return value;
    4cdc:	1806963a 	slli	r3,r3,24
}
    4ce0:	1946b03a 	or	r3,r3,r5
    4ce4:	f800283a 	ret

00004ce8 <pkt_32x32>:

    return true;
}

void pkt_32x32(struct pkt_buf *b)
{
    4ce8:	20800143 	ldbu	r2,5(r4)
    4cec:	21400183 	ldbu	r5,6(r4)
    4cf0:	21800103 	ldbu	r6,4(r4)
    4cf4:	1004923a 	slli	r2,r2,8
    4cf8:	280a943a 	slli	r5,r5,16
    4cfc:	21c00203 	ldbu	r7,8(r4)
    4d00:	1186b03a 	or	r3,r2,r6
    4d04:	28c4b03a 	or	r2,r5,r3
    4d08:	214001c3 	ldbu	r5,7(r4)
    4d0c:	20c00243 	ldbu	r3,9(r4)
    4d10:	22000083 	ldbu	r8,2(r4)
    4d14:	280a963a 	slli	r5,r5,24
    4d18:	1806923a 	slli	r3,r3,8
static inline void nios_pkt_32x32_unpack(const uint8_t *buf, uint8_t *target,
                                        bool *write, uint32_t *addr,
                                        uint32_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_32x32_IDX_TARGET_ID];
    4d1c:	22800043 	ldbu	r10,1(r4)
    4d20:	288ab03a 	or	r5,r5,r2
    4d24:	20800283 	ldbu	r2,10(r4)
    4d28:	19ccb03a 	or	r6,r3,r7
    4d2c:	1004943a 	slli	r2,r2,16
    4d30:	1186b03a 	or	r3,r2,r6
    4d34:	208002c3 	ldbu	r2,11(r4)
    bool is_write;
    bool success;

    nios_pkt_32x32_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    4d38:	4180004c 	andi	r6,r8,1
    4d3c:	1004963a 	slli	r2,r2,24
    4d40:	10c4b03a 	or	r2,r2,r3
    4d44:	50c03fcc 	andi	r3,r10,255
    4d48:	30001a26 	beq	r6,zero,4db4 <pkt_32x32+0xcc>
#include "devices.h"
#include "debug.h"

static inline bool perform_write(uint8_t id, uint32_t addr, uint32_t data)
{
    switch (id) {
    4d4c:	18000326 	beq	r3,zero,4d5c <pkt_32x32+0x74>
    4d50:	01c00044 	movi	r7,1
    4d54:	19c00c26 	beq	r3,r7,4d88 <pkt_32x32+0xa0>
    4d58:	00002206 	br	4de4 <pkt_32x32+0xfc>
        /* The address is used as a bitmask for the expansion IO registers.
         * We'll skip RMWs if all bits are being written */
        case NIOS_PKT_32x32_TARGET_EXP:
            if (addr != 0xffffffff) {
    4d5c:	00ffffc4 	movi	r3,-1
    4d60:	01e42c14 	movui	r7,37040
    4d64:	28c00626 	beq	r5,r3,4d80 <pkt_32x32+0x98>

}

static inline uint32_t expansion_port_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE);
    4d68:	38c00037 	ldwio	r3,0(r7)
}

INLINE void expansion_port_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE, value);
    4d6c:	10d0f03a 	xor	r8,r2,r3
    4d70:	4150703a 	and	r8,r8,r5
    4d74:	40c6f03a 	xor	r3,r8,r3
    4d78:	38c00035 	stwio	r3,0(r7)
    4d7c:	00001706 	br	4ddc <pkt_32x32+0xf4>
    4d80:	38800035 	stwio	r2,0(r7)
    4d84:	00001506 	br	4ddc <pkt_32x32+0xf4>
                expansion_port_write(data);
            }
            break;

        case NIOS_PKT_32x32_TARGET_EXP_DIR:
            if (addr != 0xffffffff) {
    4d88:	01ffffc4 	movi	r7,-1
    4d8c:	02242814 	movui	r8,37024
    4d90:	29c00626 	beq	r5,r7,4dac <pkt_32x32+0xc4>
}

INLINE uint32_t expansion_port_get_direction()
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE);
    4d94:	41c00037 	ldwio	r7,0(r8)
}

INLINE void expansion_port_set_direction(uint32_t dir)
{
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE, dir);
    4d98:	11d2f03a 	xor	r9,r2,r7
    4d9c:	4952703a 	and	r9,r9,r5
    4da0:	49cef03a 	xor	r7,r9,r7
    4da4:	41c00035 	stwio	r7,0(r8)
    4da8:	00000f06 	br	4de8 <pkt_32x32+0x100>
    4dac:	40800035 	stwio	r2,0(r8)
    4db0:	00000d06 	br	4de8 <pkt_32x32+0x100>
    return true;
}

static inline bool perform_read(uint8_t id, uint32_t addr, uint32_t *data)
{
    switch (id) {
    4db4:	18000626 	beq	r3,zero,4dd0 <pkt_32x32+0xe8>
    4db8:	01c00044 	movi	r7,1
    4dbc:	19c0091e 	bne	r3,r7,4de4 <pkt_32x32+0xfc>
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE, value);
}

INLINE uint32_t expansion_port_get_direction()
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE);
    4dc0:	00a42814 	movui	r2,37024
    4dc4:	10800037 	ldwio	r2,0(r2)
        case NIOS_PKT_32x32_TARGET_EXP:
            *data = expansion_port_read() & addr;
            break;

        case NIOS_PKT_32x32_TARGET_EXP_DIR:
            *data = expansion_port_get_direction() & addr;
    4dc8:	1144703a 	and	r2,r2,r5
    4dcc:	00000606 	br	4de8 <pkt_32x32+0x100>

}

static inline uint32_t expansion_port_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE);
    4dd0:	00a42c14 	movui	r2,37040
    4dd4:	10800037 	ldwio	r2,0(r2)
static inline bool perform_read(uint8_t id, uint32_t addr, uint32_t *data)
{
    switch (id) {
        /* The address is used as a bitmask for the expansion IO registers */
        case NIOS_PKT_32x32_TARGET_EXP:
            *data = expansion_port_read() & addr;
    4dd8:	1144703a 	and	r2,r2,r5
        default:
            DBG("Invalid ID: 0x%02x\n", id);
            return false;
    }

    return true;
    4ddc:	00c00044 	movi	r3,1
    4de0:	00000106 	br	4de8 <pkt_32x32+0x100>

        */

        default:
            DBG("Invalid ID: 0x%02x\n", id);
            return false;
    4de4:	0007883a 	mov	r3,zero

/* Pack the request buffer */
static inline void nios_pkt_32x32_pack(uint8_t *buf, uint8_t target, bool write,
                                       uint32_t addr, uint32_t data)
{
    buf[NIOS_PKT_32x32_IDX_MAGIC]     = NIOS_PKT_32x32_MAGIC;
    4de8:	01c012c4 	movi	r7,75
    4dec:	21c00405 	stb	r7,16(r4)
    buf[NIOS_PKT_32x32_IDX_TARGET_ID] = target;
    4df0:	22800445 	stb	r10,17(r4)

    if (write) {
    4df4:	30000326 	beq	r6,zero,4e04 <pkt_32x32+0x11c>
        buf[NIOS_PKT_32x32_IDX_FLAGS] = NIOS_PKT_32x32_FLAG_WRITE;
    4df8:	01800044 	movi	r6,1
    4dfc:	21800485 	stb	r6,18(r4)
    4e00:	00000106 	br	4e08 <pkt_32x32+0x120>
    } else {
        buf[NIOS_PKT_32x32_IDX_FLAGS] = 0x00;
    4e04:	20000485 	stb	zero,18(r4)
    }

    buf[NIOS_PKT_32x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_32x32_IDX_ADDR + 0] = (addr >> 0);
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    4e08:	280cd23a 	srli	r6,r5,8
        buf[NIOS_PKT_32x32_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_32x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_32x32_IDX_ADDR + 0] = (addr >> 0);
    4e0c:	21400505 	stb	r5,20(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);

    buf[NIOS_PKT_32x32_IDX_DATA + 0] = (data >> 0);
    4e10:	20800605 	stb	r2,24(r4)
    }

    buf[NIOS_PKT_32x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_32x32_IDX_ADDR + 0] = (addr >> 0);
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    4e14:	21800545 	stb	r6,21(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    4e18:	280cd43a 	srli	r6,r5,16
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);
    4e1c:	280ad63a 	srli	r5,r5,24
        buf[NIOS_PKT_32x32_IDX_FLAGS] = NIOS_PKT_32x32_FLAG_WRITE;
    } else {
        buf[NIOS_PKT_32x32_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_32x32_IDX_RESV1] = 0x00;
    4e20:	200004c5 	stb	zero,19(r4)

    buf[NIOS_PKT_32x32_IDX_ADDR + 0] = (addr >> 0);
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    4e24:	21800585 	stb	r6,22(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);
    4e28:	214005c5 	stb	r5,23(r4)

    buf[NIOS_PKT_32x32_IDX_DATA + 0] = (data >> 0);
    buf[NIOS_PKT_32x32_IDX_DATA + 1] = (data >> 8);
    4e2c:	100ad23a 	srli	r5,r2,8
    buf[NIOS_PKT_32x32_IDX_DATA + 2] = (data >> 16);
    buf[NIOS_PKT_32x32_IDX_DATA + 3] = (data >> 24);

    buf[NIOS_PKT_32x32_IDX_RESV2 + 0] = 0x00;
    4e30:	20000705 	stb	zero,28(r4)
    buf[NIOS_PKT_32x32_IDX_RESV2 + 1] = 0x00;
    4e34:	20000745 	stb	zero,29(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 1] = (addr >> 8);
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);

    buf[NIOS_PKT_32x32_IDX_DATA + 0] = (data >> 0);
    buf[NIOS_PKT_32x32_IDX_DATA + 1] = (data >> 8);
    4e38:	21400645 	stb	r5,25(r4)
    buf[NIOS_PKT_32x32_IDX_DATA + 2] = (data >> 16);
    4e3c:	100ad43a 	srli	r5,r2,16
    buf[NIOS_PKT_32x32_IDX_DATA + 3] = (data >> 24);
    4e40:	1004d63a 	srli	r2,r2,24

    buf[NIOS_PKT_32x32_IDX_RESV2 + 0] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 1] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 2] = 0x00;
    4e44:	20000785 	stb	zero,30(r4)
    buf[NIOS_PKT_32x32_IDX_ADDR + 2] = (addr >> 16);
    buf[NIOS_PKT_32x32_IDX_ADDR + 3] = (addr >> 24);

    buf[NIOS_PKT_32x32_IDX_DATA + 0] = (data >> 0);
    buf[NIOS_PKT_32x32_IDX_DATA + 1] = (data >> 8);
    buf[NIOS_PKT_32x32_IDX_DATA + 2] = (data >> 16);
    4e48:	21400685 	stb	r5,26(r4)
    buf[NIOS_PKT_32x32_IDX_DATA + 3] = (data >> 24);
    4e4c:	208006c5 	stb	r2,27(r4)

    buf[NIOS_PKT_32x32_IDX_RESV2 + 0] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 1] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 2] = 0x00;
    buf[NIOS_PKT_32x32_IDX_RESV2 + 3] = 0x00;
    4e50:	200007c5 	stb	zero,31(r4)
                                            bool write, uint32_t addr,
                                            uint32_t data, bool success)
{
    nios_pkt_32x32_pack(buf, target, write, addr, data);

    if (success) {
    4e54:	18c03fcc 	andi	r3,r3,255
    4e58:	18000326 	beq	r3,zero,4e68 <pkt_32x32+0x180>
        buf[NIOS_PKT_32x32_IDX_FLAGS] |= NIOS_PKT_32x32_FLAG_SUCCESS;
    4e5c:	20800483 	ldbu	r2,18(r4)
    4e60:	10800094 	ori	r2,r2,2
    4e64:	20800485 	stb	r2,18(r4)
    4e68:	f800283a 	ret

00004e6c <pkt_8x16>:

    return true;
}

void pkt_8x16(struct pkt_buf *b)
{
    4e6c:	defff804 	addi	sp,sp,-32
    4e70:	dc400215 	stw	r17,8(sp)
    4e74:	dc000115 	stw	r16,4(sp)
    4e78:	dfc00715 	stw	ra,28(sp)
    4e7c:	dd400615 	stw	r21,24(sp)
    4e80:	dd000515 	stw	r20,20(sp)
    4e84:	dcc00415 	stw	r19,16(sp)
    4e88:	dc800315 	stw	r18,12(sp)
    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x16_IDX_ADDR];
    }

    if (data != NULL) {
        *data   = (buf[NIOS_PKT_8x16_IDX_DATA + 0] << 0) |
    4e8c:	21400183 	ldbu	r5,6(r4)
    4e90:	20800143 	ldbu	r2,5(r4)
    4e94:	25400083 	ldbu	r21,2(r4)
    4e98:	280a923a 	slli	r5,r5,8
static inline void nios_pkt_8x16_unpack(const uint8_t *buf, uint8_t *target,
                                       bool *write, uint8_t *addr,
                                       uint16_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_8x16_IDX_TARGET_ID];
    4e9c:	25000043 	ldbu	r20,1(r4)
    bool is_write;
    bool success;

    nios_pkt_8x16_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    4ea0:	ad40004c 	andi	r21,r21,1
    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x16_IDX_ADDR];
    }

    if (data != NULL) {
        *data   = (buf[NIOS_PKT_8x16_IDX_DATA + 0] << 0) |
    4ea4:	288ab03a 	or	r5,r5,r2
    4ea8:	d940000d 	sth	r5,0(sp)

    return true;
}

void pkt_8x16(struct pkt_buf *b)
{
    4eac:	2023883a 	mov	r17,r4
    if (write != NULL) {
        *write  = (buf[NIOS_PKT_8x16_IDX_FLAGS] & NIOS_PKT_8x16_FLAG_WRITE) != 0;
    }

    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x16_IDX_ADDR];
    4eb0:	24800103 	ldbu	r18,4(r4)
    4eb4:	a4003fcc 	andi	r16,r20,255
    bool is_write;
    bool success;

    nios_pkt_8x16_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    4eb8:	a8002326 	beq	r21,zero,4f48 <pkt_8x16+0xdc>
}


static inline bool perform_write(uint8_t id, uint8_t addr, uint16_t data)
{
    switch (id) {
    4ebc:	04c00044 	movi	r19,1
    4ec0:	84c00b26 	beq	r16,r19,4ef0 <pkt_8x16+0x84>
    4ec4:	80000626 	beq	r16,zero,4ee0 <pkt_8x16+0x74>
    4ec8:	00800084 	movi	r2,2
    4ecc:	80803b1e 	bne	r16,r2,4fbc <pkt_8x16+0x150>
        case NIOS_PKT_8x16_TARGET_IQ_CORR:
            iq_corr_write(addr, data);
            break;

        case NIOS_PKT_8x16_TARGET_AGC_CORR:
            agc_dc_corr_write(addr, data);
    4ed0:	297fffcc 	andi	r5,r5,65535
    4ed4:	91003fcc 	andi	r4,r18,255
    4ed8:	0004bf00 	call	4bf0 <agc_dc_corr_write>
    4edc:	00002106 	br	4f64 <pkt_8x16+0xf8>

static inline bool perform_write(uint8_t id, uint8_t addr, uint16_t data)
{
    switch (id) {
        case NIOS_PKT_8x16_TARGET_VCTCXO_DAC:
            vctcxo_trim_dac_write(addr, data);
    4ee0:	297fffcc 	andi	r5,r5,65535
    4ee4:	91003fcc 	andi	r4,r18,255
    4ee8:	0004a0c0 	call	4a0c <vctcxo_trim_dac_write>
    4eec:	00001d06 	br	4f64 <pkt_8x16+0xf8>
    return true;
}

static inline bool iq_corr_write(uint8_t addr, uint16_t data)
{
    switch (addr) {
    4ef0:	94c03fcc 	andi	r19,r18,255
    4ef4:	9c000c26 	beq	r19,r16,4f28 <pkt_8x16+0xbc>
    4ef8:	98000826 	beq	r19,zero,4f1c <pkt_8x16+0xb0>
    4efc:	00800084 	movi	r2,2
    4f00:	98800d26 	beq	r19,r2,4f38 <pkt_8x16+0xcc>
    4f04:	008000c4 	movi	r2,3
    4f08:	98802d1e 	bne	r19,r2,4fc0 <pkt_8x16+0x154>
        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_TX, data);
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_PHASE:
            iqbal_set_phase(BLADERF_MODULE_TX, data);
    4f0c:	297fffcc 	andi	r5,r5,65535
    4f10:	8009883a 	mov	r4,r16
    4f14:	0004b900 	call	4b90 <iqbal_set_phase>
    4f18:	00002906 	br	4fc0 <pkt_8x16+0x154>

static inline bool iq_corr_write(uint8_t addr, uint16_t data)
{
    switch (addr) {
        case NIOS_PKT_8x16_ADDR_IQ_CORR_RX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_RX, data);
    4f1c:	297fffcc 	andi	r5,r5,65535
    4f20:	0009883a 	mov	r4,zero
    4f24:	00000606 	br	4f40 <pkt_8x16+0xd4>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_RX_PHASE:
            iqbal_set_phase(BLADERF_MODULE_RX, data);
    4f28:	297fffcc 	andi	r5,r5,65535
    4f2c:	0009883a 	mov	r4,zero
    4f30:	0004b900 	call	4b90 <iqbal_set_phase>
    4f34:	00000b06 	br	4f64 <pkt_8x16+0xf8>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_TX, data);
    4f38:	297fffcc 	andi	r5,r5,65535
    4f3c:	8009883a 	mov	r4,r16
    4f40:	0004b4c0 	call	4b4c <iqbal_set_gain>
    4f44:	00001e06 	br	4fc0 <pkt_8x16+0x154>

static inline bool perform_read(uint8_t id, uint8_t addr, uint16_t *data)
{
    bool success = true;

    switch (id) {
    4f48:	80000326 	beq	r16,zero,4f58 <pkt_8x16+0xec>
    4f4c:	00800044 	movi	r2,1
    4f50:	80800626 	beq	r16,r2,4f6c <pkt_8x16+0x100>
    4f54:	00001906 	br	4fbc <pkt_8x16+0x150>
        case NIOS_PKT_8x16_TARGET_VCTCXO_DAC:
            vctcxo_trim_dac_read(addr, data);
    4f58:	d80b883a 	mov	r5,sp
    4f5c:	91003fcc 	andi	r4,r18,255
    4f60:	0004a540 	call	4a54 <vctcxo_trim_dac_read>
        default:
            DBG("%s: Invalid ID: 0x%02x\n", __FUNCTION__, id);
            return false;
    }

    return success;
    4f64:	04000044 	movi	r16,1
    4f68:	00001506 	br	4fc0 <pkt_8x16+0x154>
#include "devices.h"
#include "debug.h"

static inline bool iq_corr_read(uint8_t addr, uint16_t *data)
{
    switch (addr) {
    4f6c:	94c03fcc 	andi	r19,r18,255
    4f70:	9c000a26 	beq	r19,r16,4f9c <pkt_8x16+0x130>
    4f74:	98000726 	beq	r19,zero,4f94 <pkt_8x16+0x128>
    4f78:	00800084 	movi	r2,2
    4f7c:	98800b26 	beq	r19,r2,4fac <pkt_8x16+0x140>
    4f80:	008000c4 	movi	r2,3
    4f84:	98800e1e 	bne	r19,r2,4fc0 <pkt_8x16+0x154>
        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_GAIN:
            *data = iqbal_get_gain(BLADERF_MODULE_TX);
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_PHASE:
            *data = iqbal_get_phase(BLADERF_MODULE_TX);
    4f88:	8009883a 	mov	r4,r16
    4f8c:	0004b740 	call	4b74 <iqbal_get_phase>
    4f90:	00000806 	br	4fb4 <pkt_8x16+0x148>

static inline bool iq_corr_read(uint8_t addr, uint16_t *data)
{
    switch (addr) {
        case NIOS_PKT_8x16_ADDR_IQ_CORR_RX_GAIN:
            *data = iqbal_get_gain(BLADERF_MODULE_RX);
    4f94:	0009883a 	mov	r4,zero
    4f98:	00000506 	br	4fb0 <pkt_8x16+0x144>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_RX_PHASE:
            *data = iqbal_get_phase(BLADERF_MODULE_RX);
    4f9c:	0009883a 	mov	r4,zero
    4fa0:	0004b740 	call	4b74 <iqbal_get_phase>
    4fa4:	d880000d 	sth	r2,0(sp)
    4fa8:	003fee06 	br	4f64 <_gp+0xffff5e4c>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_GAIN:
            *data = iqbal_get_gain(BLADERF_MODULE_TX);
    4fac:	8009883a 	mov	r4,r16
    4fb0:	0004b340 	call	4b34 <iqbal_get_gain>
            break;

        case NIOS_PKT_8x16_ADDR_IQ_CORR_TX_PHASE:
            *data = iqbal_get_phase(BLADERF_MODULE_TX);
    4fb4:	d880000d 	sth	r2,0(sp)
    4fb8:	00000106 	br	4fc0 <pkt_8x16+0x154>

        */

        default:
            DBG("%s: Invalid ID: 0x%02x\n", __FUNCTION__, id);
            return false;
    4fbc:	0021883a 	mov	r16,zero

/* Pack the request buffer */
static inline void nios_pkt_8x16_pack(uint8_t *buf, uint8_t target, bool write,
                                      uint8_t addr, uint16_t data)
{
    buf[NIOS_PKT_8x16_IDX_MAGIC]     = NIOS_PKT_8x16_MAGIC;
    4fc0:	00c01084 	movi	r3,66
    4fc4:	88c00405 	stb	r3,16(r17)
    buf[NIOS_PKT_8x16_IDX_TARGET_ID] = target;
    4fc8:	8d000445 	stb	r20,17(r17)
        success = perform_write(id, addr, data);
    } else {
        success = perform_read(id, addr, &data);
    }

    nios_pkt_8x16_resp_pack(b->resp, id, is_write, addr, data, success);
    4fcc:	d880000b 	ldhu	r2,0(sp)

    if (write) {
    4fd0:	a8000326 	beq	r21,zero,4fe0 <pkt_8x16+0x174>
        buf[NIOS_PKT_8x16_IDX_FLAGS] = NIOS_PKT_8x16_FLAG_WRITE;
    4fd4:	00c00044 	movi	r3,1
    4fd8:	88c00485 	stb	r3,18(r17)
    4fdc:	00000106 	br	4fe4 <pkt_8x16+0x178>
    } else {
        buf[NIOS_PKT_8x16_IDX_FLAGS] = 0x00;
    4fe0:	88000485 	stb	zero,18(r17)

    buf[NIOS_PKT_8x16_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x16_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x16_IDX_DATA]     = data & 0xff;
    4fe4:	88800545 	stb	r2,21(r17)
    buf[NIOS_PKT_8x16_IDX_DATA + 1] = (data >> 8);
    4fe8:	1004d23a 	srli	r2,r2,8
        buf[NIOS_PKT_8x16_IDX_FLAGS] = NIOS_PKT_8x16_FLAG_WRITE;
    } else {
        buf[NIOS_PKT_8x16_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_8x16_IDX_RESV1] = 0x00;
    4fec:	880004c5 	stb	zero,19(r17)

    buf[NIOS_PKT_8x16_IDX_ADDR] = addr;
    4ff0:	8c800505 	stb	r18,20(r17)

    buf[NIOS_PKT_8x16_IDX_DATA]     = data & 0xff;
    buf[NIOS_PKT_8x16_IDX_DATA + 1] = (data >> 8);
    4ff4:	88800585 	stb	r2,22(r17)

    buf[NIOS_PKT_8x16_IDX_RESV2 + 0] = 0x00;
    4ff8:	880005c5 	stb	zero,23(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 1] = 0x00;
    4ffc:	88000605 	stb	zero,24(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 2] = 0x00;
    5000:	88000645 	stb	zero,25(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 3] = 0x00;
    5004:	88000685 	stb	zero,26(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 4] = 0x00;
    5008:	880006c5 	stb	zero,27(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 5] = 0x00;
    500c:	88000705 	stb	zero,28(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 6] = 0x00;
    5010:	88000745 	stb	zero,29(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 7] = 0x00;
    5014:	88000785 	stb	zero,30(r17)
    buf[NIOS_PKT_8x16_IDX_RESV2 + 8] = 0x00;
    5018:	880007c5 	stb	zero,31(r17)
                                           bool write, uint8_t addr,
                                           uint16_t data, bool success)
{
    nios_pkt_8x16_pack(buf, target, write, addr, data);

    if (success) {
    501c:	84003fcc 	andi	r16,r16,255
    5020:	80000326 	beq	r16,zero,5030 <pkt_8x16+0x1c4>
        buf[NIOS_PKT_8x16_IDX_FLAGS] |= NIOS_PKT_8x16_FLAG_SUCCESS;
    5024:	88800483 	ldbu	r2,18(r17)
    5028:	10800094 	ori	r2,r2,2
    502c:	88800485 	stb	r2,18(r17)
}
    5030:	dfc00717 	ldw	ra,28(sp)
    5034:	dd400617 	ldw	r21,24(sp)
    5038:	dd000517 	ldw	r20,20(sp)
    503c:	dcc00417 	ldw	r19,16(sp)
    5040:	dc800317 	ldw	r18,12(sp)
    5044:	dc400217 	ldw	r17,8(sp)
    5048:	dc000117 	ldw	r16,4(sp)
    504c:	dec00804 	addi	sp,sp,32
    5050:	f800283a 	ret

00005054 <pkt_8x32>:

    return true;
}

void pkt_8x32(struct pkt_buf *b)
{
    5054:	defffa04 	addi	sp,sp,-24
    5058:	dc000015 	stw	r16,0(sp)
    505c:	dfc00515 	stw	ra,20(sp)
    5060:	dd000415 	stw	r20,16(sp)
    5064:	dcc00315 	stw	r19,12(sp)
    5068:	dc800215 	stw	r18,8(sp)
    506c:	dc400115 	stw	r17,4(sp)
    5070:	24800083 	ldbu	r18,2(r4)
static inline void nios_pkt_8x32_unpack(const uint8_t *buf, uint8_t *target,
                                        bool *write, uint8_t *addr,
                                        uint32_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_8x32_IDX_TARGET_ID];
    5074:	25000043 	ldbu	r20,1(r4)
    5078:	2021883a 	mov	r16,r4
    bool is_write;
    bool success;

    nios_pkt_8x32_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    507c:	9480004c 	andi	r18,r18,1
    if (write != NULL) {
        *write  = (buf[NIOS_PKT_8x32_IDX_FLAGS] & NIOS_PKT_8x32_FLAG_WRITE) != 0;
    }

    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x32_IDX_ADDR];
    5080:	24c00103 	ldbu	r19,4(r4)
    5084:	a1803fcc 	andi	r6,r20,255
    5088:	90002326 	beq	r18,zero,5118 <pkt_8x32+0xc4>
    508c:	20c00183 	ldbu	r3,6(r4)
    5090:	844001c3 	ldbu	r17,7(r16)
    5094:	21400143 	ldbu	r5,5(r4)
    5098:	1806923a 	slli	r3,r3,8
    509c:	8822943a 	slli	r17,r17,16
    50a0:	1948b03a 	or	r4,r3,r5
    50a4:	8906b03a 	or	r3,r17,r4
    50a8:	84400203 	ldbu	r17,8(r16)
    return true;
}

static inline bool perform_write(uint8_t id, uint8_t addr, uint32_t data)
{
    switch (id) {
    50ac:	01000084 	movi	r4,2
    50b0:	8822963a 	slli	r17,r17,24
    50b4:	88e2b03a 	or	r17,r17,r3
    50b8:	31000626 	beq	r6,r4,50d4 <pkt_8x32+0x80>
    50bc:	00802004 	movi	r2,128
    50c0:	30800726 	beq	r6,r2,50e0 <pkt_8x32+0x8c>
    50c4:	00800044 	movi	r2,1
    50c8:	3080291e 	bne	r6,r2,5170 <pkt_8x32+0x11c>
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
}

static inline void control_reg_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
    50cc:	00a41014 	movui	r2,36928
    50d0:	00000606 	br	50ec <pkt_8x32+0x98>
        case NIOS_PKT_8x32_TARGET_CONTROL:
            control_reg_write(data);
            break;

        case NIOS_PKT_8x32_TARGET_ADF4351:
            adf4351_write(data);
    50d4:	8809883a 	mov	r4,r17
    50d8:	0004ae00 	call	4ae0 <adf4351_write>
    50dc:	00000406 	br	50f0 <pkt_8x32+0x9c>
}


static inline void dd_control_reg_write(uint8_t addr, uint32_t value)
{
	if (addr == 0)
    50e0:	98c03fcc 	andi	r3,r19,255
    50e4:	1800041e 	bne	r3,zero,50f8 <pkt_8x32+0xa4>
	{
		IOWR_ALTERA_AVALON_PIO_DATA(DD_CTRL_0_BASE, value);
    50e8:	00a59814 	movui	r2,38496
    50ec:	14400035 	stwio	r17,0(r2)
        default:
            DBG("Invalid id: 0x%02x\n", id);
            return false;
    }

    return true;
    50f0:	00800044 	movi	r2,1
    50f4:	00002406 	br	5188 <pkt_8x32+0x134>
	}

	if (addr == 1)
    50f8:	00800044 	movi	r2,1
    50fc:	1880021e 	bne	r3,r2,5108 <pkt_8x32+0xb4>
	{
		IOWR_ALTERA_AVALON_PIO_DATA(DD_CTRL_1_BASE, value);
    5100:	00a59c14 	movui	r2,38512
    5104:	003ff906 	br	50ec <_gp+0xffff5fd4>
	}

	if (addr == 2)
    5108:	19001f1e 	bne	r3,r4,5188 <pkt_8x32+0x134>
	{
		IOWR_ALTERA_AVALON_PIO_DATA(DD_CTRL_2_BASE, value);
    510c:	00e5a014 	movui	r3,38528
    5110:	1c400035 	stwio	r17,0(r3)
    5114:	00001c06 	br	5188 <pkt_8x32+0x134>
#include "devices.h"
#include "debug.h"

static inline bool perform_read(uint8_t id, uint8_t addr, uint32_t *data)
{
    switch (id) {
    5118:	00800044 	movi	r2,1
    511c:	30800526 	beq	r6,r2,5134 <pkt_8x32+0xe0>
    5120:	30001526 	beq	r6,zero,5178 <pkt_8x32+0x124>
    5124:	00c02004 	movi	r3,128
    5128:	30c00426 	beq	r6,r3,513c <pkt_8x32+0xe8>
            *data = control_reg_read();
            break;

        case NIOS_PKT_8x32_TARGET_ADF4351:
            DBG("Illegal read from ADF4351.\n");
            *data = 0x00;
    512c:	0023883a 	mov	r17,zero
    5130:	00000f06 	br	5170 <pkt_8x32+0x11c>
	return 0;
}

static inline uint32_t control_reg_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
    5134:	00a41014 	movui	r2,36928
    5138:	00000606 	br	5154 <pkt_8x32+0x100>



static inline uint32_t dd_control_reg_read(uint8_t addr)
{
	if (addr == 0)
    513c:	98c03fcc 	andi	r3,r19,255
    5140:	1800021e 	bne	r3,zero,514c <pkt_8x32+0xf8>
	{
		return IORD_ALTERA_AVALON_PIO_DATA(DD_CTRL_0_BASE);
    5144:	00e59814 	movui	r3,38496
    5148:	00000706 	br	5168 <pkt_8x32+0x114>
	}

	if (addr == 1)
    514c:	1880031e 	bne	r3,r2,515c <pkt_8x32+0x108>
	{
		return IORD_ALTERA_AVALON_PIO_DATA(DD_CTRL_1_BASE);
    5150:	00a59c14 	movui	r2,38512
    5154:	14400037 	ldwio	r17,0(r2)
    5158:	003fe506 	br	50f0 <_gp+0xffff5fd8>
	}

	if (addr == 2)
    515c:	01000084 	movi	r4,2
    5160:	1900081e 	bne	r3,r4,5184 <pkt_8x32+0x130>
	{
		return IORD_ALTERA_AVALON_PIO_DATA(DD_CTRL_2_BASE);
    5164:	00e5a014 	movui	r3,38528
    5168:	1c400037 	ldwio	r17,0(r3)
    516c:	00000606 	br	5188 <pkt_8x32+0x134>
static inline bool perform_write(uint8_t id, uint8_t addr, uint32_t data)
{
    switch (id) {
        case NIOS_PKT_8x32_TARGET_VERSION:
            DBG("Invalid write to version register.\n");
            return false;
    5170:	0005883a 	mov	r2,zero
    5174:	00000406 	br	5188 <pkt_8x32+0x134>

static inline bool perform_read(uint8_t id, uint8_t addr, uint32_t *data)
{
    switch (id) {
        case NIOS_PKT_8x32_TARGET_VERSION:
            *data = fpga_version();
    5178:	04400074 	movhi	r17,1
    517c:	8c41c004 	addi	r17,r17,1792
    5180:	00000106 	br	5188 <pkt_8x32+0x134>
	}

	return 0;
    5184:	0023883a 	mov	r17,zero

/* Pack the request buffer */
static inline void nios_pkt_8x32_pack(uint8_t *buf, uint8_t target, bool write,
                                      uint8_t addr, uint32_t data)
{
    buf[NIOS_PKT_8x32_IDX_MAGIC]     = NIOS_PKT_8x32_MAGIC;
    5188:	00c010c4 	movi	r3,67
    518c:	80c00405 	stb	r3,16(r16)
    buf[NIOS_PKT_8x32_IDX_TARGET_ID] = target;
    5190:	85000445 	stb	r20,17(r16)

    if (write) {
    5194:	90000326 	beq	r18,zero,51a4 <pkt_8x32+0x150>
        buf[NIOS_PKT_8x32_IDX_FLAGS] = NIOS_PKT_8x32_FLAG_WRITE;
    5198:	00c00044 	movi	r3,1
    519c:	80c00485 	stb	r3,18(r16)
    51a0:	00000106 	br	51a8 <pkt_8x32+0x154>
    } else {
        buf[NIOS_PKT_8x32_IDX_FLAGS] = 0x00;
    51a4:	80000485 	stb	zero,18(r16)
    buf[NIOS_PKT_8x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x32_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x32_IDX_DATA + 0] = data & 0xff;
    buf[NIOS_PKT_8x32_IDX_DATA + 1] = (data >> 8);
    51a8:	8806d23a 	srli	r3,r17,8

    buf[NIOS_PKT_8x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x32_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x32_IDX_DATA + 0] = data & 0xff;
    51ac:	84400545 	stb	r17,21(r16)
        buf[NIOS_PKT_8x32_IDX_FLAGS] = NIOS_PKT_8x32_FLAG_WRITE;
    } else {
        buf[NIOS_PKT_8x32_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_8x32_IDX_RESV1] = 0x00;
    51b0:	800004c5 	stb	zero,19(r16)

    buf[NIOS_PKT_8x32_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x32_IDX_DATA + 0] = data & 0xff;
    buf[NIOS_PKT_8x32_IDX_DATA + 1] = (data >> 8);
    51b4:	80c00585 	stb	r3,22(r16)
    buf[NIOS_PKT_8x32_IDX_DATA + 2] = (data >> 16);
    51b8:	8806d43a 	srli	r3,r17,16
    buf[NIOS_PKT_8x32_IDX_DATA + 3] = (data >> 24);
    51bc:	8822d63a 	srli	r17,r17,24
        buf[NIOS_PKT_8x32_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_8x32_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x32_IDX_ADDR] = addr;
    51c0:	84c00505 	stb	r19,20(r16)

    buf[NIOS_PKT_8x32_IDX_DATA + 0] = data & 0xff;
    buf[NIOS_PKT_8x32_IDX_DATA + 1] = (data >> 8);
    buf[NIOS_PKT_8x32_IDX_DATA + 2] = (data >> 16);
    51c4:	80c005c5 	stb	r3,23(r16)
    buf[NIOS_PKT_8x32_IDX_DATA + 3] = (data >> 24);
    51c8:	84400605 	stb	r17,24(r16)

    buf[NIOS_PKT_8x32_IDX_RESV2 + 0] = 0x00;
    51cc:	80000645 	stb	zero,25(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 1] = 0x00;
    51d0:	80000685 	stb	zero,26(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 2] = 0x00;
    51d4:	800006c5 	stb	zero,27(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 3] = 0x00;
    51d8:	80000705 	stb	zero,28(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 4] = 0x00;
    51dc:	80000745 	stb	zero,29(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 5] = 0x00;
    51e0:	80000785 	stb	zero,30(r16)
    buf[NIOS_PKT_8x32_IDX_RESV2 + 6] = 0x00;
    51e4:	800007c5 	stb	zero,31(r16)
                                           bool write, uint8_t addr,
                                           uint32_t data, bool success)
{
    nios_pkt_8x32_pack(buf, target, write, addr, data);

    if (success) {
    51e8:	10803fcc 	andi	r2,r2,255
    51ec:	10000326 	beq	r2,zero,51fc <pkt_8x32+0x1a8>
        buf[NIOS_PKT_8x32_IDX_FLAGS] |= NIOS_PKT_8x32_FLAG_SUCCESS;
    51f0:	80800483 	ldbu	r2,18(r16)
    51f4:	10800094 	ori	r2,r2,2
    51f8:	80800485 	stb	r2,18(r16)
    } else {
        success = perform_read(id, addr, &data);
    }

    nios_pkt_8x32_resp_pack(b->resp, id, is_write, addr, data, success);
}
    51fc:	dfc00517 	ldw	ra,20(sp)
    5200:	dd000417 	ldw	r20,16(sp)
    5204:	dcc00317 	ldw	r19,12(sp)
    5208:	dc800217 	ldw	r18,8(sp)
    520c:	dc400117 	ldw	r17,4(sp)
    5210:	dc000017 	ldw	r16,0(sp)
    5214:	dec00604 	addi	sp,sp,24
    5218:	f800283a 	ret

0000521c <pkt_8x64>:

    return success;
}

void pkt_8x64(struct pkt_buf *b)
{
    521c:	defffa04 	addi	sp,sp,-24
    5220:	dc000015 	stw	r16,0(sp)
    5224:	dfc00515 	stw	ra,20(sp)
    5228:	dd000415 	stw	r20,16(sp)
    522c:	dcc00315 	stw	r19,12(sp)
    5230:	dc800215 	stw	r18,8(sp)
    5234:	dc400115 	stw	r17,4(sp)
    5238:	2021883a 	mov	r16,r4
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 1] << 8)  |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 2] << 16) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 3] << 24) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 4] << 32) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 5] << 40) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 6] << 48) |
    523c:	20c00183 	ldbu	r3,6(r4)
    5240:	808001c3 	ldbu	r2,7(r16)
    5244:	21400143 	ldbu	r5,5(r4)
    5248:	1806923a 	slli	r3,r3,8
    524c:	1004943a 	slli	r2,r2,16
    5250:	25000083 	ldbu	r20,2(r4)
static inline void nios_pkt_8x64_unpack(const uint8_t *buf, uint8_t *target,
                                        bool *write, uint8_t *addr,
                                        uint64_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_8x64_IDX_TARGET_ID];
    5254:	24800043 	ldbu	r18,1(r4)
    if (write != NULL) {
        *write  = (buf[NIOS_PKT_8x64_IDX_FLAGS] & NIOS_PKT_8x64_FLAG_WRITE) != 0;
    }

    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x64_IDX_ADDR];
    5258:	24400103 	ldbu	r17,4(r4)
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 1] << 8)  |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 2] << 16) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 3] << 24) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 4] << 32) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 5] << 40) |
                  ((uint64_t) buf[NIOS_PKT_8x64_IDX_DATA + 6] << 48) |
    525c:	1948b03a 	or	r4,r3,r5
    5260:	1106b03a 	or	r3,r2,r4
    5264:	80800203 	ldbu	r2,8(r16)
    5268:	81000283 	ldbu	r4,10(r16)
    526c:	81800243 	ldbu	r6,9(r16)
    5270:	1004963a 	slli	r2,r2,24
    5274:	2008923a 	slli	r4,r4,8
    bool    is_write;
    bool    success;

    nios_pkt_8x64_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    5278:	a500004c 	andi	r20,r20,1
    527c:	10c4b03a 	or	r2,r2,r3
    5280:	80c002c3 	ldbu	r3,11(r16)
    5284:	218ab03a 	or	r5,r4,r6
    5288:	1806943a 	slli	r3,r3,16
    528c:	1948b03a 	or	r4,r3,r5
    5290:	80c00303 	ldbu	r3,12(r16)
    5294:	1806963a 	slli	r3,r3,24
    5298:	1906b03a 	or	r3,r3,r4
    529c:	a0000c1e 	bne	r20,zero,52d0 <pkt_8x64+0xb4>

static inline bool perform_read(uint8_t id, uint8_t addr, uint64_t *data)
{
    bool success;

    switch (id) {
    52a0:	91003fcc 	andi	r4,r18,255
    52a4:	20000a1e 	bne	r4,zero,52d0 <pkt_8x64+0xb4>
    }
}

static inline bool read_timestamp(uint8_t addr, uint64_t *data)
{
    switch (addr) {
    52a8:	8cc03fcc 	andi	r19,r17,255
    52ac:	98000426 	beq	r19,zero,52c0 <pkt_8x64+0xa4>
    52b0:	01000044 	movi	r4,1
    52b4:	9900061e 	bne	r19,r4,52d0 <pkt_8x64+0xb4>
        case NIOS_PKT_8x64_TIMESTAMP_RX:
            *data = time_tamer_read(BLADERF_MODULE_RX);
            break;

        case NIOS_PKT_8x64_TIMESTAMP_TX:
            *data = time_tamer_read(BLADERF_MODULE_TX);
    52b8:	9809883a 	mov	r4,r19
    52bc:	00000106 	br	52c4 <pkt_8x64+0xa8>

static inline bool read_timestamp(uint8_t addr, uint64_t *data)
{
    switch (addr) {
        case NIOS_PKT_8x64_TIMESTAMP_RX:
            *data = time_tamer_read(BLADERF_MODULE_RX);
    52c0:	0009883a 	mov	r4,zero
    52c4:	0004c6c0 	call	4c6c <time_tamer_read>
        default:
            DBG("Invalid addr: 0x%02x\n", addr);
            return false;
    }

    return true;
    52c8:	01000044 	movi	r4,1
    52cc:	00000106 	br	52d4 <pkt_8x64+0xb8>
            *data = time_tamer_read(BLADERF_MODULE_TX);
            break;

        default:
            DBG("Invalid addr: 0x%02x\n", addr);
            return false;
    52d0:	0009883a 	mov	r4,zero

/* Pack the request buffer */
static inline void nios_pkt_8x64_pack(uint8_t *buf, uint8_t target, bool write,
                                      uint8_t addr, uint64_t data)
{
    buf[NIOS_PKT_8x64_IDX_MAGIC]     = NIOS_PKT_8x64_MAGIC;
    52d4:	01401104 	movi	r5,68
    52d8:	81400405 	stb	r5,16(r16)
    buf[NIOS_PKT_8x64_IDX_TARGET_ID] = target;
    52dc:	84800445 	stb	r18,17(r16)

    if (write) {
    52e0:	a0000326 	beq	r20,zero,52f0 <pkt_8x64+0xd4>
        buf[NIOS_PKT_8x64_IDX_FLAGS] = NIOS_PKT_8x64_FLAG_WRITE;
    52e4:	01400044 	movi	r5,1
    52e8:	81400485 	stb	r5,18(r16)
    52ec:	00000106 	br	52f4 <pkt_8x64+0xd8>
    } else {
        buf[NIOS_PKT_8x64_IDX_FLAGS] = 0x00;
    52f0:	80000485 	stb	zero,18(r16)
    buf[NIOS_PKT_8x64_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    52f4:	100ad23a 	srli	r5,r2,8

    buf[NIOS_PKT_8x64_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    52f8:	80800545 	stb	r2,21(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    52fc:	80c00645 	stb	r3,25(r16)
    buf[NIOS_PKT_8x64_IDX_RESV1] = 0x00;

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    5300:	81400585 	stb	r5,22(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    5304:	100ad43a 	srli	r5,r2,16
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    5308:	1004d63a 	srli	r2,r2,24
        buf[NIOS_PKT_8x64_IDX_FLAGS] = NIOS_PKT_8x64_FLAG_WRITE;
    } else {
        buf[NIOS_PKT_8x64_IDX_FLAGS] = 0x00;
    }

    buf[NIOS_PKT_8x64_IDX_RESV1] = 0x00;
    530c:	800004c5 	stb	zero,19(r16)

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;
    5310:	84400505 	stb	r17,20(r16)

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    5314:	80800605 	stb	r2,24(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 5] = (data >> 40) & 0xff;
    5318:	1804d23a 	srli	r2,r3,8

    buf[NIOS_PKT_8x64_IDX_ADDR] = addr;

    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    531c:	814005c5 	stb	r5,23(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 5] = (data >> 40) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 6] = (data >> 48) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 7] = (data >> 56) & 0xff;

    buf[NIOS_PKT_8x64_IDX_RESV2 + 0] = 0x00;
    5320:	80000745 	stb	zero,29(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 0] = (data >> 0)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 5] = (data >> 40) & 0xff;
    5324:	80800685 	stb	r2,26(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 6] = (data >> 48) & 0xff;
    5328:	1804d43a 	srli	r2,r3,16
    buf[NIOS_PKT_8x64_IDX_DATA + 7] = (data >> 56) & 0xff;
    532c:	1806d63a 	srli	r3,r3,24

    buf[NIOS_PKT_8x64_IDX_RESV2 + 0] = 0x00;
    buf[NIOS_PKT_8x64_IDX_RESV2 + 1] = 0x00;
    5330:	80000785 	stb	zero,30(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 1] = (data >> 8)  & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 2] = (data >> 16) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 3] = (data >> 24) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 4] = (data >> 32) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 5] = (data >> 40) & 0xff;
    buf[NIOS_PKT_8x64_IDX_DATA + 6] = (data >> 48) & 0xff;
    5334:	808006c5 	stb	r2,27(r16)
    buf[NIOS_PKT_8x64_IDX_DATA + 7] = (data >> 56) & 0xff;
    5338:	80c00705 	stb	r3,28(r16)

    buf[NIOS_PKT_8x64_IDX_RESV2 + 0] = 0x00;
    buf[NIOS_PKT_8x64_IDX_RESV2 + 1] = 0x00;
    buf[NIOS_PKT_8x64_IDX_RESV2 + 2] = 0x00;
    533c:	800007c5 	stb	zero,31(r16)
                                           bool write, uint8_t addr,
                                           uint64_t data, bool success)
{
    nios_pkt_8x64_pack(buf, target, write, addr, data);

    if (success) {
    5340:	21003fcc 	andi	r4,r4,255
    5344:	20000326 	beq	r4,zero,5354 <pkt_8x64+0x138>
        buf[NIOS_PKT_8x64_IDX_FLAGS] |= NIOS_PKT_8x64_FLAG_SUCCESS;
    5348:	80800483 	ldbu	r2,18(r16)
    534c:	10800094 	ori	r2,r2,2
    5350:	80800485 	stb	r2,18(r16)
    } else {
        success = perform_read(id, addr, &data);
    }

    nios_pkt_8x64_resp_pack(b->resp, id, is_write, addr, data, success);
}
    5354:	dfc00517 	ldw	ra,20(sp)
    5358:	dd000417 	ldw	r20,16(sp)
    535c:	dcc00317 	ldw	r19,12(sp)
    5360:	dc800217 	ldw	r18,8(sp)
    5364:	dc400117 	ldw	r17,4(sp)
    5368:	dc000017 	ldw	r16,0(sp)
    536c:	dec00604 	addi	sp,sp,24
    5370:	f800283a 	ret

00005374 <pkt_8x8>:

    return true;
}

void pkt_8x8(struct pkt_buf *b)
{
    5374:	defffa04 	addi	sp,sp,-24
    5378:	dc000015 	stw	r16,0(sp)
    537c:	dfc00515 	stw	ra,20(sp)
    5380:	dd000415 	stw	r20,16(sp)
    5384:	dcc00315 	stw	r19,12(sp)
    5388:	dc800215 	stw	r18,8(sp)
    538c:	dc400115 	stw	r17,4(sp)
    5390:	24c00083 	ldbu	r19,2(r4)
static inline void nios_pkt_8x8_unpack(const uint8_t *buf, uint8_t *target,
                                       bool *write, uint8_t *addr,
                                       uint8_t *data)
{
    if (target != NULL) {
        *target = buf[NIOS_PKT_8x8_IDX_TARGET_ID];
    5394:	25000043 	ldbu	r20,1(r4)
    5398:	2021883a 	mov	r16,r4
    bool    is_write;
    bool    success;

    nios_pkt_8x8_unpack(b->req, &id, &is_write, &addr, &data);

    if (is_write) {
    539c:	9cc0004c 	andi	r19,r19,1
    if (write != NULL) {
        *write  = (buf[NIOS_PKT_8x8_IDX_FLAGS] & NIOS_PKT_8x8_FLAG_WRITE) != 0;
    }

    if (addr != NULL) {
        *addr   = buf[NIOS_PKT_8x8_IDX_ADDR];
    53a0:	24800103 	ldbu	r18,4(r4)
    53a4:	a0803fcc 	andi	r2,r20,255
    53a8:	00c00104 	movi	r3,4
    53ac:	98002126 	beq	r19,zero,5434 <pkt_8x8+0xc0>
    }

    if (data != NULL) {
        *data   = buf[NIOS_PKT_8x8_IDX_DATA];
    53b0:	24400143 	ldbu	r17,5(r4)
    return true;
}

static inline bool perform_write(uint8_t id, uint8_t addr, uint8_t data)
{
    switch (id) {
    53b4:	18803c36 	bltu	r3,r2,54a8 <pkt_8x8+0x134>
    53b8:	100490ba 	slli	r2,r2,2
    53bc:	00c00034 	movhi	r3,0
    53c0:	18d4f404 	addi	r3,r3,21456
    53c4:	10c5883a 	add	r2,r2,r3
    53c8:	10800017 	ldw	r2,0(r2)
    53cc:	1000683a 	jmp	r2
    53d0:	000053e4 	muli	zero,zero,335
    53d4:	000053f4 	movhi	zero,335
    53d8:	00005404 	movi	zero,336
    53dc:	0000541c 	xori	zero,zero,336
    53e0:	00005428 	cmpgeui	zero,zero,336
        case NIOS_PKT_8x8_TARGET_LMS6:
            lms6_write(addr, data);
    53e4:	89403fcc 	andi	r5,r17,255
    53e8:	91003fcc 	andi	r4,r18,255
    53ec:	00048940 	call	4894 <lms6_write>
    53f0:	00003006 	br	54b4 <pkt_8x8+0x140>
            break;

        case NIOS_PKT_8x8_TARGET_SI5338:
            si5338_write(addr, data);
    53f4:	89403fcc 	andi	r5,r17,255
    53f8:	91003fcc 	andi	r4,r18,255
    53fc:	00049800 	call	4980 <si5338_write>
    5400:	00002c06 	br	54b4 <pkt_8x8+0x140>
            break;

        case NIOS_PKT_8x8_TARGET_VCTCXO_TAMER:
            switch (addr) {
    5404:	90803fcc 	andi	r2,r18,255
    5408:	00c03fc4 	movi	r3,255
    540c:	10c0291e 	bne	r2,r3,54b4 <pkt_8x8+0x140>
                /* Using 0xff for mode selection operation so that we can
                 * reserve lower values for register-level access */
                case 0xff:
                    vctcxo_tamer_set_tune_mode((bladerf_vctcxo_tamer_mode) data);
    5410:	89003fcc 	andi	r4,r17,255
    5414:	00045b00 	call	45b0 <vctcxo_tamer_set_tune_mode>
    5418:	00002606 	br	54b4 <pkt_8x8+0x140>
                    break;
            }
            break;

        case NIOS_PKT_8x8_TX_TRIGGER_CTL:
            tx_trigger_ctl_write(data);
    541c:	89003fcc 	andi	r4,r17,255
    5420:	0004bb80 	call	4bb8 <tx_trigger_ctl_write>
    5424:	00002306 	br	54b4 <pkt_8x8+0x140>
            break;

        case NIOS_PKT_8x8_RX_TRIGGER_CTL:
            rx_trigger_ctl_write(data);
    5428:	89003fcc 	andi	r4,r17,255
    542c:	0004bd40 	call	4bd4 <rx_trigger_ctl_write>
    5430:	00002006 	br	54b4 <pkt_8x8+0x140>
#include "devices.h"
#include "debug.h"

static inline bool perform_read(uint8_t id, uint8_t addr, uint8_t *data)
{
    switch (id) {
    5434:	18801b36 	bltu	r3,r2,54a4 <pkt_8x8+0x130>
    5438:	100490ba 	slli	r2,r2,2
    543c:	00c00034 	movhi	r3,0
    5440:	18d51404 	addi	r3,r3,21584
    5444:	10c5883a 	add	r2,r2,r3
    5448:	10800017 	ldw	r2,0(r2)
    544c:	1000683a 	jmp	r2
    5450:	00005464 	muli	zero,zero,337
    5454:	00005470 	cmpltui	zero,zero,337
    5458:	0000547c 	xorhi	zero,zero,337
    545c:	00005490 	cmplti	zero,zero,338
    5460:	00005498 	cmpnei	zero,zero,338
        case NIOS_PKT_8x8_TARGET_LMS6:
            *data = lms6_read(addr);
    5464:	91003fcc 	andi	r4,r18,255
    5468:	00048540 	call	4854 <lms6_read>
    546c:	00000b06 	br	549c <pkt_8x8+0x128>
            break;

        case NIOS_PKT_8x8_TARGET_SI5338:
            *data = si5338_read(addr);
    5470:	91003fcc 	andi	r4,r18,255
    5474:	00048e00 	call	48e0 <si5338_read>
    5478:	00000806 	br	549c <pkt_8x8+0x128>
            break;

        case NIOS_PKT_8x8_TARGET_VCTCXO_TAMER:
            switch (addr) {
    547c:	90803fcc 	andi	r2,r18,255
    5480:	00c03fc4 	movi	r3,255
    5484:	10c00a1e 	bne	r2,r3,54b0 <pkt_8x8+0x13c>
                /* Using 0xff for mode selection operation so that we can
                 * reserve lower values for register-level access */
                case 0xff:
                    *data = (uint8_t) vctcxo_tamer_get_tune_mode();
    5488:	00045c00 	call	45c0 <vctcxo_tamer_get_tune_mode>
    548c:	00000306 	br	549c <pkt_8x8+0x128>
                    *data = 0x00;
            }
            break;

        case NIOS_PKT_8x8_TX_TRIGGER_CTL:
            *data = tx_trigger_ctl_read();
    5490:	0004bc80 	call	4bc8 <tx_trigger_ctl_read>
    5494:	00000106 	br	549c <pkt_8x8+0x128>
            break;

        case NIOS_PKT_8x8_RX_TRIGGER_CTL:
            *data = rx_trigger_ctl_read();
    5498:	0004be40 	call	4be4 <rx_trigger_ctl_read>
    549c:	1023883a 	mov	r17,r2
    54a0:	00000406 	br	54b4 <pkt_8x8+0x140>

        */

        default:
            DBG("%s: Invalid ID: 0x%02x\n", __FUNCTION__, id);
            *data = 0xff;
    54a4:	047fffc4 	movi	r17,-1
            return false;
    54a8:	0007883a 	mov	r3,zero
    54ac:	00000206 	br	54b8 <pkt_8x8+0x144>
                case 0xff:
                    *data = (uint8_t) vctcxo_tamer_get_tune_mode();
                    break;

                default:
                    *data = 0x00;
    54b0:	0023883a 	mov	r17,zero
            DBG("%s: Invalid ID: 0x%02x\n", __FUNCTION__, id);
            *data = 0xff;
            return false;
    }

    return true;
    54b4:	00c00044 	movi	r3,1

/* Pack the request buffer */
static inline void nios_pkt_8x8_pack(uint8_t *buf, uint8_t target, bool write,
                                     uint8_t addr, uint8_t data)
{
    buf[NIOS_PKT_8x8_IDX_MAGIC]     = NIOS_PKT_8x8_MAGIC;
    54b8:	00801044 	movi	r2,65
    54bc:	80800405 	stb	r2,16(r16)
    buf[NIOS_PKT_8x8_IDX_TARGET_ID] = target;
    54c0:	85000445 	stb	r20,17(r16)

    if (write) {
    54c4:	98000326 	beq	r19,zero,54d4 <pkt_8x8+0x160>
        buf[NIOS_PKT_8x8_IDX_FLAGS] = NIOS_PKT_8x8_FLAG_WRITE;
    54c8:	00800044 	movi	r2,1
    54cc:	80800485 	stb	r2,18(r16)
    54d0:	00000106 	br	54d8 <pkt_8x8+0x164>
    } else {
        buf[NIOS_PKT_8x8_IDX_FLAGS] = 0x00;
    54d4:	80000485 	stb	zero,18(r16)
    }

    buf[NIOS_PKT_8x8_IDX_RESV1] = 0x00;
    54d8:	800004c5 	stb	zero,19(r16)

    buf[NIOS_PKT_8x8_IDX_ADDR] = addr;
    54dc:	84800505 	stb	r18,20(r16)
    buf[NIOS_PKT_8x8_IDX_DATA] = data;
    54e0:	84400545 	stb	r17,21(r16)

    buf[NIOS_PKT_8x8_IDX_RESV2 + 0] = 0x00;
    54e4:	80000585 	stb	zero,22(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 1] = 0x00;
    54e8:	800005c5 	stb	zero,23(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 2] = 0x00;
    54ec:	80000605 	stb	zero,24(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 3] = 0x00;
    54f0:	80000645 	stb	zero,25(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 4] = 0x00;
    54f4:	80000685 	stb	zero,26(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 5] = 0x00;
    54f8:	800006c5 	stb	zero,27(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 6] = 0x00;
    54fc:	80000705 	stb	zero,28(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 7] = 0x00;
    5500:	80000745 	stb	zero,29(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 8] = 0x00;
    5504:	80000785 	stb	zero,30(r16)
    buf[NIOS_PKT_8x8_IDX_RESV2 + 9] = 0x00;
    5508:	800007c5 	stb	zero,31(r16)
                                          bool write, uint8_t addr,
                                          uint8_t data, bool success)
{
    nios_pkt_8x8_pack(buf, target, write, addr, data);

    if (success) {
    550c:	18c03fcc 	andi	r3,r3,255
    5510:	18000326 	beq	r3,zero,5520 <pkt_8x8+0x1ac>
        buf[NIOS_PKT_8x8_IDX_FLAGS] |= NIOS_PKT_8x8_FLAG_SUCCESS;
    5514:	80800483 	ldbu	r2,18(r16)
    5518:	10800094 	ori	r2,r2,2
    551c:	80800485 	stb	r2,18(r16)
    } else {
        success = perform_read(id, addr, &data);
    }

    nios_pkt_8x8_resp_pack(b->resp, id, is_write, addr, data, success);
}
    5520:	dfc00517 	ldw	ra,20(sp)
    5524:	dd000417 	ldw	r20,16(sp)
    5528:	dcc00317 	ldw	r19,12(sp)
    552c:	dc800217 	ldw	r18,8(sp)
    5530:	dc400117 	ldw	r17,4(sp)
    5534:	dc000017 	ldw	r16,0(sp)
    5538:	dec00604 	addi	sp,sp,24
    553c:	f800283a 	ret

00005540 <lookup_param>:

    [CONFIG_UNKNOWN]          = { 255, 0 },
};

static inline enum config_param lookup_param(uint8_t addr)
{
    5540:	01400034 	movhi	r5,0
    5544:	295c3f44 	addi	r5,r5,28925
    uint8_t i;

    DBG("Perip lookup for addr=%d\n", addr);

    for (i = 0; i < ARRAY_SIZE(config_params); i++) {
    5548:	0005883a 	mov	r2,zero
        if (config_params[i].start <= addr &&
    554c:	21003fcc 	andi	r4,r4,255
{
    uint8_t i;

    DBG("Perip lookup for addr=%d\n", addr);

    for (i = 0; i < ARRAY_SIZE(config_params); i++) {
    5550:	01800344 	movi	r6,13
        if (config_params[i].start <= addr &&
    5554:	28ffffc3 	ldbu	r3,-1(r5)
    5558:	20c00536 	bltu	r4,r3,5570 <lookup_param+0x30>
    555c:	29c00003 	ldbu	r7,0(r5)
    5560:	38c7883a 	add	r3,r7,r3
    5564:	20c0020e 	bge	r4,r3,5570 <lookup_param+0x30>
            (config_params[i].start + config_params[i].len) > addr) {
            DBG("Found match at entry %d\n", i);
            return (enum config_param) i;
    5568:	10803fcc 	andi	r2,r2,255
    556c:	f800283a 	ret
{
    uint8_t i;

    DBG("Perip lookup for addr=%d\n", addr);

    for (i = 0; i < ARRAY_SIZE(config_params); i++) {
    5570:	10c00044 	addi	r3,r2,1
    5574:	1805883a 	mov	r2,r3
    5578:	18c03fcc 	andi	r3,r3,255
    557c:	29400084 	addi	r5,r5,2
    5580:	19bff41e 	bne	r3,r6,5554 <_gp+0xffff643c>
            return (enum config_param) i;
        }
    }

    DBG("UNKNOWN PARAM.\n");
    return CONFIG_UNKNOWN;
    5584:	00800304 	movi	r2,12
}
    5588:	f800283a 	ret

0000558c <pkt_legacy>:
            break;
    }
}

void pkt_legacy(struct pkt_buf *b)
{
    558c:	defff504 	addi	sp,sp,-44
    5590:	dc400215 	stw	r17,8(sp)
    5594:	dc000115 	stw	r16,4(sp)
    5598:	dfc00a15 	stw	ra,40(sp)
    559c:	df000915 	stw	fp,36(sp)
    55a0:	ddc00815 	stw	r23,32(sp)
    55a4:	dd800715 	stw	r22,28(sp)
    55a8:	dd400615 	stw	r21,24(sp)
    55ac:	dd000515 	stw	r20,20(sp)
    55b0:	dcc00415 	stw	r19,16(sp)
    55b4:	dc800315 	stw	r18,12(sp)
    /* Parse configuration word */
    const uint8_t cfg = b->req[PKT_CFG_IDX];
    55b8:	20c00043 	ldbu	r3,1(r4)
            break;
    }
}

void pkt_legacy(struct pkt_buf *b)
{
    55bc:	2021883a 	mov	r16,r4
    const bool is_write = (cfg & (NIOS_PKT_LEGACY_MODE_DIR_WRITE)) != 0;
    const uint8_t dev_id = (cfg & NIOS_PKT_LEGACY_MODE_DEV_MASK);
    const uint8_t count = (cfg & NIOS_PKT_LEGACY_MODE_CNT_MASK);

    /* Response must start with same magic value and config word */
    b->resp[PKT_MAGIC_IDX] = b->req[PKT_MAGIC_IDX];
    55c0:	81400003 	ldbu	r5,0(r16)
    55c4:	1900100c 	andi	r4,r3,64
{
    /* Parse configuration word */
    const uint8_t cfg = b->req[PKT_CFG_IDX];
    const bool is_read = (cfg & (NIOS_PKT_LEGACY_MODE_DIR_READ)) != 0;
    const bool is_write = (cfg & (NIOS_PKT_LEGACY_MODE_DIR_WRITE)) != 0;
    const uint8_t dev_id = (cfg & NIOS_PKT_LEGACY_MODE_DEV_MASK);
    55c8:	18800c0c 	andi	r2,r3,48
    const uint8_t count = (cfg & NIOS_PKT_LEGACY_MODE_CNT_MASK);
    55cc:	1c4001cc 	andi	r17,r3,7

    /* Response must start with same magic value and config word */
    b->resp[PKT_MAGIC_IDX] = b->req[PKT_MAGIC_IDX];
    b->resp[PKT_CFG_IDX]   = b->req[PKT_CFG_IDX];
    55d0:	80c00445 	stb	r3,17(r16)

    DBG("%s: read=%s, write=%s, dev_id=0x%x, cfg=%x, count=%d\n", __FUNCTION__,
        is_read ? "true" : "false", is_write ? "true" : "false", dev_id, cfg, count);

    if (is_read) {
    55d4:	18c03fcc 	andi	r3,r3,255
    55d8:	18c0201c 	xori	r3,r3,128
    const bool is_write = (cfg & (NIOS_PKT_LEGACY_MODE_DIR_WRITE)) != 0;
    const uint8_t dev_id = (cfg & NIOS_PKT_LEGACY_MODE_DEV_MASK);
    const uint8_t count = (cfg & NIOS_PKT_LEGACY_MODE_CNT_MASK);

    /* Response must start with same magic value and config word */
    b->resp[PKT_MAGIC_IDX] = b->req[PKT_MAGIC_IDX];
    55dc:	81400405 	stb	r5,16(r16)
    b->resp[PKT_CFG_IDX]   = b->req[PKT_CFG_IDX];

    DBG("%s: read=%s, write=%s, dev_id=0x%x, cfg=%x, count=%d\n", __FUNCTION__,
        is_read ? "true" : "false", is_write ? "true" : "false", dev_id, cfg, count);

    if (is_read) {
    55e0:	18ffe004 	addi	r3,r3,-128
    55e4:	1800790e 	bge	r3,zero,57cc <pkt_legacy+0x240>

static inline void legacy_pkt_read(uint8_t dev_id, uint8_t count,
                                   struct pkt_buf *b)
{

    switch (dev_id) {
    55e8:	10803fcc 	andi	r2,r2,255
    55ec:	00c00404 	movi	r3,16
    55f0:	10c01126 	beq	r2,r3,5638 <pkt_legacy+0xac>
    55f4:	00c00c04 	movi	r3,48
    55f8:	10c01426 	beq	r2,r3,564c <pkt_legacy+0xc0>
    55fc:	1000fe1e 	bne	r2,zero,59f8 <pkt_legacy+0x46c>
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);
    5600:	81000083 	ldbu	r4,2(r16)

static uint64_t perform_config_read(enum config_param param)
{
    uint64_t payload;

    switch (param) {
    5604:	05800034 	movhi	r22,0
            payload = perform_config_read(param);
            last_param = param;
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    5608:	05c00034 	movhi	r23,0
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);
    560c:	00055400 	call	5540 <lookup_param>
    5610:	8829883a 	mov	r20,r17
    static uint8_t n = 0;
    static uint64_t payload = 0;
    static enum config_param param = CONFIG_UNKNOWN;
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    5614:	84800084 	addi	r18,r16,2
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];
    5618:	84c00484 	addi	r19,r16,18

    param = lookup_param(b->req[PAYLOAD_IDX]);
    561c:	d0a00415 	stw	r2,-32752(gp)
    5620:	840004c4 	addi	r16,r16,19

    for (i = 0; i < count; i++) {
    5624:	0023883a 	mov	r17,zero

static uint64_t perform_config_read(enum config_param param)
{
    uint64_t payload;

    switch (param) {
    5628:	054002c4 	movi	r21,11
    562c:	b595a804 	addi	r22,r22,22176
            payload = perform_config_read(param);
            last_param = param;
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    5630:	bddc3f04 	addi	r23,r23,28924
    5634:	00000c06 	br	5668 <pkt_legacy+0xdc>
{

    switch (dev_id) {
        case NIOS_PKT_LEGACY_DEV_LMS:
            DBG("%s: Performing LMS6 read.\n", __FUNCTION__);
            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
    5638:	81000083 	ldbu	r4,2(r16)
    563c:	81000485 	stb	r4,18(r16)
            b->resp[DATA_IDX] = lms6_read(b->req[ADDR_IDX]);
    5640:	21003fcc 	andi	r4,r4,255
    5644:	00048540 	call	4854 <lms6_read>
    5648:	00000406 	br	565c <pkt_legacy+0xd0>
            break;

        case NIOS_PKT_LEGACY_DEV_SI5338:
            DBG("%s: Performing SI5338 read.\n", __FUNCTION__);
            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
    564c:	81000083 	ldbu	r4,2(r16)
    5650:	81000485 	stb	r4,18(r16)
            b->resp[DATA_IDX] = si5338_read(b->req[ADDR_IDX]);
    5654:	21003fcc 	andi	r4,r4,255
    5658:	00048e00 	call	48e0 <si5338_read>
    565c:	808004c5 	stb	r2,19(r16)
    5660:	0000e506 	br	59f8 <pkt_legacy+0x46c>
    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);

    for (i = 0; i < count; i++) {
    5664:	8c400044 	addi	r17,r17,1
    5668:	a0803fcc 	andi	r2,r20,255
    566c:	88c03fcc 	andi	r3,r17,255
    5670:	10c0e126 	beq	r2,r3,59f8 <pkt_legacy+0x46c>

        /* Reset if we're at the beggining of a requst, or if it appears
         * that we got a different request while in the middle of the previous
         * series of accesses. */
        if (n == 0 || (param != last_param)) {
    5674:	d0e01403 	ldbu	r3,-32688(gp)
    5678:	d0a00417 	ldw	r2,-32752(gp)
    567c:	18000226 	beq	r3,zero,5688 <pkt_legacy+0xfc>
    5680:	d0e00317 	ldw	r3,-32756(gp)
    5684:	10c03526 	beq	r2,r3,575c <pkt_legacy+0x1d0>
            DBG("Resetting read state for param=%d with n=%d\n", param, n);
            n = 0;
    5688:	d0201405 	stb	zero,-32688(gp)

static uint64_t perform_config_read(enum config_param param)
{
    uint64_t payload;

    switch (param) {
    568c:	a8802936 	bltu	r21,r2,5734 <pkt_legacy+0x1a8>
    5690:	100490ba 	slli	r2,r2,2
    5694:	1585883a 	add	r2,r2,r22
    5698:	10800017 	ldw	r2,0(r2)
    569c:	1000683a 	jmp	r2
    56a0:	000056d8 	cmpnei	zero,zero,347
    56a4:	000056e0 	cmpeqi	zero,zero,347
    56a8:	000056e8 	cmpgeui	zero,zero,347
    56ac:	000056f0 	cmpltui	zero,zero,347
    56b0:	000056fc 	xorhi	zero,zero,347
    56b4:	00005740 	call	574 <__alt_mem_ram-0x3a8c>
    56b8:	0000570c 	andi	zero,zero,348
    56bc:	00005714 	movui	zero,348
    56c0:	000056d0 	cmplti	zero,zero,347
    56c4:	000056d0 	cmplti	zero,zero,347
    56c8:	00005720 	cmpeqi	zero,zero,348
    56cc:	0000572c 	andhi	zero,zero,348
            break;

        case CONFIG_VCTXCO:
            /* TODO Implement VCTCXO trim DAC read */
            DBG("%s: Attempted VCTCXO read.\n", __FUNCTION__);
            payload = 0x00;
    56d0:	0005883a 	mov	r2,zero
    56d4:	00001c06 	br	5748 <pkt_legacy+0x1bc>
}

static inline uint32_t control_reg_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
    56d8:	00a41014 	movui	r2,36928
    56dc:	00001106 	br	5724 <pkt_legacy+0x198>
            payload = control_reg_read();
            break;

        case CONFIG_IQ_CORR_RX_GAIN:
            DBG("%s: Performing RX IQ gain read.\n", __FUNCTION__);
            payload = iqbal_get_gain(BLADERF_MODULE_RX);
    56e0:	0009883a 	mov	r4,zero
    56e4:	00000306 	br	56f4 <pkt_legacy+0x168>
            break;

        case CONFIG_IQ_CORR_RX_PHASE:
            DBG("%s: Performing RX IQ phase read.\n", __FUNCTION__);
            payload = iqbal_get_phase(BLADERF_MODULE_RX);
    56e8:	0009883a 	mov	r4,zero
    56ec:	00000406 	br	5700 <pkt_legacy+0x174>
            break;

        case CONFIG_IQ_CORR_TX_GAIN:
            DBG("%s: Performing TX IQ gain read.\n", __FUNCTION__);
            payload = iqbal_get_gain(BLADERF_MODULE_TX);
    56f0:	01000044 	movi	r4,1
    56f4:	0004b340 	call	4b34 <iqbal_get_gain>
    56f8:	00000206 	br	5704 <pkt_legacy+0x178>
            break;

        case CONFIG_IQ_CORR_TX_PHASE:
            DBG("%s: Performing TX IQ phase read.\n", __FUNCTION__);
            payload = iqbal_get_phase(BLADERF_MODULE_TX);
    56fc:	01000044 	movi	r4,1
    5700:	0004b740 	call	4b74 <iqbal_get_phase>
    5704:	10bfffcc 	andi	r2,r2,65535
    5708:	00000f06 	br	5748 <pkt_legacy+0x1bc>
            payload = fpga_version();
            break;

        case CONFIG_RX_TIMESTAMP:
            DBG("%s: Performing RX timestamp read.\n", __FUNCTION__);
            payload = time_tamer_read(BLADERF_MODULE_RX);
    570c:	0009883a 	mov	r4,zero
    5710:	00000106 	br	5718 <pkt_legacy+0x18c>
            break;

        case CONFIG_TX_TIMESTAMP:
            DBG("%s: Performing TX timestamp read.\n", __FUNCTION__);
            payload = time_tamer_read(BLADERF_MODULE_TX);
    5714:	01000044 	movi	r4,1
    5718:	0004c6c0 	call	4c6c <time_tamer_read>
    571c:	00000b06 	br	574c <pkt_legacy+0x1c0>

}

static inline uint32_t expansion_port_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE);
    5720:	00a42c14 	movui	r2,37040
    5724:	10800037 	ldwio	r2,0(r2)
    5728:	00000706 	br	5748 <pkt_legacy+0x1bc>
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE, value);
}

INLINE uint32_t expansion_port_get_direction()
{
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE);
    572c:	00a42814 	movui	r2,37024
    5730:	003ffc06 	br	5724 <_gp+0xffff660c>
            payload = expansion_port_get_direction();
            break;

        default:
            DBG("Invalid config read parameter: %u\n", param);
            payload = (uint64_t) -1;
    5734:	00bfffc4 	movi	r2,-1
    5738:	1007883a 	mov	r3,r2
    573c:	00000306 	br	574c <pkt_legacy+0x1c0>
            payload = iqbal_get_phase(BLADERF_MODULE_TX);
            break;

        case CONFIG_FPGA_VERSION:
            DBG("%s: Performing FPGA version read.\n", __FUNCTION__);
            payload = fpga_version();
    5740:	00800074 	movhi	r2,1
    5744:	1081c004 	addi	r2,r2,1792
    5748:	0007883a 	mov	r3,zero
         * that we got a different request while in the middle of the previous
         * series of accesses. */
        if (n == 0 || (param != last_param)) {
            DBG("Resetting read state for param=%d with n=%d\n", param, n);
            n = 0;
            payload = perform_config_read(param);
    574c:	d0a01215 	stw	r2,-32696(gp)
            last_param = param;
    5750:	d0a00417 	ldw	r2,-32752(gp)
         * that we got a different request while in the middle of the previous
         * series of accesses. */
        if (n == 0 || (param != last_param)) {
            DBG("Resetting read state for param=%d with n=%d\n", param, n);
            n = 0;
            payload = perform_config_read(param);
    5754:	d0e01315 	stw	r3,-32692(gp)
            last_param = param;
    5758:	d0a00315 	stw	r2,-32756(gp)
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    575c:	d1e00417 	ldw	r7,-32752(gp)

        /* Write read data into response buffer */
        *resp_data++ = (uint8_t) (payload >> (n * 8));
    5760:	d7201403 	ldbu	fp,-32688(gp)
            payload = perform_config_read(param);
            last_param = param;
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    5764:	90800003 	ldbu	r2,0(r18)
    5768:	39cf883a 	add	r7,r7,r7
    576c:	b9cf883a 	add	r7,r23,r7
    5770:	38c00003 	ldbu	r3,0(r7)

        /* Write read data into response buffer */
        *resp_data++ = (uint8_t) (payload >> (n * 8));
    5774:	e1803fcc 	andi	r6,fp,255
    5778:	300c90fa 	slli	r6,r6,3
    577c:	d1201217 	ldw	r4,-32696(gp)
    5780:	d1601317 	ldw	r5,-32692(gp)
            payload = perform_config_read(param);
            last_param = param;
        }

        /* Copy address offset from request to response buffer */
        *resp_data++ = *req_data++ - config_params[param].start;
    5784:	10c5c83a 	sub	r2,r2,r3
    5788:	98800005 	stb	r2,0(r19)

        /* Write read data into response buffer */
        *resp_data++ = (uint8_t) (payload >> (n * 8));
    578c:	d9c00015 	stw	r7,0(sp)
    5790:	0006a900 	call	6a90 <__lshrdi3>
    5794:	80800005 	stb	r2,0(r16)

        req_data++;
        n++;

        /* We've finished returning data for this request - reset and quit . */
        if (n >= config_params[param].len) {
    5798:	d9c00017 	ldw	r7,0(sp)

        /* Write read data into response buffer */
        *resp_data++ = (uint8_t) (payload >> (n * 8));

        req_data++;
        n++;
    579c:	e7000044 	addi	fp,fp,1
    57a0:	d7201405 	stb	fp,-32688(gp)

        /* We've finished returning data for this request - reset and quit . */
        if (n >= config_params[param].len) {
    57a4:	38800043 	ldbu	r2,1(r7)
    57a8:	e7003fcc 	andi	fp,fp,255
    57ac:	9cc00084 	addi	r19,r19,2
    57b0:	94800084 	addi	r18,r18,2
    57b4:	84000084 	addi	r16,r16,2
    57b8:	e0bfaa36 	bltu	fp,r2,5664 <_gp+0xffff654c>
            n = 0;
            param = CONFIG_UNKNOWN;
    57bc:	00800304 	movi	r2,12
        req_data++;
        n++;

        /* We've finished returning data for this request - reset and quit . */
        if (n >= config_params[param].len) {
            n = 0;
    57c0:	d0201405 	stb	zero,-32688(gp)
            param = CONFIG_UNKNOWN;
    57c4:	d0a00415 	stw	r2,-32752(gp)
    57c8:	00008b06 	br	59f8 <pkt_legacy+0x46c>
    DBG("%s: read=%s, write=%s, dev_id=0x%x, cfg=%x, count=%d\n", __FUNCTION__,
        is_read ? "true" : "false", is_write ? "true" : "false", dev_id, cfg, count);

    if (is_read) {
        legacy_pkt_read(dev_id, count, b);
    } else if (is_write) {
    57cc:	20008a26 	beq	r4,zero,59f8 <pkt_legacy+0x46c>

static inline void legacy_pkt_write(uint8_t dev_id, uint8_t count,
                                   struct pkt_buf *b)

{
    switch (dev_id) {
    57d0:	10803fcc 	andi	r2,r2,255
    57d4:	00c00404 	movi	r3,16
    57d8:	10c00426 	beq	r2,r3,57ec <pkt_legacy+0x260>
    57dc:	00c00c04 	movi	r3,48
    57e0:	10c00626 	beq	r2,r3,57fc <pkt_legacy+0x270>
    57e4:	1000841e 	bne	r2,zero,59f8 <pkt_legacy+0x46c>
    57e8:	00000b06 	br	5818 <pkt_legacy+0x28c>
        case NIOS_PKT_LEGACY_DEV_LMS:
            lms6_write(b->req[ADDR_IDX], b->req[DATA_IDX]);
    57ec:	814000c3 	ldbu	r5,3(r16)
    57f0:	81000083 	ldbu	r4,2(r16)
    57f4:	00048940 	call	4894 <lms6_write>
    57f8:	00000306 	br	5808 <pkt_legacy+0x27c>
            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
            b->resp[DATA_IDX] = 0;
            break;

        case NIOS_PKT_LEGACY_DEV_SI5338:
            si5338_write(b->req[ADDR_IDX], b->req[DATA_IDX]);
    57fc:	814000c3 	ldbu	r5,3(r16)
    5800:	81000083 	ldbu	r4,2(r16)
    5804:	00049800 	call	4980 <si5338_write>

            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
    5808:	80800083 	ldbu	r2,2(r16)
            b->resp[DATA_IDX] = 0;
    580c:	800004c5 	stb	zero,19(r16)
            break;

        case NIOS_PKT_LEGACY_DEV_SI5338:
            si5338_write(b->req[ADDR_IDX], b->req[DATA_IDX]);

            b->resp[ADDR_IDX] = b->req[ADDR_IDX];
    5810:	80800485 	stb	r2,18(r16)
    5814:	00007806 	br	59f8 <pkt_legacy+0x46c>
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);
    5818:	81000083 	ldbu	r4,2(r16)
    static uint64_t payload = 0;
    static uint8_t n = 0;
    static enum config_param param = CONFIG_UNKNOWN;
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    581c:	84800084 	addi	r18,r16,2
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];
    5820:	84c00484 	addi	r19,r16,18

    param = lookup_param(b->req[PAYLOAD_IDX]);
    5824:	00055400 	call	5540 <lookup_param>

    /* Reset if we're at the beggining of a requst, or if it appears
     * that we got a different request while in the middle of the previous
     * series of accesses. */
    if (n == 0 || (param != last_param)) {
    5828:	d0e01103 	ldbu	r3,-32700(gp)
    static enum config_param last_param = CONFIG_UNKNOWN;

    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);
    582c:	d0a00215 	stw	r2,-32760(gp)

    /* Reset if we're at the beggining of a requst, or if it appears
     * that we got a different request while in the middle of the previous
     * series of accesses. */
    if (n == 0 || (param != last_param)) {
    5830:	18000226 	beq	r3,zero,583c <pkt_legacy+0x2b0>
    5834:	d0e00117 	ldw	r3,-32764(gp)
    5838:	10c00326 	beq	r2,r3,5848 <pkt_legacy+0x2bc>
        DBG("Resetting write state for param=%d with n=%d\n", param, n);
        payload = 0;
    583c:	d0200f15 	stw	zero,-32708(gp)
    5840:	d0201015 	stw	zero,-32704(gp)
        n = 0;
    5844:	d0201105 	stb	zero,-32700(gp)
    5848:	d1201103 	ldbu	r4,-32700(gp)
    }

    for (i = 0; i < count && n < config_params[param].len; i++) {
    584c:	02000034 	movhi	r8,0
    5850:	1095883a 	add	r10,r2,r2
    5854:	421c3f04 	addi	r8,r8,28924
    5858:	d1e00f17 	ldw	r7,-32708(gp)
    585c:	d1a01017 	ldw	r6,-32704(gp)
    5860:	8923883a 	add	r17,r17,r4
    5864:	4291883a 	add	r8,r8,r10
    5868:	824004c4 	addi	r9,r16,19
    const uint8_t *req_data = &b->req[PAYLOAD_IDX];
    uint8_t *resp_data = &b->resp[PAYLOAD_IDX];

    param = lookup_param(b->req[PAYLOAD_IDX]);

    for (i = 0; i < count; i++) {
    586c:	0007883a 	mov	r3,zero
    5870:	840000c4 	addi	r16,r16,3
        DBG("Resetting write state for param=%d with n=%d\n", param, n);
        payload = 0;
        n = 0;
    }

    for (i = 0; i < count && n < config_params[param].len; i++) {
    5874:	8c403fcc 	andi	r17,r17,255
    5878:	43000044 	addi	r12,r8,1
    587c:	21403fcc 	andi	r5,r4,255
    5880:	89401526 	beq	r17,r5,58d8 <pkt_legacy+0x34c>
    5884:	62c00003 	ldbu	r11,0(r12)
    5888:	23400044 	addi	r13,r4,1
    588c:	2ac0122e 	bgeu	r5,r11,58d8 <pkt_legacy+0x34c>
        /* Copy over address offset into response, and zero out data*/
        *resp_data++ = *req_data++ - config_params[param].start;
    5890:	91000003 	ldbu	r4,0(r18)
    5894:	40c00003 	ldbu	r3,0(r8)
        *resp_data++ = 0;

        /* Shift data into our aggregated payload word */
        payload |= (*req_data) << (n * 8);
    5898:	280a90fa 	slli	r5,r5,3
    589c:	9cc00084 	addi	r19,r19,2
        n = 0;
    }

    for (i = 0; i < count && n < config_params[param].len; i++) {
        /* Copy over address offset into response, and zero out data*/
        *resp_data++ = *req_data++ - config_params[param].start;
    58a0:	20c9c83a 	sub	r4,r4,r3
    58a4:	993fff85 	stb	r4,-2(r19)
        *resp_data++ = 0;
    58a8:	48000005 	stb	zero,0(r9)

        /* Shift data into our aggregated payload word */
        payload |= (*req_data) << (n * 8);
    58ac:	80c00003 	ldbu	r3,0(r16)
    58b0:	94800084 	addi	r18,r18,2
    58b4:	4a400084 	addi	r9,r9,2
    58b8:	194a983a 	sll	r5,r3,r5
    58bc:	84000084 	addi	r16,r16,2
    58c0:	6809883a 	mov	r4,r13
    58c4:	2807d7fa 	srai	r3,r5,31
    58c8:	394eb03a 	or	r7,r7,r5
    58cc:	30ccb03a 	or	r6,r6,r3
    58d0:	00c00044 	movi	r3,1
    58d4:	003fe906 	br	587c <_gp+0xffff6764>
    58d8:	18c03fcc 	andi	r3,r3,255
    58dc:	18000326 	beq	r3,zero,58ec <pkt_legacy+0x360>
    58e0:	d1201105 	stb	r4,-32700(gp)
    58e4:	d1e00f15 	stw	r7,-32708(gp)
    58e8:	d1a01015 	stw	r6,-32704(gp)
        req_data++;
        n++;
    }

    /* We aggregated all the data we need - perform the write and reset */
    if (n >= config_params[param].len) {
    58ec:	00c00034 	movhi	r3,0
    58f0:	18dc3f04 	addi	r3,r3,28924
    58f4:	1a87883a 	add	r3,r3,r10
    58f8:	18c00043 	ldbu	r3,1(r3)
    58fc:	d1201103 	ldbu	r4,-32700(gp)
    5900:	20c03b36 	bltu	r4,r3,59f0 <pkt_legacy+0x464>
    }
}

static inline void perform_config_write(enum config_param p, uint64_t payload)
{
    switch (p) {
    5904:	00c002c4 	movi	r3,11
        n++;
    }

    /* We aggregated all the data we need - perform the write and reset */
    if (n >= config_params[param].len) {
        perform_config_write(param, payload);
    5908:	d4200f17 	ldw	r16,-32708(gp)
    }
}

static inline void perform_config_write(enum config_param p, uint64_t payload)
{
    switch (p) {
    590c:	18803536 	bltu	r3,r2,59e4 <pkt_legacy+0x458>
    5910:	100490ba 	slli	r2,r2,2
    5914:	00c00034 	movhi	r3,0
    5918:	18d64a04 	addi	r3,r3,22824
    591c:	10c5883a 	add	r2,r2,r3
    5920:	10800017 	ldw	r2,0(r2)
    5924:	1000683a 	jmp	r2
    5928:	00005958 	cmpnei	zero,zero,357
    592c:	00005960 	cmpeqi	zero,zero,357
    5930:	0000596c 	andhi	zero,zero,357
    5934:	00005978 	rdprs	zero,zero,357
    5938:	00005988 	cmpgei	zero,zero,358
    593c:	000059e4 	muli	zero,zero,359
    5940:	00005998 	cmpnei	zero,zero,358
    5944:	000059a0 	cmpeqi	zero,zero,358
    5948:	000059ac 	andhi	zero,zero,358
    594c:	000059c8 	cmpgei	zero,zero,359
    5950:	000059d4 	movui	zero,359
    5954:	000059dc 	xori	zero,zero,359
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
}

static inline void control_reg_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
    5958:	00a41014 	movui	r2,36928
    595c:	00002006 	br	59e0 <pkt_legacy+0x454>
        case CONFIG_CONTROL_REG:
            control_reg_write((uint32_t) payload);
            break;

        case CONFIG_IQ_CORR_RX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_RX, (uint16_t) payload);
    5960:	817fffcc 	andi	r5,r16,65535
    5964:	0009883a 	mov	r4,zero
    5968:	00000506 	br	5980 <pkt_legacy+0x3f4>
            break;

        case CONFIG_IQ_CORR_RX_PHASE:
            iqbal_set_phase(BLADERF_MODULE_RX, (uint16_t) payload);
    596c:	817fffcc 	andi	r5,r16,65535
    5970:	0009883a 	mov	r4,zero
    5974:	00000606 	br	5990 <pkt_legacy+0x404>
            break;

        case CONFIG_IQ_CORR_TX_GAIN:
            iqbal_set_gain(BLADERF_MODULE_TX, (uint16_t) payload);
    5978:	817fffcc 	andi	r5,r16,65535
    597c:	01000044 	movi	r4,1
    5980:	0004b4c0 	call	4b4c <iqbal_set_gain>
    5984:	00001706 	br	59e4 <pkt_legacy+0x458>
            break;

        case CONFIG_IQ_CORR_TX_PHASE:
            iqbal_set_phase(BLADERF_MODULE_TX, (uint16_t) payload);
    5988:	817fffcc 	andi	r5,r16,65535
    598c:	01000044 	movi	r4,1
    5990:	0004b900 	call	4b90 <iqbal_set_phase>
    5994:	00001306 	br	59e4 <pkt_legacy+0x458>

INLINE void time_tamer_reset(bladerf_module m)
{
    /* A single write is sufficient to clear the timestamp counter */
    if (m == BLADERF_MODULE_RX) {
        IOWR_8DIRECT(RX_TAMER_BASE, 0, 0);
    5998:	00a45814 	movui	r2,37216
    599c:	00000106 	br	59a4 <pkt_legacy+0x418>
    } else {
        IOWR_8DIRECT(TX_TAMER_BASE, 0, 0);
    59a0:	00a45014 	movui	r2,37184
    59a4:	10000025 	stbio	zero,0(r2)
    59a8:	00000e06 	br	59e4 <pkt_legacy+0x458>
             * yielding writes for these specific commands:
             *
             * Command 0x28: Set device to write-through mode
             * Command 0x08: Write value to channel 0
             */
            vctcxo_trim_dac_write(0x28, 0);
    59ac:	000b883a 	mov	r5,zero
    59b0:	01000a04 	movi	r4,40
    59b4:	0004a0c0 	call	4a0c <vctcxo_trim_dac_write>
            vctcxo_trim_dac_write(0x08, (uint16_t) payload);
    59b8:	817fffcc 	andi	r5,r16,65535
    59bc:	01000204 	movi	r4,8
    59c0:	0004a0c0 	call	4a0c <vctcxo_trim_dac_write>
    59c4:	00000706 	br	59e4 <pkt_legacy+0x458>
            break;

        case CONFIG_XB200_SYNTH:
            adf4351_write((uint32_t) payload);
    59c8:	8009883a 	mov	r4,r16
    59cc:	0004ae00 	call	4ae0 <adf4351_write>
    59d0:	00000406 	br	59e4 <pkt_legacy+0x458>
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE);
}

INLINE void expansion_port_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_BASE, value);
    59d4:	00a42c14 	movui	r2,37040
    59d8:	00000106 	br	59e0 <pkt_legacy+0x454>
    return IORD_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE);
}

INLINE void expansion_port_set_direction(uint32_t dir)
{
    IOWR_ALTERA_AVALON_PIO_DATA(XB_GPIO_DIR_BASE, dir);
    59dc:	00a42814 	movui	r2,37024
    59e0:	14000035 	stwio	r16,0(r2)

    /* We aggregated all the data we need - perform the write and reset */
    if (n >= config_params[param].len) {
        perform_config_write(param, payload);
        n = 0;
        param = CONFIG_UNKNOWN;
    59e4:	00800304 	movi	r2,12
    }

    /* We aggregated all the data we need - perform the write and reset */
    if (n >= config_params[param].len) {
        perform_config_write(param, payload);
        n = 0;
    59e8:	d0201105 	stb	zero,-32700(gp)
        param = CONFIG_UNKNOWN;
    59ec:	d0a00215 	stw	r2,-32760(gp)
    }

    last_param = param;
    59f0:	d0a00217 	ldw	r2,-32760(gp)
    59f4:	d0a00115 	stw	r2,-32764(gp)
    } else if (is_write) {
        legacy_pkt_write(dev_id, count, b);
    } else {
        DBG("Config word did not have R/W: 0x%x\n", cfg);
    }
}
    59f8:	dfc00a17 	ldw	ra,40(sp)
    59fc:	df000917 	ldw	fp,36(sp)
    5a00:	ddc00817 	ldw	r23,32(sp)
    5a04:	dd800717 	ldw	r22,28(sp)
    5a08:	dd400617 	ldw	r21,24(sp)
    5a0c:	dd000517 	ldw	r20,20(sp)
    5a10:	dcc00417 	ldw	r19,16(sp)
    5a14:	dc800317 	ldw	r18,12(sp)
    5a18:	dc400217 	ldw	r17,8(sp)
    5a1c:	dc000117 	ldw	r16,4(sp)
    5a20:	dec00b04 	addi	sp,sp,44
    5a24:	f800283a 	ret

00005a28 <reset_queue>:
/* The retune interrupt may fire while this call is occuring, so we should
 * perform these operations in an order that minimizes the race window, and
 * does not cause the race to be problematic. It's fine if the last retune
 * occurs before we can cancel it. */
static void reset_queue(struct queue *q)
{
    5a28:	defffc04 	addi	sp,sp,-16
    5a2c:	dc800215 	stw	r18,8(sp)
    5a30:	dc400115 	stw	r17,4(sp)
    5a34:	dc000015 	stw	r16,0(sp)
    5a38:	dfc00315 	stw	ra,12(sp)
    5a3c:	2021883a 	mov	r16,r4
    unsigned int i;

    q->count = 0;
    5a40:	20000005 	stb	zero,0(r4)

    for (i = 0; i < RETUNE_QUEUE_MAX; i++) {
    5a44:	0023883a 	mov	r17,zero
    5a48:	04800404 	movi	r18,16
        q->entries[i].state = ENTRY_STATE_INVALID;
    5a4c:	8809883a 	mov	r4,r17
    5a50:	01400604 	movi	r5,24
    5a54:	0006c840 	call	6c84 <__mulsi3>
    5a58:	8085883a 	add	r2,r16,r2
    5a5c:	10800104 	addi	r2,r2,4
    5a60:	10000015 	stw	zero,0(r2)
{
    unsigned int i;

    q->count = 0;

    for (i = 0; i < RETUNE_QUEUE_MAX; i++) {
    5a64:	8c400044 	addi	r17,r17,1
    5a68:	8cbff81e 	bne	r17,r18,5a4c <_gp+0xffff6934>
        q->entries[i].state = ENTRY_STATE_INVALID;
    }

    q->rem_idx = q->ins_idx = 0;
    5a6c:	80000045 	stb	zero,1(r16)
    5a70:	80000085 	stb	zero,2(r16)
}
    5a74:	dfc00317 	ldw	ra,12(sp)
    5a78:	dc800217 	ldw	r18,8(sp)
    5a7c:	dc400117 	ldw	r17,4(sp)
    5a80:	dc000017 	ldw	r16,0(sp)
    5a84:	dec00404 	addi	sp,sp,16
    5a88:	f800283a 	ret

00005a8c <retune_isr>:
}

/* Get the state of the next item in the retune queue */
static inline struct queue_entry * peek_next_retune(struct queue *q)
{
    if (q->count == 0) {
    5a8c:	20800003 	ldbu	r2,0(r4)
    5a90:	10001c26 	beq	r2,zero,5b04 <retune_isr+0x78>

    q->rem_idx = q->ins_idx = 0;
}

static inline void retune_isr(struct queue *q)
{
    5a94:	defffd04 	addi	sp,sp,-12
    5a98:	dc000015 	stw	r16,0(sp)
    5a9c:	dfc00215 	stw	ra,8(sp)
    5aa0:	dc400115 	stw	r17,4(sp)
static inline struct queue_entry * peek_next_retune(struct queue *q)
{
    if (q->count == 0) {
        return NULL;
    } else {
        return &q->entries[q->rem_idx];
    5aa4:	24400083 	ldbu	r17,2(r4)
    5aa8:	2021883a 	mov	r16,r4
    5aac:	01400604 	movi	r5,24
    5ab0:	8809883a 	mov	r4,r17
    5ab4:	0006c840 	call	6c84 <__mulsi3>
    5ab8:	10c00104 	addi	r3,r2,4
    5abc:	80c7883a 	add	r3,r16,r3
}

static inline void retune_isr(struct queue *q)
{
    struct queue_entry *e = peek_next_retune(q);
    if (e != NULL) {
    5ac0:	18000c26 	beq	r3,zero,5af4 <retune_isr+0x68>
        if (e->state == ENTRY_STATE_SCHEDULED) {
    5ac4:	8085883a 	add	r2,r16,r2
    5ac8:	10800104 	addi	r2,r2,4
    5acc:	10c00017 	ldw	r3,0(r2)
    5ad0:	00800084 	movi	r2,2
    5ad4:	1880071e 	bne	r3,r2,5af4 <retune_isr+0x68>
            e->state = ENTRY_STATE_READY;
    5ad8:	01400604 	movi	r5,24
    5adc:	8809883a 	mov	r4,r17
    5ae0:	0006c840 	call	6c84 <__mulsi3>
    5ae4:	8085883a 	add	r2,r16,r2
    5ae8:	10800104 	addi	r2,r2,4
    5aec:	00c000c4 	movi	r3,3
    5af0:	10c00015 	stw	r3,0(r2)
        } else {
            INCREMENT_ERROR_COUNT();
        }
    }
}
    5af4:	dfc00217 	ldw	ra,8(sp)
    5af8:	dc400117 	ldw	r17,4(sp)
    5afc:	dc000017 	ldw	r16,0(sp)
    5b00:	dec00304 	addi	sp,sp,12
    5b04:	f800283a 	ret

00005b08 <retune_tx>:
}

static void retune_tx(void *context)
{
	/* Handle the ISR */
    retune_isr(&tx_queue);
    5b08:	01000034 	movhi	r4,0
    /* Clear the interrupt */
    timer_tamer_clear_interrupt(BLADERF_MODULE_RX);
}

static void retune_tx(void *context)
{
    5b0c:	deffff04 	addi	sp,sp,-4
	/* Handle the ISR */
    retune_isr(&tx_queue);
    5b10:	211c5f04 	addi	r4,r4,29052
    /* Clear the interrupt */
    timer_tamer_clear_interrupt(BLADERF_MODULE_RX);
}

static void retune_tx(void *context)
{
    5b14:	dfc00015 	stw	ra,0(sp)
	/* Handle the ISR */
    retune_isr(&tx_queue);
    5b18:	0005a8c0 	call	5a8c <retune_isr>
INLINE void timer_tamer_clear_interrupt(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        IOWR_8DIRECT(RX_TAMER_BASE, 8, 1) ;
    } else {
        IOWR_8DIRECT(TX_TAMER_BASE, 8, 1) ;
    5b1c:	00a45214 	movui	r2,37192
    5b20:	00c00044 	movi	r3,1
    5b24:	10c00025 	stbio	r3,0(r2)

    /* Clear the interrupt */
    timer_tamer_clear_interrupt(BLADERF_MODULE_TX);
}
    5b28:	dfc00017 	ldw	ra,0(sp)
    5b2c:	dec00104 	addi	sp,sp,4
    5b30:	f800283a 	ret

00005b34 <retune_rx>:

#ifndef BLADERF_NIOS_PC_SIMULATION
static void retune_rx(void *context)
{
	/* Handle the ISR */
    retune_isr(&rx_queue);
    5b34:	01000034 	movhi	r4,0
}


#ifndef BLADERF_NIOS_PC_SIMULATION
static void retune_rx(void *context)
{
    5b38:	deffff04 	addi	sp,sp,-4
	/* Handle the ISR */
    retune_isr(&rx_queue);
    5b3c:	211cc004 	addi	r4,r4,29440
}


#ifndef BLADERF_NIOS_PC_SIMULATION
static void retune_rx(void *context)
{
    5b40:	dfc00015 	stw	ra,0(sp)
	/* Handle the ISR */
    retune_isr(&rx_queue);
    5b44:	0005a8c0 	call	5a8c <retune_isr>
}

INLINE void timer_tamer_clear_interrupt(bladerf_module m)
{
    if (m == BLADERF_MODULE_RX) {
        IOWR_8DIRECT(RX_TAMER_BASE, 8, 1) ;
    5b48:	00a45a14 	movui	r2,37224
    5b4c:	00c00044 	movi	r3,1
    5b50:	10c00025 	stbio	r3,0(r2)

    /* Clear the interrupt */
    timer_tamer_clear_interrupt(BLADERF_MODULE_RX);
}
    5b54:	dfc00017 	ldw	ra,0(sp)
    5b58:	dec00104 	addi	sp,sp,4
    5b5c:	f800283a 	ret

00005b60 <perform_work>:
}

/* Get the state of the next item in the retune queue */
static inline struct queue_entry * peek_next_retune(struct queue *q)
{
    if (q->count == 0) {
    5b60:	20800003 	ldbu	r2,0(r4)
    5b64:	10004326 	beq	r2,zero,5c74 <perform_work+0x114>
    ) ;
#endif
}

static inline void perform_work(struct queue *q, bladerf_module module)
{
    5b68:	defffc04 	addi	sp,sp,-16
    5b6c:	dc400115 	stw	r17,4(sp)
    5b70:	dc000015 	stw	r16,0(sp)
    5b74:	dfc00315 	stw	ra,12(sp)
    5b78:	dc800215 	stw	r18,8(sp)
static inline struct queue_entry * peek_next_retune(struct queue *q)
{
    if (q->count == 0) {
        return NULL;
    } else {
        return &q->entries[q->rem_idx];
    5b7c:	24800083 	ldbu	r18,2(r4)
    5b80:	2021883a 	mov	r16,r4
    5b84:	2823883a 	mov	r17,r5
    5b88:	9009883a 	mov	r4,r18
    5b8c:	01400604 	movi	r5,24
    5b90:	0006c840 	call	6c84 <__mulsi3>
    5b94:	10c00104 	addi	r3,r2,4
    5b98:	80c7883a 	add	r3,r16,r3

static inline void perform_work(struct queue *q, bladerf_module module)
{
    struct queue_entry *e = peek_next_retune(q);

    if (e == NULL) {
    5b9c:	18003026 	beq	r3,zero,5c60 <perform_work+0x100>
        return;
    }

    switch (e->state) {
    5ba0:	8087883a 	add	r3,r16,r2
    5ba4:	18c00104 	addi	r3,r3,4
    5ba8:	19000017 	ldw	r4,0(r3)
    5bac:	01400044 	movi	r5,1
    5bb0:	21400326 	beq	r4,r5,5bc0 <perform_work+0x60>
    5bb4:	00c000c4 	movi	r3,3
    5bb8:	20c01126 	beq	r4,r3,5c00 <perform_work+0xa0>
    5bbc:	00002806 	br	5c60 <perform_work+0x100>
        case ENTRY_STATE_NEW:
            e->state = ENTRY_STATE_SCHEDULED;
    5bc0:	00800084 	movi	r2,2
            tamer_schedule(module, e->timestamp);
    5bc4:	9009883a 	mov	r4,r18
        return;
    }

    switch (e->state) {
        case ENTRY_STATE_NEW:
            e->state = ENTRY_STATE_SCHEDULED;
    5bc8:	18800015 	stw	r2,0(r3)
            tamer_schedule(module, e->timestamp);
    5bcc:	01400604 	movi	r5,24
    5bd0:	0006c840 	call	6c84 <__mulsi3>
    5bd4:	8085883a 	add	r2,r16,r2
    5bd8:	10800504 	addi	r2,r2,20
    5bdc:	11400017 	ldw	r5,0(r2)
    5be0:	11800117 	ldw	r6,4(r2)
    5be4:	8809883a 	mov	r4,r17

        default:
            INCREMENT_ERROR_COUNT();
            break;
    }
}
    5be8:	dfc00317 	ldw	ra,12(sp)
    5bec:	dc800217 	ldw	r18,8(sp)
    5bf0:	dc400117 	ldw	r17,4(sp)
    5bf4:	dc000017 	ldw	r16,0(sp)
    5bf8:	dec00404 	addi	sp,sp,16
    }

    switch (e->state) {
        case ENTRY_STATE_NEW:
            e->state = ENTRY_STATE_SCHEDULED;
            tamer_schedule(module, e->timestamp);
    5bfc:	00047081 	jmpi	4708 <tamer_schedule>
            break;

        case ENTRY_STATE_READY:

            /* Perform our retune */
            if (lms_set_precalculated_frequency(NULL, module, &e->freq)) {
    5c00:	11800204 	addi	r6,r2,8
    5c04:	818d883a 	add	r6,r16,r6
    5c08:	880b883a 	mov	r5,r17
    5c0c:	0009883a 	mov	r4,zero
    5c10:	000661c0 	call	661c <lms_set_precalculated_frequency>
    5c14:	1000091e 	bne	r2,zero,5c3c <perform_work+0xdc>
                INCREMENT_ERROR_COUNT();
            } else {
                bool low_band = (e->freq.flags & LMS_FREQ_FLAGS_LOW_BAND) != 0;
    5c18:	01400604 	movi	r5,24
    5c1c:	9009883a 	mov	r4,r18
    5c20:	0006c840 	call	6c84 <__mulsi3>
    5c24:	8085883a 	add	r2,r16,r2
                if (band_select(NULL, module, low_band)) {
    5c28:	11800403 	ldbu	r6,16(r2)
    5c2c:	880b883a 	mov	r5,r17
    5c30:	0009883a 	mov	r4,zero
    5c34:	3180004c 	andi	r6,r6,1
    5c38:	00060ac0 	call	60ac <band_select>
 * or QUEUE_EMPTY if there was nothing to dequeue */
static inline uint8_t dequeue_retune(struct queue *q, struct queue_entry *e)
{
    uint8_t ret;

    if (q->count == 0) {
    5c3c:	80c00003 	ldbu	r3,0(r16)
    5c40:	18803fcc 	andi	r2,r3,255
    5c44:	10000626 	beq	r2,zero,5c60 <perform_work+0x100>

    if (e != NULL) {
        memcpy(&e, &q->entries[q->rem_idx], sizeof(e[0]));
    }

    q->rem_idx = (q->rem_idx + 1) & (RETUNE_QUEUE_MAX - 1);
    5c48:	80800083 	ldbu	r2,2(r16)

    q->count--;
    5c4c:	18ffffc4 	addi	r3,r3,-1
    5c50:	80c00005 	stb	r3,0(r16)

    if (e != NULL) {
        memcpy(&e, &q->entries[q->rem_idx], sizeof(e[0]));
    }

    q->rem_idx = (q->rem_idx + 1) & (RETUNE_QUEUE_MAX - 1);
    5c54:	10800044 	addi	r2,r2,1
    5c58:	108003cc 	andi	r2,r2,15
    5c5c:	80800085 	stb	r2,2(r16)

        default:
            INCREMENT_ERROR_COUNT();
            break;
    }
}
    5c60:	dfc00317 	ldw	ra,12(sp)
    5c64:	dc800217 	ldw	r18,8(sp)
    5c68:	dc400117 	ldw	r17,4(sp)
    5c6c:	dc000017 	ldw	r16,0(sp)
    5c70:	dec00404 	addi	sp,sp,16
    5c74:	f800283a 	ret

00005c78 <pkt_retune_init>:
#endif


void pkt_retune_init()
{
    reset_queue(&rx_queue);
    5c78:	01000034 	movhi	r4,0
}
#endif


void pkt_retune_init()
{
    5c7c:	defffe04 	addi	sp,sp,-8
    reset_queue(&rx_queue);
    5c80:	211cc004 	addi	r4,r4,29440
}
#endif


void pkt_retune_init()
{
    5c84:	dfc00115 	stw	ra,4(sp)
    reset_queue(&rx_queue);
    5c88:	0005a280 	call	5a28 <reset_queue>
    reset_queue(&tx_queue);
    5c8c:	01000034 	movhi	r4,0
    5c90:	211c5f04 	addi	r4,r4,29052
    5c94:	0005a280 	call	5a28 <reset_queue>

#ifndef BLADERF_NIOS_PC_SIMULATION

    /* Register RX Time Tamer ISR */
    alt_ic_isr_register(
    5c98:	01800034 	movhi	r6,0
    5c9c:	d8000015 	stw	zero,0(sp)
    5ca0:	000f883a 	mov	r7,zero
    5ca4:	3196cd04 	addi	r6,r6,23348
    5ca8:	014000c4 	movi	r5,3
    5cac:	0009883a 	mov	r4,zero
    5cb0:	0006cf40 	call	6cf4 <alt_ic_isr_register>
        NULL,
        NULL
    ) ;

    /* Register TX Time Tamer ISR */
    alt_ic_isr_register(
    5cb4:	01800034 	movhi	r6,0
    5cb8:	d8000015 	stw	zero,0(sp)
    5cbc:	000f883a 	mov	r7,zero
    5cc0:	3196c204 	addi	r6,r6,23304
    5cc4:	01400084 	movi	r5,2
    5cc8:	0009883a 	mov	r4,zero
    5ccc:	0006cf40 	call	6cf4 <alt_ic_isr_register>
        retune_tx,
        NULL,
        NULL
    ) ;
#endif
}
    5cd0:	dfc00117 	ldw	ra,4(sp)
    5cd4:	dec00204 	addi	sp,sp,8
    5cd8:	f800283a 	ret

00005cdc <pkt_retune_work>:
    }
}

void pkt_retune_work(void)
{
    perform_work(&rx_queue, BLADERF_MODULE_RX);
    5cdc:	01000034 	movhi	r4,0
            break;
    }
}

void pkt_retune_work(void)
{
    5ce0:	deffff04 	addi	sp,sp,-4
    perform_work(&rx_queue, BLADERF_MODULE_RX);
    5ce4:	000b883a 	mov	r5,zero
    5ce8:	211cc004 	addi	r4,r4,29440
            break;
    }
}

void pkt_retune_work(void)
{
    5cec:	dfc00015 	stw	ra,0(sp)
    perform_work(&rx_queue, BLADERF_MODULE_RX);
    5cf0:	0005b600 	call	5b60 <perform_work>
    perform_work(&tx_queue, BLADERF_MODULE_TX);
    5cf4:	01000034 	movhi	r4,0
    5cf8:	01400044 	movi	r5,1
    5cfc:	211c5f04 	addi	r4,r4,29052
}
    5d00:	dfc00017 	ldw	ra,0(sp)
    5d04:	dec00104 	addi	sp,sp,4
}

void pkt_retune_work(void)
{
    perform_work(&rx_queue, BLADERF_MODULE_RX);
    perform_work(&tx_queue, BLADERF_MODULE_TX);
    5d08:	0005b601 	jmpi	5b60 <perform_work>

00005d0c <pkt_retune>:
}

void pkt_retune(struct pkt_buf *b)
{
    5d0c:	defff304 	addi	sp,sp,-52
    5d10:	dc000315 	stw	r16,12(sp)
    5d14:	2021883a 	mov	r16,r4
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 2]) << 16);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 3]) << 24);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 4]) << 32);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 5]) << 40);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 6]) << 48);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 7]) << 56);
    5d18:	80800083 	ldbu	r2,2(r16)
    5d1c:	dd400815 	stw	r21,32(sp)
    5d20:	854000c3 	ldbu	r21,3(r16)
    5d24:	dc400415 	stw	r17,16(sp)
    5d28:	dfc00c15 	stw	ra,48(sp)
    5d2c:	df000b15 	stw	fp,44(sp)
    5d30:	ddc00a15 	stw	r23,40(sp)
    5d34:	dd800915 	stw	r22,36(sp)
    5d38:	dd000715 	stw	r20,28(sp)
    5d3c:	dcc00615 	stw	r19,24(sp)
    5d40:	dc800515 	stw	r18,20(sp)
    5d44:	21000043 	ldbu	r4,1(r4)
    5d48:	1004923a 	slli	r2,r2,8
    5d4c:	a82a943a 	slli	r21,r21,16
    5d50:	844001c3 	ldbu	r17,7(r16)
    5d54:	1106b03a 	or	r3,r2,r4
    5d58:	a8c4b03a 	or	r2,r21,r3
    5d5c:	85400103 	ldbu	r21,4(r16)
    5d60:	81000143 	ldbu	r4,5(r16)
    5d64:	8822943a 	slli	r17,r17,16
    5d68:	a82a963a 	slli	r21,r21,24
    5d6c:	a8aab03a 	or	r21,r21,r2
    5d70:	80800183 	ldbu	r2,6(r16)
    5d74:	1004923a 	slli	r2,r2,8
    5d78:	1106b03a 	or	r3,r2,r4
    5d7c:	88c4b03a 	or	r2,r17,r3
    5d80:	84400203 	ldbu	r17,8(r16)

    *nint  = buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 0] << 1;
    *nint |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] >> 7;
    5d84:	80c00243 	ldbu	r3,9(r16)
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 2]) << 16);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 3]) << 24);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 4]) << 32);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 5]) << 40);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 6]) << 48);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 7]) << 56);
    5d88:	8822963a 	slli	r17,r17,24

    *nint  = buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 0] << 1;
    *nint |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] >> 7;
    5d8c:	18c7883a 	add	r3,r3,r3
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 2]) << 16);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 3]) << 24);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 4]) << 32);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 5]) << 40);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 6]) << 48);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 7]) << 56);
    5d90:	88a2b03a 	or	r17,r17,r2

    *nint  = buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 0] << 1;
    *nint |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] >> 7;
    5d94:	80800283 	ldbu	r2,10(r16)
    5d98:	11003fcc 	andi	r4,r2,255
    5d9c:	2008d1fa 	srli	r4,r4,7

    *nfrac  = (buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] & 0x7f) << 16;
    *nfrac |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 2] << 8;
    *nfrac |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 3];
    5da0:	10801fcc 	andi	r2,r2,127
    5da4:	1004943a 	slli	r2,r2,16
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 5]) << 40);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 6]) << 48);
    *timestamp |= ( ((uint64_t) buf[NIOS_PKT_RETUNE_IDX_TIME + 7]) << 56);

    *nint  = buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 0] << 1;
    *nint |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] >> 7;
    5da8:	1906b03a 	or	r3,r3,r4
    5dac:	d8c0008d 	sth	r3,2(sp)

    *nfrac  = (buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 1] & 0x7f) << 16;
    *nfrac |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 2] << 8;
    *nfrac |= buf[NIOS_PKT_RETUNE_IDX_INTFRAC + 3];
    5db0:	80c002c3 	ldbu	r3,11(r16)
    5db4:	1808923a 	slli	r4,r3,8
    5db8:	80c00303 	ldbu	r3,12(r16)
    5dbc:	20c6b03a 	or	r3,r4,r3
    5dc0:	1884b03a 	or	r2,r3,r2
    5dc4:	d8800115 	stw	r2,4(sp)

    *freqsel = buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & 0x3f;
    5dc8:	80800343 	ldbu	r2,13(r16)
    5dcc:	10c00fcc 	andi	r3,r2,63
    5dd0:	d8c00005 	stb	r3,0(sp)

    *module = -1;

    if (buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & FLAG_TX) {
    5dd4:	10c03fcc 	andi	r3,r2,255
    5dd8:	18c0201c 	xori	r3,r3,128
    5ddc:	18ffe004 	addi	r3,r3,-128
    5de0:	18000616 	blt	r3,zero,5dfc <pkt_retune+0xf0>
        *module = BLADERF_MODULE_TX;
    } else if (buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & FLAG_RX) {
    5de4:	14803fcc 	andi	r18,r2,255
    5de8:	9024d1ba 	srli	r18,r18,6
    5dec:	9480005c 	xori	r18,r18,1
    5df0:	9480004c 	andi	r18,r18,1
    5df4:	04a5c83a 	sub	r18,zero,r18
    5df8:	00000106 	br	5e00 <pkt_retune+0xf4>
    *freqsel = buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & 0x3f;

    *module = -1;

    if (buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & FLAG_TX) {
        *module = BLADERF_MODULE_TX;
    5dfc:	04800044 	movi	r18,1
    } else if (buf[NIOS_PKT_RETUNE_IDX_FREQSEL] & FLAG_RX) {
        *module = BLADERF_MODULE_RX;
    }

    *low_band = (buf[NIOS_PKT_RETUNE_IDX_BANDSEL] & FLAG_LOW_BAND) != 0;
    5e00:	81800383 	ldbu	r6,14(r16)
    *quick_tune = (buf[NIOS_PKT_RETUNE_IDX_BANDSEL] & FLAG_QUICK_TUNE) != 0;
    *vcocap = buf[NIOS_PKT_RETUNE_IDX_BANDSEL] & 0x3f;
    5e04:	30c00fcc 	andi	r3,r6,63
                           &f.nint, &f.nfrac, &f.freqsel, &f.vcocap,
                           &low_band, &quick_tune);

    f.vcocap_result = 0xff;

    if (low_band) {
    5e08:	35803fcc 	andi	r22,r6,255
    5e0c:	d8c00045 	stb	r3,1(sp)
    5e10:	b580201c 	xori	r22,r22,128

    nios_pkt_retune_unpack(b->req, &module, &timestamp,
                           &f.nint, &f.nfrac, &f.freqsel, &f.vcocap,
                           &low_band, &quick_tune);

    f.vcocap_result = 0xff;
    5e14:	00ffffc4 	movi	r3,-1
    5e18:	d8c00245 	stb	r3,9(sp)

    if (low_band) {
    5e1c:	b5bfe004 	addi	r22,r22,-128
    5e20:	3080100c 	andi	r2,r6,64
    5e24:	b000030e 	bge	r22,zero,5e34 <pkt_retune+0x128>
        f.flags = LMS_FREQ_FLAGS_LOW_BAND;
    5e28:	00c00044 	movi	r3,1
    5e2c:	d8c00205 	stb	r3,8(sp)
    5e30:	00000106 	br	5e38 <pkt_retune+0x12c>
    } else {
        f.flags = 0;
    5e34:	d8000205 	stb	zero,8(sp)
    }

    if (quick_tune) {
    5e38:	10000326 	beq	r2,zero,5e48 <pkt_retune+0x13c>
        f.flags |= LMS_FREQ_FLAGS_FORCE_VCOCAP;
    5e3c:	d8800203 	ldbu	r2,8(sp)
    5e40:	10800094 	ori	r2,r2,2
    5e44:	d8800205 	stb	r2,8(sp)
    }

    start_time = time_tamer_read(module);
    5e48:	9009883a 	mov	r4,r18
    5e4c:	0004c6c0 	call	4c6c <time_tamer_read>
    5e50:	1027883a 	mov	r19,r2

    if (timestamp == NIOS_PKT_RETUNE_NOW) {
    5e54:	ac44b03a 	or	r2,r21,r17

    if (quick_tune) {
        f.flags |= LMS_FREQ_FLAGS_FORCE_VCOCAP;
    }

    start_time = time_tamer_read(module);
    5e58:	1829883a 	mov	r20,r3

    if (timestamp == NIOS_PKT_RETUNE_NOW) {
    5e5c:	10000f1e 	bne	r2,zero,5e9c <pkt_retune+0x190>
        /* Fire off this retune operation now */
        switch (module) {
    5e60:	00800044 	movi	r2,1
    5e64:	14805e36 	bltu	r2,r18,5fe0 <pkt_retune+0x2d4>
            case BLADERF_MODULE_RX:
            case BLADERF_MODULE_TX:
                status = lms_set_precalculated_frequency(NULL, module, &f);
    5e68:	d80d883a 	mov	r6,sp
    5e6c:	900b883a 	mov	r5,r18
    5e70:	0009883a 	mov	r4,zero
    5e74:	000661c0 	call	661c <lms_set_precalculated_frequency>
                if (status != 0) {
    5e78:	1000881e 	bne	r2,zero,609c <pkt_retune+0x390>
                    goto out;
                }

                flags |= NIOS_PKT_RETUNERESP_FLAG_TSVTUNE_VALID;

                status = band_select(NULL, module, low_band);
    5e7c:	b00cd7fa 	srli	r6,r22,31
    5e80:	900b883a 	mov	r5,r18
    5e84:	0009883a 	mov	r4,zero
    5e88:	00060ac0 	call	60ac <band_select>
    5e8c:	1023883a 	mov	r17,r2
                status = lms_set_precalculated_frequency(NULL, module, &f);
                if (status != 0) {
                    goto out;
                }

                flags |= NIOS_PKT_RETUNERESP_FLAG_TSVTUNE_VALID;
    5e90:	054000c4 	movi	r21,3

                status = band_select(NULL, module, low_band);
                if (status != 0) {
    5e94:	1000821e 	bne	r2,zero,60a0 <pkt_retune+0x394>
    5e98:	00005306 	br	5fe8 <pkt_retune+0x2dc>
            default:
                INCREMENT_ERROR_COUNT();
                status = -1;
        }

    } else if (timestamp == NIOS_PKT_RETUNE_CLEAR_QUEUE) {
    5e9c:	00bfffc4 	movi	r2,-1
    5ea0:	a8800d1e 	bne	r21,r2,5ed8 <pkt_retune+0x1cc>
    5ea4:	8d400c1e 	bne	r17,r21,5ed8 <pkt_retune+0x1cc>
        switch (module) {
    5ea8:	90000526 	beq	r18,zero,5ec0 <pkt_retune+0x1b4>
    5eac:	00800044 	movi	r2,1
    5eb0:	9080491e 	bne	r18,r2,5fd8 <pkt_retune+0x2cc>
                reset_queue(&rx_queue);
                status = 0;
                break;

            case BLADERF_MODULE_TX:
                reset_queue(&tx_queue);
    5eb4:	01000034 	movhi	r4,0
    5eb8:	211c5f04 	addi	r4,r4,29052
    5ebc:	00000206 	br	5ec8 <pkt_retune+0x1bc>
        }

    } else if (timestamp == NIOS_PKT_RETUNE_CLEAR_QUEUE) {
        switch (module) {
            case BLADERF_MODULE_RX:
                reset_queue(&rx_queue);
    5ec0:	01000034 	movhi	r4,0
    5ec4:	211cc004 	addi	r4,r4,29440
                status = 0;
                break;

            case BLADERF_MODULE_TX:
                reset_queue(&tx_queue);
    5ec8:	0005a280 	call	5a28 <reset_queue>
    uint64_t end_time;
    uint64_t duration = 0;
    bool low_band;
    bool quick_tune;

    flags = NIOS_PKT_RETUNERESP_FLAG_SUCCESS;
    5ecc:	05400084 	movi	r21,2
                status = 0;
                break;

            case BLADERF_MODULE_TX:
                reset_queue(&tx_queue);
                status = 0;
    5ed0:	0023883a 	mov	r17,zero
                break;
    5ed4:	00004406 	br	5fe8 <pkt_retune+0x2dc>
                status = -1;
        }
    } else {
        uint8_t queue_size;

        switch (module) {
    5ed8:	90000326 	beq	r18,zero,5ee8 <pkt_retune+0x1dc>
    5edc:	00800044 	movi	r2,1
    5ee0:	90801826 	beq	r18,r2,5f44 <pkt_retune+0x238>
    5ee4:	00003e06 	br	5fe0 <pkt_retune+0x2d4>
                                     const struct lms_freq *f,
                                     uint64_t timestamp)
{
    uint8_t ret;

    if (q->count >= RETUNE_QUEUE_MAX) {
    5ee8:	05800034 	movhi	r22,0
    5eec:	b59cc004 	addi	r22,r22,29440
    5ef0:	b0800003 	ldbu	r2,0(r22)
    5ef4:	00c003c4 	movi	r3,15
    5ef8:	18803936 	bltu	r3,r2,5fe0 <pkt_retune+0x2d4>
        return QUEUE_FULL;
    }

    memcpy(&q->entries[q->ins_idx].freq, f, sizeof(f[0]));
    5efc:	b1000043 	ldbu	r4,1(r22)
    5f00:	01400604 	movi	r5,24
    5f04:	0006c840 	call	6c84 <__mulsi3>
    5f08:	10800204 	addi	r2,r2,8
    5f0c:	01800304 	movi	r6,12
    5f10:	d80b883a 	mov	r5,sp
    5f14:	b089883a 	add	r4,r22,r2
    5f18:	0006cac0 	call	6cac <memcpy>

    q->entries[q->ins_idx].state = ENTRY_STATE_NEW;
    5f1c:	b5c00043 	ldbu	r23,1(r22)
    5f20:	01400604 	movi	r5,24
    5f24:	bf003fcc 	andi	fp,r23,255
    5f28:	e009883a 	mov	r4,fp
    5f2c:	0006c840 	call	6c84 <__mulsi3>
    5f30:	b085883a 	add	r2,r22,r2
    5f34:	10800104 	addi	r2,r2,4
    5f38:	00c00044 	movi	r3,1
    5f3c:	10c00015 	stw	r3,0(r2)
    5f40:	00001506 	br	5f98 <pkt_retune+0x28c>
                                     const struct lms_freq *f,
                                     uint64_t timestamp)
{
    uint8_t ret;

    if (q->count >= RETUNE_QUEUE_MAX) {
    5f44:	05800034 	movhi	r22,0
    5f48:	b59c5f04 	addi	r22,r22,29052
    5f4c:	b0800003 	ldbu	r2,0(r22)
    5f50:	00c003c4 	movi	r3,15
    5f54:	18802236 	bltu	r3,r2,5fe0 <pkt_retune+0x2d4>
        return QUEUE_FULL;
    }

    memcpy(&q->entries[q->ins_idx].freq, f, sizeof(f[0]));
    5f58:	b1000043 	ldbu	r4,1(r22)
    5f5c:	01400604 	movi	r5,24
    5f60:	0006c840 	call	6c84 <__mulsi3>
    5f64:	10800204 	addi	r2,r2,8
    5f68:	01800304 	movi	r6,12
    5f6c:	d80b883a 	mov	r5,sp
    5f70:	b089883a 	add	r4,r22,r2
    5f74:	0006cac0 	call	6cac <memcpy>

    q->entries[q->ins_idx].state = ENTRY_STATE_NEW;
    5f78:	b5c00043 	ldbu	r23,1(r22)
    5f7c:	01400604 	movi	r5,24
    5f80:	bf003fcc 	andi	fp,r23,255
    5f84:	e009883a 	mov	r4,fp
    5f88:	0006c840 	call	6c84 <__mulsi3>
    5f8c:	b085883a 	add	r2,r22,r2
    5f90:	10800104 	addi	r2,r2,4
    5f94:	14800015 	stw	r18,0(r2)
    q->entries[q->ins_idx].timestamp = timestamp;
    5f98:	01400604 	movi	r5,24
    5f9c:	e009883a 	mov	r4,fp
    5fa0:	0006c840 	call	6c84 <__mulsi3>
    5fa4:	b085883a 	add	r2,r22,r2
    5fa8:	10800504 	addi	r2,r2,20
    5fac:	14400115 	stw	r17,4(r2)
    5fb0:	15400015 	stw	r21,0(r2)

    q->ins_idx = (q->ins_idx + 1) & (RETUNE_QUEUE_MAX - 1);

    q->count++;
    5fb4:	b0800003 	ldbu	r2,0(r22)
    memcpy(&q->entries[q->ins_idx].freq, f, sizeof(f[0]));

    q->entries[q->ins_idx].state = ENTRY_STATE_NEW;
    q->entries[q->ins_idx].timestamp = timestamp;

    q->ins_idx = (q->ins_idx + 1) & (RETUNE_QUEUE_MAX - 1);
    5fb8:	bdc00044 	addi	r23,r23,1
    5fbc:	bdc003cc 	andi	r23,r23,15

    q->count++;
    5fc0:	10800044 	addi	r2,r2,1
                INCREMENT_ERROR_COUNT();
                queue_size = QUEUE_FULL;

        }

        if (queue_size == QUEUE_FULL) {
    5fc4:	14403fcc 	andi	r17,r2,255
    5fc8:	8c403fe0 	cmpeqi	r17,r17,255
    memcpy(&q->entries[q->ins_idx].freq, f, sizeof(f[0]));

    q->entries[q->ins_idx].state = ENTRY_STATE_NEW;
    q->entries[q->ins_idx].timestamp = timestamp;

    q->ins_idx = (q->ins_idx + 1) & (RETUNE_QUEUE_MAX - 1);
    5fcc:	b5c00045 	stb	r23,1(r22)

    q->count++;
    5fd0:	b0800005 	stb	r2,0(r22)
                INCREMENT_ERROR_COUNT();
                queue_size = QUEUE_FULL;

        }

        if (queue_size == QUEUE_FULL) {
    5fd4:	0463c83a 	sub	r17,zero,r17
    uint64_t end_time;
    uint64_t duration = 0;
    bool low_band;
    bool quick_tune;

    flags = NIOS_PKT_RETUNERESP_FLAG_SUCCESS;
    5fd8:	05400084 	movi	r21,2
    5fdc:	00000206 	br	5fe8 <pkt_retune+0x2dc>
    5fe0:	05400084 	movi	r21,2
                queue_size = QUEUE_FULL;

        }

        if (queue_size == QUEUE_FULL) {
            status = -1;
    5fe4:	047fffc4 	movi	r17,-1
        } else {
            status = 0;
        }
    }

    end_time = time_tamer_read(module);
    5fe8:	9009883a 	mov	r4,r18
    5fec:	0004c6c0 	call	4c6c <time_tamer_read>
    duration = end_time - start_time;
    5ff0:	14e7c83a 	sub	r19,r2,r19
    5ff4:	14c5803a 	cmpltu	r2,r2,r19
    5ff8:	1d07c83a 	sub	r3,r3,r20
    5ffc:	1887c83a 	sub	r3,r3,r2

out:
    if (status != 0) {
    6000:	88000226 	beq	r17,zero,600c <pkt_retune+0x300>
        flags &= ~(NIOS_PKT_RETUNERESP_FLAG_SUCCESS);
    6004:	00bfff44 	movi	r2,-3
    6008:	156a703a 	and	r21,r2,r21
static inline void nios_pkt_retune_resp_pack(uint8_t *buf,
                                             uint64_t duration,
                                             uint8_t vcocap,
                                             uint8_t flags)
{
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;
    600c:	00801504 	movi	r2,84
    6010:	80800405 	stb	r2,16(r16)

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    6014:	9804d23a 	srli	r2,r19,8
                                             uint8_t vcocap,
                                             uint8_t flags)
{
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    6018:	84c00445 	stb	r19,17(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    601c:	80c00545 	stb	r3,21(r16)
                                             uint8_t flags)
{
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    6020:	80800485 	stb	r2,18(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    6024:	9804d43a 	srli	r2,r19,16
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    6028:	9826d63a 	srli	r19,r19,24
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;

    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;

    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;
    602c:	85400685 	stb	r21,26(r16)
{
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    6030:	808004c5 	stb	r2,19(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    6034:	1804d23a 	srli	r2,r3,8
    buf[NIOS_PKT_RETUNERESP_IDX_MAGIC] = NIOS_PKT_RETUNE_MAGIC;

    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    6038:	84c00505 	stb	r19,20(r16)

    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;

    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;

    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 0] = 0x00;
    603c:	800006c5 	stb	zero,27(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 0] =  duration        & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    6040:	80800585 	stb	r2,22(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    6044:	1804d43a 	srli	r2,r3,16
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;
    6048:	1806d63a 	srli	r3,r3,24
    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;

    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;

    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 0] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 1] = 0x00;
    604c:	80000705 	stb	zero,28(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 1] = (duration >> 8)  & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    6050:	808005c5 	stb	r2,23(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;

    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;
    6054:	d8800243 	ldbu	r2,9(sp)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 2] = (duration >> 16) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 3] = (duration >> 24) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;
    6058:	80c00605 	stb	r3,24(r16)

    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;

    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 0] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 1] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 2] = 0x00;
    605c:	80000745 	stb	zero,29(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 4] = (duration >> 32) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 5] = (duration >> 40) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 6] = (duration >> 48) & 0xff;
    buf[NIOS_PKT_RETUNERESP_IDX_TIME + 7] = (duration >> 56) & 0xff;

    buf[NIOS_PKT_RETUNERESP_IDX_VCOCAP] = vcocap;
    6060:	80800645 	stb	r2,25(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_FLAGS] = flags;

    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 0] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 1] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 2] = 0x00;
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 3] = 0x00;
    6064:	80000785 	stb	zero,30(r16)
    buf[NIOS_PKT_RETUNERESP_IDX_RESV + 4] = 0x00;
    6068:	800007c5 	stb	zero,31(r16)
    }

    nios_pkt_retune_resp_pack(b->resp, duration, f.vcocap_result, flags);
}
    606c:	dfc00c17 	ldw	ra,48(sp)
    6070:	df000b17 	ldw	fp,44(sp)
    6074:	ddc00a17 	ldw	r23,40(sp)
    6078:	dd800917 	ldw	r22,36(sp)
    607c:	dd400817 	ldw	r21,32(sp)
    6080:	dd000717 	ldw	r20,28(sp)
    6084:	dcc00617 	ldw	r19,24(sp)
    6088:	dc800517 	ldw	r18,20(sp)
    608c:	dc400417 	ldw	r17,16(sp)
    6090:	dc000317 	ldw	r16,12(sp)
    6094:	dec00d04 	addi	sp,sp,52
    6098:	f800283a 	ret
    uint64_t end_time;
    uint64_t duration = 0;
    bool low_band;
    bool quick_tune;

    flags = NIOS_PKT_RETUNERESP_FLAG_SUCCESS;
    609c:	05400084 	movi	r21,2
                queue_size = QUEUE_FULL;

        }

        if (queue_size == QUEUE_FULL) {
            status = -1;
    60a0:	0027883a 	mov	r19,zero
    60a4:	0007883a 	mov	r3,zero
    60a8:	003fd606 	br	6004 <_gp+0xffff6eec>

000060ac <band_select>:
#include <stdint.h>
#include "band_select.h"
#include "lms.h"

int band_select(struct bladerf *dev, bladerf_module module, bool low_band)
{
    60ac:	defffd04 	addi	sp,sp,-12
    int status;
    uint32_t gpio;
    const uint32_t band = low_band ? 2 : 1;
    60b0:	31803fcc 	andi	r6,r6,255
#include <stdint.h>
#include "band_select.h"
#include "lms.h"

int band_select(struct bladerf *dev, bladerf_module module, bool low_band)
{
    60b4:	dc400115 	stw	r17,4(sp)
    60b8:	dc000015 	stw	r16,0(sp)
    60bc:	dfc00215 	stw	ra,8(sp)
    60c0:	2823883a 	mov	r17,r5
    int status;
    uint32_t gpio;
    const uint32_t band = low_band ? 2 : 1;
    60c4:	3020c03a 	cmpne	r16,r6,zero

    log_debug("Selecting %s band.\n", low_band ? "low" : "high");

    status = lms_select_band(dev, module, low_band);
    60c8:	00065840 	call	6584 <lms_select_band>
    if (status != 0) {
    60cc:	1000101e 	bne	r2,zero,6110 <band_select+0x64>
    60d0:	84000044 	addi	r16,r16,1
	return 0;
}

static inline uint32_t control_reg_read(void)
{
    return IORD_ALTERA_AVALON_PIO_DATA(CONTROL_BASE);
    60d4:	00e41014 	movui	r3,36928
    60d8:	18800037 	ldwio	r2,0(r3)
    status = CONFIG_GPIO_READ(dev, &gpio);
    if (status != 0) {
        return status;
    }

    gpio &= ~(module == BLADERF_MODULE_TX ? (3 << 3) : (3 << 5));
    60dc:	01000044 	movi	r4,1
    60e0:	89000226 	beq	r17,r4,60ec <band_select+0x40>
    60e4:	017fe7c4 	movi	r5,-97
    60e8:	00000106 	br	60f0 <band_select+0x44>
    60ec:	017ff9c4 	movi	r5,-25
    60f0:	2884703a 	and	r2,r5,r2
    gpio |= (module == BLADERF_MODULE_TX ? (band << 3) : (band << 5));
    60f4:	8900021e 	bne	r17,r4,6100 <band_select+0x54>
    60f8:	802090fa 	slli	r16,r16,3
    60fc:	00000106 	br	6104 <band_select+0x58>
    6100:	8020917a 	slli	r16,r16,5
}

static inline void control_reg_write(uint32_t value)
{
    IOWR_ALTERA_AVALON_PIO_DATA(CONTROL_BASE, value);
    6104:	80a0b03a 	or	r16,r16,r2
    6108:	1c000035 	stwio	r16,0(r3)

    return CONFIG_GPIO_WRITE(dev, gpio);
    610c:	0005883a 	mov	r2,zero
}
    6110:	dfc00217 	ldw	ra,8(sp)
    6114:	dc400117 	ldw	r17,4(sp)
    6118:	dc000017 	ldw	r16,0(sp)
    611c:	dec00304 	addi	sp,sp,12
    6120:	f800283a 	ret

00006124 <vtune_low_to_norm>:
}

static int vtune_low_to_norm(struct bladerf *dev, uint8_t base,
                                    uint8_t vcocap, uint8_t vcocap_reg_state,
                                    uint8_t *vtune_low_limit)
{
    6124:	defff804 	addi	sp,sp,-32
    6128:	dcc00315 	stw	r19,12(sp)
    612c:	dcc00817 	ldw	r19,32(sp)
    6130:	dd400515 	stw	r21,20(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6134:	2d400244 	addi	r21,r5,9

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6138:	29400284 	addi	r5,r5,10
}

static int vtune_low_to_norm(struct bladerf *dev, uint8_t base,
                                    uint8_t vcocap, uint8_t vcocap_reg_state,
                                    uint8_t *vtune_low_limit)
{
    613c:	dd800615 	stw	r22,24(sp)
    6140:	dc800215 	stw	r18,8(sp)
    6144:	dc400115 	stw	r17,4(sp)
    6148:	dc000015 	stw	r16,0(sp)
    614c:	dfc00715 	stw	ra,28(sp)
    6150:	dd000415 	stw	r20,16(sp)
    6154:	3023883a 	mov	r17,r6
    6158:	382d883a 	mov	r22,r7
    615c:	343ffb04 	addi	r16,r6,-20
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6160:	ad403fcc 	andi	r21,r21,255

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6164:	2c803fcc 	andi	r18,r5,255
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {

        if (vcocap == 0) {
    6168:	88803fcc 	andi	r2,r17,255
    616c:	1000021e 	bne	r2,zero,6178 <vtune_low_to_norm+0x54>
            *vtune_low_limit = 0;
    6170:	98000005 	stb	zero,0(r19)
            log_warning("VCOCAP hit min value.\n");
            return 0;
    6174:	00001406 	br	61c8 <vtune_low_to_norm+0xa4>
        }

        vcocap--;
    6178:	8d3fffc4 	addi	r20,r17,-1
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    617c:	a58ab03a 	or	r5,r20,r22
    6180:	29403fcc 	andi	r5,r5,255
    6184:	a809883a 	mov	r4,r21
    6188:	00048940 	call	4894 <lms6_write>
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    618c:	01000644 	movi	r4,25
    6190:	0006ef40 	call	6ef4 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    6194:	9009883a 	mov	r4,r18
    6198:	00048540 	call	4854 <lms6_read>
        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == VCO_NORM) {
    619c:	10803fcc 	andi	r2,r2,255
    61a0:	1004d1ba 	srli	r2,r2,6
    61a4:	1000021e 	bne	r2,zero,61b0 <vtune_low_to_norm+0x8c>
            *vtune_low_limit = vcocap + 1;
    61a8:	9c400005 	stb	r17,0(r19)
            log_verbose("VTUNE NORM @ VCOCAP=%u\n", vcocap);
            log_verbose("VTUNE LOW @ VCOCAP=%u\n", *vtune_low_limit);
            return 0;
    61ac:	00000606 	br	61c8 <vtune_low_to_norm+0xa4>
{
    int status;
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {
    61b0:	a0803fcc 	andi	r2,r20,255
    61b4:	80c03fcc 	andi	r3,r16,255
    61b8:	10c00226 	beq	r2,r3,61c4 <vtune_low_to_norm+0xa0>
    61bc:	a023883a 	mov	r17,r20
    61c0:	003fe906 	br	6168 <_gp+0xffff7050>
            return 0;
        }
    }

    log_error("VTUNE Low->Norm loop failed to converge.\n");
    return BLADERF_ERR_UNEXPECTED;
    61c4:	00bfffc4 	movi	r2,-1
}
    61c8:	dfc00717 	ldw	ra,28(sp)
    61cc:	dd800617 	ldw	r22,24(sp)
    61d0:	dd400517 	ldw	r21,20(sp)
    61d4:	dd000417 	ldw	r20,16(sp)
    61d8:	dcc00317 	ldw	r19,12(sp)
    61dc:	dc800217 	ldw	r18,8(sp)
    61e0:	dc400117 	ldw	r17,4(sp)
    61e4:	dc000017 	ldw	r16,0(sp)
    61e8:	dec00804 	addi	sp,sp,32
    61ec:	f800283a 	ret

000061f0 <vtune_high_to_norm>:
#endif

static int vtune_high_to_norm(struct bladerf *dev, uint8_t base,
                                     uint8_t vcocap, uint8_t vcocap_reg_state,
                                     uint8_t *vtune_high_limit)
{
    61f0:	defff804 	addi	sp,sp,-32
    61f4:	dcc00315 	stw	r19,12(sp)
    61f8:	dcc00817 	ldw	r19,32(sp)
    61fc:	dd400515 	stw	r21,20(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6200:	2d400244 	addi	r21,r5,9

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6204:	29400284 	addi	r5,r5,10
#endif

static int vtune_high_to_norm(struct bladerf *dev, uint8_t base,
                                     uint8_t vcocap, uint8_t vcocap_reg_state,
                                     uint8_t *vtune_high_limit)
{
    6208:	dd800615 	stw	r22,24(sp)
    620c:	dc800215 	stw	r18,8(sp)
    6210:	dc400115 	stw	r17,4(sp)
    6214:	dc000015 	stw	r16,0(sp)
    6218:	dfc00715 	stw	ra,28(sp)
    621c:	dd000415 	stw	r20,16(sp)
    6220:	3023883a 	mov	r17,r6
    6224:	382d883a 	mov	r22,r7
    6228:	34000504 	addi	r16,r6,20
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    622c:	ad403fcc 	andi	r21,r21,255

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6230:	2c803fcc 	andi	r18,r5,255
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {

        if (vcocap >= VCOCAP_MAX_VALUE) {
    6234:	88803fcc 	andi	r2,r17,255
    6238:	00c00f84 	movi	r3,62
    623c:	1880042e 	bgeu	r3,r2,6250 <vtune_high_to_norm+0x60>
            *vtune_high_limit = VCOCAP_MAX_VALUE;
    6240:	00800fc4 	movi	r2,63
    6244:	98800005 	stb	r2,0(r19)
            log_warning("%s: VCOCAP hit max value.\n", __FUNCTION__);
            return 0;
    6248:	0005883a 	mov	r2,zero
    624c:	00001406 	br	62a0 <vtune_high_to_norm+0xb0>
        }

        vcocap++;
    6250:	8d000044 	addi	r20,r17,1
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6254:	a58ab03a 	or	r5,r20,r22
    6258:	29403fcc 	andi	r5,r5,255
    625c:	a809883a 	mov	r4,r21
    6260:	00048940 	call	4894 <lms6_write>
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    6264:	01000644 	movi	r4,25
    6268:	0006ef40 	call	6ef4 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    626c:	9009883a 	mov	r4,r18
    6270:	00048540 	call	4854 <lms6_read>
        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == VCO_NORM) {
    6274:	10803fcc 	andi	r2,r2,255
    6278:	1004d1ba 	srli	r2,r2,6
    627c:	1000021e 	bne	r2,zero,6288 <vtune_high_to_norm+0x98>
            *vtune_high_limit = vcocap - 1;
    6280:	9c400005 	stb	r17,0(r19)
            log_verbose("VTUNE NORM @ VCOCAP=%u\n", vcocap);
            log_verbose("VTUNE HIGH @ VCOCAP=%u\n", *vtune_high_limit);
            return 0;
    6284:	00000606 	br	62a0 <vtune_high_to_norm+0xb0>
{
    int status;
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {
    6288:	a0803fcc 	andi	r2,r20,255
    628c:	80c03fcc 	andi	r3,r16,255
    6290:	10c00226 	beq	r2,r3,629c <vtune_high_to_norm+0xac>
    6294:	a023883a 	mov	r17,r20
    6298:	003fe606 	br	6234 <_gp+0xffff711c>
            return 0;
        }
    }

    log_error("VTUNE High->Norm loop failed to converge.\n");
    return BLADERF_ERR_UNEXPECTED;
    629c:	00bfffc4 	movi	r2,-1
}
    62a0:	dfc00717 	ldw	ra,28(sp)
    62a4:	dd800617 	ldw	r22,24(sp)
    62a8:	dd400517 	ldw	r21,20(sp)
    62ac:	dd000417 	ldw	r20,16(sp)
    62b0:	dcc00317 	ldw	r19,12(sp)
    62b4:	dc800217 	ldw	r18,8(sp)
    62b8:	dc400117 	ldw	r17,4(sp)
    62bc:	dc000017 	ldw	r16,0(sp)
    62c0:	dec00804 	addi	sp,sp,32
    62c4:	f800283a 	ret

000062c8 <wait_for_vtune_value>:

/* Wait for VTUNE to reach HIGH or LOW. NORM is not a valid option here */
static int wait_for_vtune_value(struct bladerf *dev,
                                uint8_t base, uint8_t target_value,
                                uint8_t *vcocap, uint8_t vcocap_reg_state)
{
    62c8:	defff704 	addi	sp,sp,-36
    62cc:	dd400515 	stw	r21,20(sp)
    62d0:	dcc00315 	stw	r19,12(sp)
    62d4:	dc800215 	stw	r18,8(sp)
    62d8:	dc000015 	stw	r16,0(sp)
    62dc:	3025883a 	mov	r18,r6
    62e0:	dfc00815 	stw	ra,32(sp)
    62e4:	ddc00715 	stw	r23,28(sp)
    62e8:	dd800615 	stw	r22,24(sp)
    62ec:	dd000415 	stw	r20,16(sp)
    62f0:	dc400115 	stw	r17,4(sp)
    uint8_t vtune;
    unsigned int i;
    int status = 0;
    const unsigned int max_retries = 15;
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    62f4:	31803fcc 	andi	r6,r6,255
    62f8:	00800084 	movi	r2,2

/* Wait for VTUNE to reach HIGH or LOW. NORM is not a valid option here */
static int wait_for_vtune_value(struct bladerf *dev,
                                uint8_t base, uint8_t target_value,
                                uint8_t *vcocap, uint8_t vcocap_reg_state)
{
    62fc:	3827883a 	mov	r19,r7
    6300:	2821883a 	mov	r16,r5
    6304:	dd400903 	ldbu	r21,36(sp)
    uint8_t vtune;
    unsigned int i;
    int status = 0;
    const unsigned int max_retries = 15;
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    6308:	3080031e 	bne	r6,r2,6318 <wait_for_vtune_value+0x50>
    630c:	002d883a 	mov	r22,zero
    int8_t inc = (target_value == VCO_HIGH) ? -1 : 1;
    6310:	053fffc4 	movi	r20,-1
    6314:	00000206 	br	6320 <wait_for_vtune_value+0x58>
{
    uint8_t vtune;
    unsigned int i;
    int status = 0;
    const unsigned int max_retries = 15;
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    6318:	05800fc4 	movi	r22,63
    int8_t inc = (target_value == VCO_HIGH) ? -1 : 1;
    631c:	05000044 	movi	r20,1

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6320:	84400284 	addi	r17,r16,10
    uint8_t vtune;
    unsigned int i;
    int status = 0;
    const unsigned int max_retries = 15;
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    int8_t inc = (target_value == VCO_HIGH) ? -1 : 1;
    6324:	05c003c4 	movi	r23,15

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6328:	8c403fcc 	andi	r17,r17,255
        status = get_vtune(dev, base, 0, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == target_value) {
    632c:	94803fcc 	andi	r18,r18,255

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    6330:	8809883a 	mov	r4,r17
    6334:	00048540 	call	4854 <lms6_read>
        status = get_vtune(dev, base, 0, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == target_value) {
    6338:	10803fcc 	andi	r2,r2,255
    633c:	1004d1ba 	srli	r2,r2,6
    6340:	90801726 	beq	r18,r2,63a0 <wait_for_vtune_value+0xd8>
            return 0;
        } else {
            log_verbose("VTUNE was %s. Waiting and retrying...\n",
                        vtune_str(vtune));

            VTUNE_BUSY_WAIT(10);
    6344:	01000284 	movi	r4,10
    6348:	bdffffc4 	addi	r23,r23,-1
    634c:	0006ef40 	call	6ef4 <usleep>
    const uint8_t limit = (target_value == VCO_HIGH) ? 0 : VCOCAP_MAX_VALUE;
    int8_t inc = (target_value == VCO_HIGH) ? -1 : 1;

    assert(target_value == VCO_HIGH || target_value == VCO_LOW);

    for (i = 0; i < max_retries; i++) {
    6350:	b83ff71e 	bne	r23,zero,6330 <_gp+0xffff7218>
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6354:	84000244 	addi	r16,r16,9
    }

    log_debug("Timed out while waiting for VTUNE=%s. Walking VCOCAP...\n",
               vtune_str(target_value));

    while (*vcocap != limit) {
    6358:	b5803fcc 	andi	r22,r22,255
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    635c:	84003fcc 	andi	r16,r16,255
    }

    log_debug("Timed out while waiting for VTUNE=%s. Walking VCOCAP...\n",
               vtune_str(target_value));

    while (*vcocap != limit) {
    6360:	99400003 	ldbu	r5,0(r19)
    6364:	28803fcc 	andi	r2,r5,255
    6368:	15800d26 	beq	r2,r22,63a0 <wait_for_vtune_value+0xd8>
        *vcocap += inc;
    636c:	a14b883a 	add	r5,r20,r5
    6370:	99400005 	stb	r5,0(r19)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6374:	2d4ab03a 	or	r5,r5,r21
    6378:	29403fcc 	andi	r5,r5,255
    637c:	8009883a 	mov	r4,r16
    6380:	00048940 	call	4894 <lms6_write>
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    6384:	01000644 	movi	r4,25
    6388:	0006ef40 	call	6ef4 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    638c:	8809883a 	mov	r4,r17
    6390:	00048540 	call	4854 <lms6_read>
        }

        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        } else if (vtune == target_value) {
    6394:	10803fcc 	andi	r2,r2,255
    6398:	1004d1ba 	srli	r2,r2,6
    639c:	90bff01e 	bne	r18,r2,6360 <_gp+0xffff7248>
#   ifdef ERROR_ON_NO_VTUNE_LIMIT
        return BLADERF_ERR_UNEXPECTED;
#   else
        return 0;
#   endif
}
    63a0:	0005883a 	mov	r2,zero
    63a4:	dfc00817 	ldw	ra,32(sp)
    63a8:	ddc00717 	ldw	r23,28(sp)
    63ac:	dd800617 	ldw	r22,24(sp)
    63b0:	dd400517 	ldw	r21,20(sp)
    63b4:	dd000417 	ldw	r20,16(sp)
    63b8:	dcc00317 	ldw	r19,12(sp)
    63bc:	dc800217 	ldw	r18,8(sp)
    63c0:	dc400117 	ldw	r17,4(sp)
    63c4:	dc000017 	ldw	r16,0(sp)
    63c8:	dec00904 	addi	sp,sp,36
    63cc:	f800283a 	ret

000063d0 <lms_select_lna>:
}
#endif

/* Select which LNA to enable */
int lms_select_lna(struct bladerf *dev, lms_lna lna)
{
    63d0:	defffd04 	addi	sp,sp,-12
    63d4:	dc400115 	stw	r17,4(sp)
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x75, &data);
    63d8:	04401d44 	movi	r17,117
}
#endif

/* Select which LNA to enable */
int lms_select_lna(struct bladerf *dev, lms_lna lna)
{
    63dc:	dc000015 	stw	r16,0(sp)
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x75, &data);
    63e0:	8809883a 	mov	r4,r17
}
#endif

/* Select which LNA to enable */
int lms_select_lna(struct bladerf *dev, lms_lna lna)
{
    63e4:	2821883a 	mov	r16,r5
    63e8:	dfc00215 	stw	ra,8(sp)
    }

    data &= ~(3 << 4);
    data |= ((lna & 3) << 4);

    return LMS_WRITE(dev, 0x75, data);
    63ec:	840000cc 	andi	r16,r16,3
int lms_select_lna(struct bladerf *dev, lms_lna lna)
{
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x75, &data);
    63f0:	00048540 	call	4854 <lms6_read>
    }

    data &= ~(3 << 4);
    data |= ((lna & 3) << 4);

    return LMS_WRITE(dev, 0x75, data);
    63f4:	800a913a 	slli	r5,r16,4
    63f8:	108033cc 	andi	r2,r2,207
    63fc:	8809883a 	mov	r4,r17
    6400:	114ab03a 	or	r5,r2,r5
    6404:	00048940 	call	4894 <lms6_write>
}
    6408:	0005883a 	mov	r2,zero
    640c:	dfc00217 	ldw	ra,8(sp)
    6410:	dc400117 	ldw	r17,4(sp)
    6414:	dc000017 	ldw	r16,0(sp)
    6418:	dec00304 	addi	sp,sp,12
    641c:	f800283a 	ret

00006420 <lms_select_pa>:
    return status;
}
#endif

int lms_select_pa(struct bladerf *dev, lms_pa pa)
{
    6420:	defffe04 	addi	sp,sp,-8
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x44, &data);
    6424:	01001104 	movi	r4,68
    return status;
}
#endif

int lms_select_pa(struct bladerf *dev, lms_pa pa)
{
    6428:	dc000015 	stw	r16,0(sp)
    642c:	dfc00115 	stw	ra,4(sp)
    6430:	2821883a 	mov	r16,r5
    int status;
    uint8_t data;

    status = LMS_READ(dev, 0x44, &data);
    6434:	00048540 	call	4854 <lms6_read>

    /* Disable PA1, PA2, and AUX PA - we'll enable as requested below. */
    data &= ~0x1C;
    6438:	00fff8c4 	movi	r3,-29

    /* AUX PA powered down */
    data |= (1 << 1);

    switch (pa) {
    643c:	01000044 	movi	r4,1
    uint8_t data;

    status = LMS_READ(dev, 0x44, &data);

    /* Disable PA1, PA2, and AUX PA - we'll enable as requested below. */
    data &= ~0x1C;
    6440:	10c6703a 	and	r3,r2,r3

    /* AUX PA powered down */
    data |= (1 << 1);

    switch (pa) {
    6444:	81000a26 	beq	r16,r4,6470 <lms_select_pa+0x50>
    6448:	80000626 	beq	r16,zero,6464 <lms_select_pa+0x44>
    644c:	00800084 	movi	r2,2
    6450:	80800926 	beq	r16,r2,6478 <lms_select_pa+0x58>
    6454:	008000c4 	movi	r2,3
    6458:	80800926 	beq	r16,r2,6480 <lms_select_pa+0x60>
        case PA_NONE:
            break;

        default:
            assert(!"Invalid PA selection");
            status = BLADERF_ERR_INVAL;
    645c:	00bfff44 	movi	r2,-3
    6460:	00000c06 	br	6494 <lms_select_pa+0x74>
    6464:	00fff844 	movi	r3,-31
    6468:	188a703a 	and	r5,r3,r2
    data |= (1 << 1);

    switch (pa) {
        case PA_AUX:
            data &= ~(1 << 1);  /* Power up the AUX PA */
            break;
    646c:	00000506 	br	6484 <lms_select_pa+0x64>

        case PA_1:
            data |= (2 << 2);   /* PA_EN[2:0] = 010 - Enable PA1 */
    6470:	19400294 	ori	r5,r3,10
            break;
    6474:	00000306 	br	6484 <lms_select_pa+0x64>

        case PA_2:
            data |= (4 << 2);   /* PA_EN[2:0] = 100 - Enable PA2 */
    6478:	19400494 	ori	r5,r3,18
            break;
    647c:	00000106 	br	6484 <lms_select_pa+0x64>

    /* Disable PA1, PA2, and AUX PA - we'll enable as requested below. */
    data &= ~0x1C;

    /* AUX PA powered down */
    data |= (1 << 1);
    6480:	19400094 	ori	r5,r3,2
            assert(!"Invalid PA selection");
            status = BLADERF_ERR_INVAL;
    }

    if (status == 0) {
        status = LMS_WRITE(dev, 0x44, data);
    6484:	29403fcc 	andi	r5,r5,255
    6488:	01001104 	movi	r4,68
    648c:	00048940 	call	4894 <lms6_write>
    6490:	0005883a 	mov	r2,zero
    }

    return status;

};
    6494:	dfc00117 	ldw	ra,4(sp)
    6498:	dc000017 	ldw	r16,0(sp)
    649c:	dec00204 	addi	sp,sp,8
    64a0:	f800283a 	ret

000064a4 <lms_get_loopback_mode>:
    return 0;
}
#endif

int lms_get_loopback_mode(struct bladerf *dev, bladerf_loopback *loopback)
{
    64a4:	defffc04 	addi	sp,sp,-16
    64a8:	dc800215 	stw	r18,8(sp)
    int status;
    uint8_t lben_lbrfen, loopbben;


    status = LMS_READ(dev, 0x08, &lben_lbrfen);
    64ac:	04800204 	movi	r18,8
    64b0:	9009883a 	mov	r4,r18
    return 0;
}
#endif

int lms_get_loopback_mode(struct bladerf *dev, bladerf_loopback *loopback)
{
    64b4:	dfc00315 	stw	ra,12(sp)
    64b8:	dc400115 	stw	r17,4(sp)
    64bc:	dc000015 	stw	r16,0(sp)
    64c0:	2821883a 	mov	r16,r5
    int status;
    uint8_t lben_lbrfen, loopbben;


    status = LMS_READ(dev, 0x08, &lben_lbrfen);
    64c4:	00048540 	call	4854 <lms6_read>
    if (status != 0) {
        return status;
    }

    status = LMS_READ(dev, 0x46, &loopbben);
    64c8:	01001184 	movi	r4,70
{
    int status;
    uint8_t lben_lbrfen, loopbben;


    status = LMS_READ(dev, 0x08, &lben_lbrfen);
    64cc:	1023883a 	mov	r17,r2
    if (status != 0) {
        return status;
    }

    status = LMS_READ(dev, 0x46, &loopbben);
    64d0:	00048540 	call	4854 <lms6_read>
    if (status != 0) {
        return status;
    }

    switch (lben_lbrfen & 0x7) {
    64d4:	88c001cc 	andi	r3,r17,7
    64d8:	01400084 	movi	r5,2
    64dc:	19400626 	beq	r3,r5,64f8 <lms_get_loopback_mode+0x54>
    64e0:	010000c4 	movi	r4,3
    64e4:	19000626 	beq	r3,r4,6500 <lms_get_loopback_mode+0x5c>
    64e8:	01800044 	movi	r6,1
    64ec:	1980061e 	bne	r3,r6,6508 <lms_get_loopback_mode+0x64>
        case LBRFEN_LNA1:
            *loopback = BLADERF_LB_RF_LNA1;
    64f0:	00800184 	movi	r2,6
    64f4:	00001b06 	br	6564 <lms_get_loopback_mode+0xc0>
            return 0;

        case LBRFEN_LNA2:
            *loopback = BLADERF_LB_RF_LNA2;
    64f8:	008001c4 	movi	r2,7
    64fc:	00001906 	br	6564 <lms_get_loopback_mode+0xc0>
            return 0;

        case LBRFEN_LNA3:
            *loopback = BLADERF_LB_RF_LNA3;
    6500:	84800015 	stw	r18,0(r16)
            return 0;
    6504:	00001806 	br	6568 <lms_get_loopback_mode+0xc4>

        default:
            break;
    }

    switch (lben_lbrfen & LBEN_MASK) {
    6508:	8c401c0c 	andi	r17,r17,112
    650c:	00c00804 	movi	r3,32
    6510:	88c00326 	beq	r17,r3,6520 <lms_get_loopback_mode+0x7c>
    6514:	00c01004 	movi	r3,64
    6518:	88c00926 	beq	r17,r3,6540 <lms_get_loopback_mode+0x9c>
    651c:	00001006 	br	6560 <lms_get_loopback_mode+0xbc>
        case LBEN_VGA2IN:
            if (loopbben & LOOPBBEN_TXLPF) {
    6520:	10c0010c 	andi	r3,r2,4
    6524:	18000226 	beq	r3,zero,6530 <lms_get_loopback_mode+0x8c>
                *loopback = BLADERF_LB_BB_TXLPF_RXVGA2;
    6528:	81400015 	stw	r5,0(r16)
                return 0;
    652c:	00000e06 	br	6568 <lms_get_loopback_mode+0xc4>
            } else if (loopbben & LOOPBBEN_TXVGA) {
    6530:	1080020c 	andi	r2,r2,8
    6534:	10000a26 	beq	r2,zero,6560 <lms_get_loopback_mode+0xbc>
                *loopback = BLADERF_LB_BB_TXVGA1_RXVGA2;
    6538:	81000015 	stw	r4,0(r16)
                return 0;
    653c:	00000a06 	br	6568 <lms_get_loopback_mode+0xc4>
            }
            break;

        case LBEN_LPFIN:
            if (loopbben & LOOPBBEN_TXLPF) {
    6540:	10c0010c 	andi	r3,r2,4
    6544:	18000226 	beq	r3,zero,6550 <lms_get_loopback_mode+0xac>
                *loopback = BLADERF_LB_BB_TXLPF_RXLPF;
    6548:	00800104 	movi	r2,4
    654c:	00000506 	br	6564 <lms_get_loopback_mode+0xc0>
                return 0;
            } else if (loopbben & LOOPBBEN_TXVGA) {
    6550:	1080020c 	andi	r2,r2,8
    6554:	10000226 	beq	r2,zero,6560 <lms_get_loopback_mode+0xbc>
                *loopback = BLADERF_LB_BB_TXVGA1_RXLPF;
    6558:	00800144 	movi	r2,5
    655c:	00000106 	br	6564 <lms_get_loopback_mode+0xc0>

        default:
            break;
    }

    *loopback = BLADERF_LB_NONE;
    6560:	00800244 	movi	r2,9
    6564:	80800015 	stw	r2,0(r16)
    return 0;
}
    6568:	0005883a 	mov	r2,zero
    656c:	dfc00317 	ldw	ra,12(sp)
    6570:	dc800217 	ldw	r18,8(sp)
    6574:	dc400117 	ldw	r17,4(sp)
    6578:	dc000017 	ldw	r16,0(sp)
    657c:	dec00404 	addi	sp,sp,16
    6580:	f800283a 	ret

00006584 <lms_select_band>:

    return status;
}

int lms_select_band(struct bladerf *dev, bladerf_module module, bool low_band)
{
    6584:	defffb04 	addi	sp,sp,-20
    6588:	dc400215 	stw	r17,8(sp)
    658c:	2823883a 	mov	r17,r5
static inline int is_loopback_enabled(struct bladerf *dev)
{
    bladerf_loopback loopback;
    int status;

    status = lms_get_loopback_mode(dev, &loopback);
    6590:	d80b883a 	mov	r5,sp

    return status;
}

int lms_select_band(struct bladerf *dev, bladerf_module module, bool low_band)
{
    6594:	dc800315 	stw	r18,12(sp)
    6598:	dc000115 	stw	r16,4(sp)
    659c:	dfc00415 	stw	ra,16(sp)
    65a0:	2025883a 	mov	r18,r4
    65a4:	3021883a 	mov	r16,r6
static inline int is_loopback_enabled(struct bladerf *dev)
{
    bladerf_loopback loopback;
    int status;

    status = lms_get_loopback_mode(dev, &loopback);
    65a8:	00064a40 	call	64a4 <lms_get_loopback_mode>
    if (status != 0) {
    65ac:	1000021e 	bne	r2,zero,65b8 <lms_select_band+0x34>
        return status;
    }

    return loopback != BLADERF_LB_NONE;
    65b0:	d8800017 	ldw	r2,0(sp)
    65b4:	10800258 	cmpnei	r2,r2,9
    int status;

    /* If loopback mode disabled, avoid changing the PA or LNA selection,
     * as these need to remain are powered down or disabled */
    status = is_loopback_enabled(dev);
    if (status < 0) {
    65b8:	10001216 	blt	r2,zero,6604 <lms_select_band+0x80>
        return status;
    } else if (status > 0) {
    65bc:	1000101e 	bne	r2,zero,6600 <lms_select_band+0x7c>
        return 0;
    }

    if (module == BLADERF_MODULE_TX) {
    65c0:	00800044 	movi	r2,1
    65c4:	81803fcc 	andi	r6,r16,255
    65c8:	8880071e 	bne	r17,r2,65e8 <lms_select_band+0x64>
        lms_pa pa = low_band ? PA_1 : PA_2;
    65cc:	3000021e 	bne	r6,zero,65d8 <lms_select_band+0x54>
    65d0:	01400084 	movi	r5,2
    65d4:	00000106 	br	65dc <lms_select_band+0x58>
    65d8:	880b883a 	mov	r5,r17
        status = lms_select_pa(dev, pa);
    65dc:	9009883a 	mov	r4,r18
    65e0:	00064200 	call	6420 <lms_select_pa>
    65e4:	00000706 	br	6604 <lms_select_band+0x80>
    } else {
        lms_lna lna = low_band ? LNA_1 : LNA_2;
    65e8:	300cc03a 	cmpne	r6,r6,zero
        status = lms_select_lna(dev, lna);
    65ec:	01400084 	movi	r5,2
    65f0:	298bc83a 	sub	r5,r5,r6
    65f4:	9009883a 	mov	r4,r18
    65f8:	00063d00 	call	63d0 <lms_select_lna>
    65fc:	00000106 	br	6604 <lms_select_band+0x80>
     * as these need to remain are powered down or disabled */
    status = is_loopback_enabled(dev);
    if (status < 0) {
        return status;
    } else if (status > 0) {
        return 0;
    6600:	0005883a 	mov	r2,zero
        lms_lna lna = low_band ? LNA_1 : LNA_2;
        status = lms_select_lna(dev, lna);
    }

    return status;
}
    6604:	dfc00417 	ldw	ra,16(sp)
    6608:	dc800317 	ldw	r18,12(sp)
    660c:	dc400217 	ldw	r17,8(sp)
    6610:	dc000117 	ldw	r16,4(sp)
    6614:	dec00504 	addi	sp,sp,20
    6618:	f800283a 	ret

0000661c <lms_set_precalculated_frequency>:
}
#endif

int lms_set_precalculated_frequency(struct bladerf *dev, bladerf_module mod,
                                    struct lms_freq *f)
{
    661c:	defff004 	addi	sp,sp,-64
    6620:	dd800c15 	stw	r22,48(sp)
    6624:	dc400715 	stw	r17,28(sp)
    6628:	dc000615 	stw	r16,24(sp)
    662c:	dfc00f15 	stw	ra,60(sp)
    6630:	df000e15 	stw	fp,56(sp)
    6634:	ddc00d15 	stw	r23,52(sp)
    6638:	dd400b15 	stw	r21,44(sp)
    663c:	dd000a15 	stw	r20,40(sp)
    6640:	dcc00915 	stw	r19,36(sp)
    6644:	dc800815 	stw	r18,32(sp)
    6648:	202d883a 	mov	r22,r4
    664c:	2821883a 	mov	r16,r5
    6650:	3023883a 	mov	r17,r6
    /* Select the base address based on which PLL we are configuring */
    const uint8_t base = (mod == BLADERF_MODULE_RX) ? 0x20 : 0x10;
    6654:	28000226 	beq	r5,zero,6660 <lms_set_precalculated_frequency+0x44>
    6658:	04800404 	movi	r18,16
    665c:	00000106 	br	6664 <lms_set_precalculated_frequency+0x48>
    6660:	04800804 	movi	r18,32
    const uint8_t pll_base =
        have_cap(dev, BLADERF_CAP_ATOMIC_NINT_NFRAC_WRITE) ?
            (base | 0x80) : base;
#   endif

    f->vcocap_result = 0xff;
    6664:	00bfffc4 	movi	r2,-1

    /* Turn on the DSMs */
    status = LMS_READ(dev, 0x09, &data);
    6668:	01000244 	movi	r4,9
    const uint8_t pll_base =
        have_cap(dev, BLADERF_CAP_ATOMIC_NINT_NFRAC_WRITE) ?
            (base | 0x80) : base;
#   endif

    f->vcocap_result = 0xff;
    666c:	88800245 	stb	r2,9(r17)

    /* Turn on the DSMs */
    status = LMS_READ(dev, 0x09, &data);
    6670:	00048540 	call	4854 <lms6_read>
    if (status == 0) {
        data |= 0x05;
        status = LMS_WRITE(dev, 0x09, data);
    6674:	10800154 	ori	r2,r2,5
    6678:	11403fcc 	andi	r5,r2,255
    667c:	01000244 	movi	r4,9
    }

    /* Write the initial vcocap estimate first to allow for adequate time for
     * VTUNE to stabilize. We need to be sure to keep the upper bits of
     * this register and perform a RMW, as bit 7 is VOVCOREG[0]. */
    status = LMS_READ(dev, base + 9, &vcocap_reg_state);
    6680:	95000244 	addi	r20,r18,9

    /* Turn on the DSMs */
    status = LMS_READ(dev, 0x09, &data);
    if (status == 0) {
        data |= 0x05;
        status = LMS_WRITE(dev, 0x09, data);
    6684:	00048940 	call	4894 <lms6_write>
    }

    /* Write the initial vcocap estimate first to allow for adequate time for
     * VTUNE to stabilize. We need to be sure to keep the upper bits of
     * this register and perform a RMW, as bit 7 is VOVCOREG[0]. */
    status = LMS_READ(dev, base + 9, &vcocap_reg_state);
    6688:	a5003fcc 	andi	r20,r20,255
    668c:	a009883a 	mov	r4,r20
    6690:	00048540 	call	4854 <lms6_read>
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6694:	89400043 	ldbu	r5,1(r17)
    status = LMS_READ(dev, base + 9, &vcocap_reg_state);
    if (status != 0) {
        goto error;
    }

    vcocap_reg_state &= ~(0x3f);
    6698:	04fff004 	movi	r19,-64
    669c:	14e6703a 	and	r19,r2,r19
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    66a0:	994ab03a 	or	r5,r19,r5
    66a4:	29403fcc 	andi	r5,r5,255
    66a8:	a009883a 	mov	r4,r20
    66ac:	00048940 	call	4894 <lms6_write>
    int status, dsm_status;

    /* Utilize atomic writes to the PLL registers, if possible. This
     * "multiwrite" is indicated by the MSB being set. */
#   ifdef BLADERF_NIOS_BUILD
    const uint8_t pll_base = base | 0x80;
    66b0:	057fe004 	movi	r21,-128
    int status;
    uint8_t regval;
    uint8_t selout;
    uint8_t addr;

    if (module == BLADERF_MODULE_TX) {
    66b4:	00800044 	movi	r2,1
    int status, dsm_status;

    /* Utilize atomic writes to the PLL registers, if possible. This
     * "multiwrite" is indicated by the MSB being set. */
#   ifdef BLADERF_NIOS_BUILD
    const uint8_t pll_base = base | 0x80;
    66b8:	956ab03a 	or	r21,r18,r21
    status = LMS_READ(dev, base + 9, &vcocap_reg_state);
    if (status != 0) {
        goto error;
    }

    vcocap_reg_state &= ~(0x3f);
    66bc:	982f883a 	mov	r23,r19
    status = write_vcocap(dev, base, f->vcocap, vcocap_reg_state);
    if (status != 0) {
        goto error;
    }

    status = write_pll_config(dev, mod, f->freqsel,
    66c0:	8f000003 	ldbu	fp,0(r17)
                              (f->flags & LMS_FREQ_FLAGS_LOW_BAND) != 0);
    66c4:	89c00203 	ldbu	r7,8(r17)
    int status;
    uint8_t regval;
    uint8_t selout;
    uint8_t addr;

    if (module == BLADERF_MODULE_TX) {
    66c8:	80800226 	beq	r16,r2,66d4 <lms_set_precalculated_frequency+0xb8>
        addr = 0x15;
    } else {
        addr = 0x25;
    66cc:	01800944 	movi	r6,37
    66d0:	00000106 	br	66d8 <lms_set_precalculated_frequency+0xbc>
    uint8_t regval;
    uint8_t selout;
    uint8_t addr;

    if (module == BLADERF_MODULE_TX) {
        addr = 0x15;
    66d4:	01800544 	movi	r6,21
    } else {
        addr = 0x25;
    }

    status = LMS_READ(dev, addr, &regval);
    66d8:	31803fcc 	andi	r6,r6,255
    66dc:	3009883a 	mov	r4,r6
    66e0:	d9800515 	stw	r6,20(sp)
    66e4:	d9c00415 	stw	r7,16(sp)
    66e8:	00048540 	call	4854 <lms6_read>
    66ec:	1011883a 	mov	r8,r2
static inline int is_loopback_enabled(struct bladerf *dev)
{
    bladerf_loopback loopback;
    int status;

    status = lms_get_loopback_mode(dev, &loopback);
    66f0:	d9400104 	addi	r5,sp,4
    66f4:	b009883a 	mov	r4,r22
    66f8:	da000315 	stw	r8,12(sp)
    66fc:	00064a40 	call	64a4 <lms_get_loopback_mode>
    6700:	1021883a 	mov	r16,r2
    if (status != 0) {
    6704:	d9800517 	ldw	r6,20(sp)
    6708:	d9c00417 	ldw	r7,16(sp)
    670c:	da000317 	ldw	r8,12(sp)
    6710:	1000021e 	bne	r2,zero,671c <lms_set_precalculated_frequency+0x100>
        return status;
    }

    return loopback != BLADERF_LB_NONE;
    6714:	dc000117 	ldw	r16,4(sp)
    6718:	84000258 	cmpnei	r16,r16,9
    if (status != 0) {
        return status;
    }

    status = is_loopback_enabled(dev);
    if (status < 0) {
    671c:	8000ca16 	blt	r16,zero,6a48 <lms_set_precalculated_frequency+0x42c>
    6720:	e0c03fcc 	andi	r3,fp,255
        return status;
    }

    if (status == 0) {
    6724:	8000041e 	bne	r16,zero,6738 <lms_set_precalculated_frequency+0x11c>
        /* Loopback not enabled - update the PLL output buffer. */
        selout = low_band ? 1 : 2;
    6728:	3940004c 	andi	r5,r7,1
    672c:	00800084 	movi	r2,2
    6730:	114bc83a 	sub	r5,r2,r5
    6734:	00000106 	br	673c <lms_set_precalculated_frequency+0x120>
        regval = (freqsel << 2) | selout;
    } else {
        /* Loopback is enabled - don't touch PLL output buffer. */
        regval = (regval & ~0xfc) | (freqsel << 2);
    6738:	414000cc 	andi	r5,r8,3
    673c:	18c7883a 	add	r3,r3,r3
    6740:	18c7883a 	add	r3,r3,r3
    6744:	28cab03a 	or	r5,r5,r3
    }

    return LMS_WRITE(dev, addr, regval);
    6748:	3009883a 	mov	r4,r6
    674c:	29403fcc 	andi	r5,r5,255
    6750:	00048940 	call	4894 <lms6_write>
    if (status != 0) {
        goto error;
    }

    data = f->nint >> 1;
    status = LMS_WRITE(dev, pll_base + 0, data);
    6754:	8940008b 	ldhu	r5,2(r17)
    6758:	a9003fcc 	andi	r4,r21,255
    675c:	280ad07a 	srli	r5,r5,1
    6760:	29403fcc 	andi	r5,r5,255
    6764:	00048940 	call	4894 <lms6_write>
    if (status != 0) {
        goto error;
    }

    data = ((f->nint & 1) << 7) | ((f->nfrac >> 16) & 0x7f);
    status = LMS_WRITE(dev, pll_base + 1, data);
    6768:	88800083 	ldbu	r2,2(r17)
    676c:	8940018b 	ldhu	r5,6(r17)
    6770:	a9000044 	addi	r4,r21,1
    6774:	100491fa 	slli	r2,r2,7
    6778:	29401fcc 	andi	r5,r5,127
    677c:	21003fcc 	andi	r4,r4,255
    6780:	288ab03a 	or	r5,r5,r2
    6784:	29403fcc 	andi	r5,r5,255
    6788:	00048940 	call	4894 <lms6_write>
    if (status != 0) {
        goto error;
    }

    data = ((f->nfrac >> 8) & 0xff);
    status = LMS_WRITE(dev, pll_base + 2, data);
    678c:	89400143 	ldbu	r5,5(r17)
    6790:	a9000084 	addi	r4,r21,2
    6794:	21003fcc 	andi	r4,r4,255
    6798:	00048940 	call	4894 <lms6_write>
    if (status != 0) {
        goto error;
    }

    data = (f->nfrac & 0xff);
    status = LMS_WRITE(dev, pll_base + 3, data);
    679c:	89400103 	ldbu	r5,4(r17)
    67a0:	a90000c4 	addi	r4,r21,3
    67a4:	21003fcc 	andi	r4,r4,255
    67a8:	00048940 	call	4894 <lms6_write>
        goto error;
    }

    /* Perform tuning algorithm unless we've been instructed to just use
     * the VCOCAP hint as-is. */
    if (f->flags & LMS_FREQ_FLAGS_FORCE_VCOCAP) {
    67ac:	88800203 	ldbu	r2,8(r17)
    67b0:	88c00043 	ldbu	r3,1(r17)
    67b4:	1080008c 	andi	r2,r2,2
    67b8:	10000326 	beq	r2,zero,67c8 <lms_set_precalculated_frequency+0x1ac>
        f->vcocap_result = f->vcocap;
    67bc:	88c00245 	stb	r3,9(r17)
    if (status != 0) {
        goto error;
    }

    data = (f->nfrac & 0xff);
    status = LMS_WRITE(dev, pll_base + 3, data);
    67c0:	0021883a 	mov	r16,zero
    67c4:	0000a006 	br	6a48 <lms_set_precalculated_frequency+0x42c>
    uint8_t vtune_high_limit; /* Where VCOCAP puts use into VTUNE HIGH region */
    uint8_t vtune_low_limit;  /* Where VCOCAP puts use into VTUNE HIGH region */

    RESET_BUSY_WAIT_COUNT();

    vtune_high_limit = VCOCAP_MAX_VALUE;
    67c8:	00800fc4 	movi	r2,63
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    67cc:	01000c84 	movi	r4,50
    RESET_BUSY_WAIT_COUNT();

    vtune_high_limit = VCOCAP_MAX_VALUE;
    vtune_low_limit = 0;

    status = get_vtune(dev, base, VTUNE_DELAY_LARGE, &vtune);
    67d0:	95403fcc 	andi	r21,r18,255

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    67d4:	94800284 	addi	r18,r18,10
static int tune_vcocap(struct bladerf *dev, uint8_t vcocap_est,
                       uint8_t base, uint8_t vcocap_reg_state,
                       uint8_t *vcocap_result)
{
    int status;
    uint8_t vcocap = vcocap_est;
    67d8:	d8c00245 	stb	r3,9(sp)
    uint8_t vtune_high_limit; /* Where VCOCAP puts use into VTUNE HIGH region */
    uint8_t vtune_low_limit;  /* Where VCOCAP puts use into VTUNE HIGH region */

    RESET_BUSY_WAIT_COUNT();

    vtune_high_limit = VCOCAP_MAX_VALUE;
    67dc:	d8800205 	stb	r2,8(sp)
    vtune_low_limit = 0;
    67e0:	d8000105 	stb	zero,4(sp)

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    }

    status = LMS_READ(dev, base + 10, vtune);
    67e4:	94803fcc 	andi	r18,r18,255
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    67e8:	0006ef40 	call	6ef4 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    67ec:	9009883a 	mov	r4,r18
    67f0:	00048540 	call	4854 <lms6_read>
    *vtune >>= 6;
    67f4:	10803fcc 	andi	r2,r2,255
    status = get_vtune(dev, base, VTUNE_DELAY_LARGE, &vtune);
    if (status != 0) {
        return status;
    }

    switch (vtune) {
    67f8:	1038d1ba 	srli	fp,r2,6
    67fc:	00800044 	movi	r2,1
    6800:	e0802b26 	beq	fp,r2,68b0 <lms_set_precalculated_frequency+0x294>
    6804:	e0000a26 	beq	fp,zero,6830 <lms_set_precalculated_frequency+0x214>
    6808:	00800084 	movi	r2,2
    680c:	e080311e 	bne	fp,r2,68d4 <lms_set_precalculated_frequency+0x2b8>
        case VCO_HIGH:
            log_verbose("Estimate HIGH: Walking down to NORM.\n");
            status = vtune_high_to_norm(dev, base, vcocap, vcocap_reg_state,
    6810:	d9800243 	ldbu	r6,9(sp)
    6814:	d8800204 	addi	r2,sp,8
    6818:	99c03fcc 	andi	r7,r19,255
    681c:	d8800015 	stw	r2,0(sp)
    6820:	a80b883a 	mov	r5,r21
    6824:	b009883a 	mov	r4,r22
    6828:	00061f00 	call	61f0 <vtune_high_to_norm>
    682c:	00002706 	br	68cc <lms_set_precalculated_frequency+0x2b0>
                                        &vtune_high_limit);
            break;

        case VCO_NORM:
            log_verbose("Estimate NORM: Walking up to HIGH.\n");
            status = vtune_norm_to_high(dev, base, vcocap, vcocap_reg_state,
    6830:	d8c00243 	ldbu	r3,9(sp)
        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == VCO_HIGH) {
    6834:	01c00084 	movi	r7,2
    6838:	19bffb04 	addi	r6,r3,-20
{
    int status;
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {
    683c:	31803fcc 	andi	r6,r6,255

        if (vcocap == 0) {
    6840:	18803fcc 	andi	r2,r3,255
    6844:	1000021e 	bne	r2,zero,6850 <lms_set_precalculated_frequency+0x234>
            *vtune_high_limit = 0;
    6848:	d8000205 	stb	zero,8(sp)
    684c:	00002106 	br	68d4 <lms_set_precalculated_frequency+0x2b8>
            log_warning("%s: VCOCAP hit min value.\n", __FUNCTION__);
            return 0;
        }

        vcocap--;
    6850:	1c3fffc4 	addi	r16,r3,-1
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6854:	85cab03a 	or	r5,r16,r23
            *vtune_high_limit = 0;
            log_warning("%s: VCOCAP hit min value.\n", __FUNCTION__);
            return 0;
        }

        vcocap--;
    6858:	8007883a 	mov	r3,r16
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    685c:	29403fcc 	andi	r5,r5,255
    6860:	a009883a 	mov	r4,r20
    6864:	d8c00315 	stw	r3,12(sp)
    6868:	d9800515 	stw	r6,20(sp)
    686c:	d9c00415 	stw	r7,16(sp)
    6870:	00048940 	call	4894 <lms6_write>
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    6874:	01000644 	movi	r4,25
    6878:	0006ef40 	call	6ef4 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    687c:	9009883a 	mov	r4,r18
    6880:	00048540 	call	4854 <lms6_read>
        status = get_vtune(dev, base, VTUNE_DELAY_SMALL, &vtune);
        if (status != 0) {
            return status;
        }

        if (vtune == VCO_HIGH) {
    6884:	10803fcc 	andi	r2,r2,255
    6888:	1004d1ba 	srli	r2,r2,6
    688c:	d9c00417 	ldw	r7,16(sp)
    6890:	d8c00317 	ldw	r3,12(sp)
    6894:	d9800517 	ldw	r6,20(sp)
    6898:	11c0021e 	bne	r2,r7,68a4 <lms_set_precalculated_frequency+0x288>
            *vtune_high_limit = vcocap;
    689c:	dc000205 	stb	r16,8(sp)
    68a0:	00000c06 	br	68d4 <lms_set_precalculated_frequency+0x2b8>
{
    int status;
    unsigned int i;
    uint8_t vtune = 0xff;

    for (i = 0; i < VTUNE_MAX_ITERATIONS; i++) {
    68a4:	84003fcc 	andi	r16,r16,255
    68a8:	343fe51e 	bne	r6,r16,6840 <_gp+0xffff7728>
    68ac:	00006506 	br	6a44 <lms_set_precalculated_frequency+0x428>
                                        &vtune_high_limit);
            break;

        case VCO_LOW:
            log_verbose("Estimate LOW: Walking down to NORM.\n");
            status = vtune_low_to_norm(dev, base, vcocap, vcocap_reg_state,
    68b0:	d9800243 	ldbu	r6,9(sp)
    68b4:	d8800104 	addi	r2,sp,4
    68b8:	99c03fcc 	andi	r7,r19,255
    68bc:	d8800015 	stw	r2,0(sp)
    68c0:	a80b883a 	mov	r5,r21
    68c4:	b009883a 	mov	r4,r22
    68c8:	00061240 	call	6124 <vtune_low_to_norm>
    68cc:	1021883a 	mov	r16,r2
                                       &vtune_low_limit);
            break;
    }

    if (status != 0) {
    68d0:	10005d1e 	bne	r2,zero,6a48 <lms_set_precalculated_frequency+0x42c>
        return status;
    } else if (vtune_high_limit != VCOCAP_MAX_VALUE) {
    68d4:	d8800203 	ldbu	r2,8(sp)
    68d8:	01000fc4 	movi	r4,63
    68dc:	10c03fcc 	andi	r3,r2,255
    68e0:	19001f26 	beq	r3,r4,6960 <lms_set_precalculated_frequency+0x344>
        /* We determined our VTUNE HIGH limit. Try to force ourselves to the
         * LOW limit and then walk back up to norm from there.
         *
         * Reminder - There's an inverse relationship between VTUNE and VCOCAP
         */
        switch (vtune) {
    68e4:	e0000226 	beq	fp,zero,68f0 <lms_set_precalculated_frequency+0x2d4>
    68e8:	01000084 	movi	r4,2
    68ec:	e100551e 	bne	fp,r4,6a44 <lms_set_precalculated_frequency+0x428>
            case VCO_HIGH:
            case VCO_NORM:
                if ( ((int) vtune_high_limit + VCOCAP_MAX_LOW_HIGH) < VCOCAP_MAX_VALUE) {
    68f0:	01000c84 	movi	r4,50
    68f4:	20c00216 	blt	r4,r3,6900 <lms_set_precalculated_frequency+0x2e4>
                    vcocap = vtune_high_limit + VCOCAP_MAX_LOW_HIGH;
    68f8:	10800304 	addi	r2,r2,12
    68fc:	00000106 	br	6904 <lms_set_precalculated_frequency+0x2e8>
                } else {
                    vcocap = VCOCAP_MAX_VALUE;
    6900:	00800fc4 	movi	r2,63
    6904:	d8800245 	stb	r2,9(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6908:	d9400243 	ldbu	r5,9(sp)
    690c:	a009883a 	mov	r4,r20
        if (status != 0) {
            return status;
        }

        log_verbose("Waiting for VTUNE LOW @ VCOCAP=%u,\n", vcocap);
        status = wait_for_vtune_value(dev, base, VCO_LOW,
    6910:	9dc03fcc 	andi	r23,r19,255
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6914:	994ab03a 	or	r5,r19,r5
    6918:	29403fcc 	andi	r5,r5,255
    691c:	00048940 	call	4894 <lms6_write>
        if (status != 0) {
            return status;
        }

        log_verbose("Waiting for VTUNE LOW @ VCOCAP=%u,\n", vcocap);
        status = wait_for_vtune_value(dev, base, VCO_LOW,
    6920:	d9c00244 	addi	r7,sp,9
    6924:	ddc00015 	stw	r23,0(sp)
    6928:	01800044 	movi	r6,1
    692c:	a80b883a 	mov	r5,r21
    6930:	b009883a 	mov	r4,r22
    6934:	00062c80 	call	62c8 <wait_for_vtune_value>
    6938:	1021883a 	mov	r16,r2
                                      &vcocap, vcocap_reg_state);

        if (status == 0) {
    693c:	1000421e 	bne	r2,zero,6a48 <lms_set_precalculated_frequency+0x42c>
            log_verbose("Walking VTUNE LOW to NORM from VCOCAP=%u,\n", vcocap);
            status = vtune_low_to_norm(dev, base, vcocap, vcocap_reg_state,
    6940:	d9800243 	ldbu	r6,9(sp)
    6944:	d8800104 	addi	r2,sp,4
    6948:	d8800015 	stw	r2,0(sp)
    694c:	b80f883a 	mov	r7,r23
    6950:	a80b883a 	mov	r5,r21
    6954:	b009883a 	mov	r4,r22
    6958:	00061240 	call	6124 <vtune_low_to_norm>
    695c:	00001f06 	br	69dc <lms_set_precalculated_frequency+0x3c0>
        /* We determined our VTUNE LOW limit. Try to force ourselves up to
         * the HIGH limit and then walk down to NORM from there
         *
         * Reminder - There's an inverse relationship between VTUNE and VCOCAP
         */
        switch (vtune) {
    6960:	00800044 	movi	r2,1
    6964:	17003736 	bltu	r2,fp,6a44 <lms_set_precalculated_frequency+0x428>
            case VCO_LOW:
            case VCO_NORM:
                if ( ((int) vtune_low_limit - VCOCAP_MAX_LOW_HIGH) > 0) {
    6968:	d8800103 	ldbu	r2,4(sp)
    696c:	01000304 	movi	r4,12
    6970:	10c03fcc 	andi	r3,r2,255
    6974:	20c0030e 	bge	r4,r3,6984 <lms_set_precalculated_frequency+0x368>
                    vcocap = vtune_low_limit - VCOCAP_MAX_LOW_HIGH;
    6978:	10bffd04 	addi	r2,r2,-12
    697c:	d8800245 	stb	r2,9(sp)
    6980:	00000106 	br	6988 <lms_set_precalculated_frequency+0x36c>
                } else {
                    vcocap = 0;
    6984:	d8000245 	stb	zero,9(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6988:	d9400243 	ldbu	r5,9(sp)
    698c:	a009883a 	mov	r4,r20
        if (status != 0) {
            return status;
        }

        log_verbose("Waiting for VTUNE HIGH @ VCOCAP=%u\n", vcocap);
        status = wait_for_vtune_value(dev, base, VCO_HIGH,
    6990:	9dc03fcc 	andi	r23,r19,255
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6994:	994ab03a 	or	r5,r19,r5
    6998:	29403fcc 	andi	r5,r5,255
    699c:	00048940 	call	4894 <lms6_write>
        if (status != 0) {
            return status;
        }

        log_verbose("Waiting for VTUNE HIGH @ VCOCAP=%u\n", vcocap);
        status = wait_for_vtune_value(dev, base, VCO_HIGH,
    69a0:	d9c00244 	addi	r7,sp,9
    69a4:	ddc00015 	stw	r23,0(sp)
    69a8:	01800084 	movi	r6,2
    69ac:	a80b883a 	mov	r5,r21
    69b0:	b009883a 	mov	r4,r22
    69b4:	00062c80 	call	62c8 <wait_for_vtune_value>
    69b8:	1021883a 	mov	r16,r2
                                      &vcocap, vcocap_reg_state);

        if (status == 0) {
    69bc:	1000221e 	bne	r2,zero,6a48 <lms_set_precalculated_frequency+0x42c>
            log_verbose("Walking VTUNE HIGH to NORM from VCOCAP=%u,\n", vcocap);
            status = vtune_high_to_norm(dev, base, vcocap, vcocap_reg_state,
    69c0:	d9800243 	ldbu	r6,9(sp)
    69c4:	d8800204 	addi	r2,sp,8
    69c8:	d8800015 	stw	r2,0(sp)
    69cc:	b80f883a 	mov	r7,r23
    69d0:	a80b883a 	mov	r5,r21
    69d4:	b009883a 	mov	r4,r22
    69d8:	00061f00 	call	61f0 <vtune_high_to_norm>
    69dc:	1021883a 	mov	r16,r2
                                        &vtune_high_limit);
        }
    }

    if (status == 0) {
    69e0:	1000191e 	bne	r2,zero,6a48 <lms_set_precalculated_frequency+0x42c>
        vcocap = vtune_high_limit + (vtune_low_limit - vtune_high_limit) / 2;
    69e4:	d9400203 	ldbu	r5,8(sp)
    69e8:	d8c00103 	ldbu	r3,4(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    69ec:	a009883a 	mov	r4,r20
                                        &vtune_high_limit);
        }
    }

    if (status == 0) {
        vcocap = vtune_high_limit + (vtune_low_limit - vtune_high_limit) / 2;
    69f0:	28803fcc 	andi	r2,r5,255
    69f4:	1885c83a 	sub	r2,r3,r2
    69f8:	1006d7fa 	srli	r3,r2,31
    69fc:	1885883a 	add	r2,r3,r2
    6a00:	1005d07a 	srai	r2,r2,1
    6a04:	1145883a 	add	r2,r2,r5
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6a08:	988ab03a 	or	r5,r19,r2
    6a0c:	29403fcc 	andi	r5,r5,255
                                        &vtune_high_limit);
        }
    }

    if (status == 0) {
        vcocap = vtune_high_limit + (vtune_low_limit - vtune_high_limit) / 2;
    6a10:	d8800245 	stb	r2,9(sp)
    int status;

    assert(vcocap <= VCOCAP_MAX_VALUE);
    log_verbose("Writing VCOCAP=%u\n", vcocap);

    status = LMS_WRITE(dev, base + 9, vcocap | vcocap_reg_state);
    6a14:	00048940 	call	4894 <lms6_write>
        if (status != 0) {
            return status;
        }

        /* Inform the caller of what we converged to */
        *vcocap_result = vcocap;
    6a18:	d8800243 	ldbu	r2,9(sp)
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    6a1c:	01000644 	movi	r4,25
        if (status != 0) {
            return status;
        }

        /* Inform the caller of what we converged to */
        *vcocap_result = vcocap;
    6a20:	88800245 	stb	r2,9(r17)
                            uint8_t *vtune)
{
    int status;

    if (delay != 0) {
        VTUNE_BUSY_WAIT(delay);
    6a24:	0006ef40 	call	6ef4 <usleep>
    }

    status = LMS_READ(dev, base + 10, vtune);
    6a28:	9009883a 	mov	r4,r18
    6a2c:	00048540 	call	4854 <lms6_read>
            return status;
        }

        PRINT_BUSY_WAIT_INFO();

        if (vtune != VCO_NORM) {
    6a30:	10803fcc 	andi	r2,r2,255
    6a34:	1020d1ba 	srli	r16,r2,6
    6a38:	8020c03a 	cmpne	r16,r16,zero
    6a3c:	0421c83a 	sub	r16,zero,r16
    6a40:	00000106 	br	6a48 <lms_set_precalculated_frequency+0x42c>
                }
                break;

            default:
                assert(!"Invalid state");
                return BLADERF_ERR_UNEXPECTED;
    6a44:	043fffc4 	movi	r16,-1
                             &f->vcocap_result);
    }

error:
    /* Turn off the DSMs */
    dsm_status = LMS_READ(dev, 0x09, &data);
    6a48:	01000244 	movi	r4,9
    6a4c:	00048540 	call	4854 <lms6_read>
    if (dsm_status == 0) {
        data &= ~(0x05);
        dsm_status = LMS_WRITE(dev, 0x09, data);
    6a50:	11403e8c 	andi	r5,r2,250
    6a54:	01000244 	movi	r4,9
    6a58:	00048940 	call	4894 <lms6_write>
    }

    return (status == 0) ? dsm_status : status;
}
    6a5c:	8005883a 	mov	r2,r16
    6a60:	dfc00f17 	ldw	ra,60(sp)
    6a64:	df000e17 	ldw	fp,56(sp)
    6a68:	ddc00d17 	ldw	r23,52(sp)
    6a6c:	dd800c17 	ldw	r22,48(sp)
    6a70:	dd400b17 	ldw	r21,44(sp)
    6a74:	dd000a17 	ldw	r20,40(sp)
    6a78:	dcc00917 	ldw	r19,36(sp)
    6a7c:	dc800817 	ldw	r18,32(sp)
    6a80:	dc400717 	ldw	r17,28(sp)
    6a84:	dc000617 	ldw	r16,24(sp)
    6a88:	dec01004 	addi	sp,sp,64
    6a8c:	f800283a 	ret

00006a90 <__lshrdi3>:
    6a90:	30000826 	beq	r6,zero,6ab4 <__lshrdi3+0x24>
    6a94:	01c00804 	movi	r7,32
    6a98:	398fc83a 	sub	r7,r7,r6
    6a9c:	01c0080e 	bge	zero,r7,6ac0 <__lshrdi3+0x30>
    6aa0:	2188d83a 	srl	r4,r4,r6
    6aa4:	29c4983a 	sll	r2,r5,r7
    6aa8:	2986d83a 	srl	r3,r5,r6
    6aac:	2084b03a 	or	r2,r4,r2
    6ab0:	f800283a 	ret
    6ab4:	2005883a 	mov	r2,r4
    6ab8:	2807883a 	mov	r3,r5
    6abc:	f800283a 	ret
    6ac0:	01cfc83a 	sub	r7,zero,r7
    6ac4:	0007883a 	mov	r3,zero
    6ac8:	29c4d83a 	srl	r2,r5,r7
    6acc:	f800283a 	ret

00006ad0 <__divsi3>:
    6ad0:	20001b16 	blt	r4,zero,6b40 <__divsi3+0x70>
    6ad4:	000f883a 	mov	r7,zero
    6ad8:	28001616 	blt	r5,zero,6b34 <__divsi3+0x64>
    6adc:	200d883a 	mov	r6,r4
    6ae0:	29001a2e 	bgeu	r5,r4,6b4c <__divsi3+0x7c>
    6ae4:	00800804 	movi	r2,32
    6ae8:	00c00044 	movi	r3,1
    6aec:	00000106 	br	6af4 <__divsi3+0x24>
    6af0:	10000d26 	beq	r2,zero,6b28 <__divsi3+0x58>
    6af4:	294b883a 	add	r5,r5,r5
    6af8:	10bfffc4 	addi	r2,r2,-1
    6afc:	18c7883a 	add	r3,r3,r3
    6b00:	293ffb36 	bltu	r5,r4,6af0 <_gp+0xffff79d8>
    6b04:	0005883a 	mov	r2,zero
    6b08:	18000726 	beq	r3,zero,6b28 <__divsi3+0x58>
    6b0c:	0005883a 	mov	r2,zero
    6b10:	31400236 	bltu	r6,r5,6b1c <__divsi3+0x4c>
    6b14:	314dc83a 	sub	r6,r6,r5
    6b18:	10c4b03a 	or	r2,r2,r3
    6b1c:	1806d07a 	srli	r3,r3,1
    6b20:	280ad07a 	srli	r5,r5,1
    6b24:	183ffa1e 	bne	r3,zero,6b10 <_gp+0xffff79f8>
    6b28:	38000126 	beq	r7,zero,6b30 <__divsi3+0x60>
    6b2c:	0085c83a 	sub	r2,zero,r2
    6b30:	f800283a 	ret
    6b34:	014bc83a 	sub	r5,zero,r5
    6b38:	39c0005c 	xori	r7,r7,1
    6b3c:	003fe706 	br	6adc <_gp+0xffff79c4>
    6b40:	0109c83a 	sub	r4,zero,r4
    6b44:	01c00044 	movi	r7,1
    6b48:	003fe306 	br	6ad8 <_gp+0xffff79c0>
    6b4c:	00c00044 	movi	r3,1
    6b50:	003fee06 	br	6b0c <_gp+0xffff79f4>

00006b54 <__modsi3>:
    6b54:	20001716 	blt	r4,zero,6bb4 <__modsi3+0x60>
    6b58:	000f883a 	mov	r7,zero
    6b5c:	2005883a 	mov	r2,r4
    6b60:	28001216 	blt	r5,zero,6bac <__modsi3+0x58>
    6b64:	2900162e 	bgeu	r5,r4,6bc0 <__modsi3+0x6c>
    6b68:	01800804 	movi	r6,32
    6b6c:	00c00044 	movi	r3,1
    6b70:	00000106 	br	6b78 <__modsi3+0x24>
    6b74:	30000a26 	beq	r6,zero,6ba0 <__modsi3+0x4c>
    6b78:	294b883a 	add	r5,r5,r5
    6b7c:	31bfffc4 	addi	r6,r6,-1
    6b80:	18c7883a 	add	r3,r3,r3
    6b84:	293ffb36 	bltu	r5,r4,6b74 <_gp+0xffff7a5c>
    6b88:	18000526 	beq	r3,zero,6ba0 <__modsi3+0x4c>
    6b8c:	1806d07a 	srli	r3,r3,1
    6b90:	11400136 	bltu	r2,r5,6b98 <__modsi3+0x44>
    6b94:	1145c83a 	sub	r2,r2,r5
    6b98:	280ad07a 	srli	r5,r5,1
    6b9c:	183ffb1e 	bne	r3,zero,6b8c <_gp+0xffff7a74>
    6ba0:	38000126 	beq	r7,zero,6ba8 <__modsi3+0x54>
    6ba4:	0085c83a 	sub	r2,zero,r2
    6ba8:	f800283a 	ret
    6bac:	014bc83a 	sub	r5,zero,r5
    6bb0:	003fec06 	br	6b64 <_gp+0xffff7a4c>
    6bb4:	0109c83a 	sub	r4,zero,r4
    6bb8:	01c00044 	movi	r7,1
    6bbc:	003fe706 	br	6b5c <_gp+0xffff7a44>
    6bc0:	00c00044 	movi	r3,1
    6bc4:	003ff106 	br	6b8c <_gp+0xffff7a74>

00006bc8 <__udivsi3>:
    6bc8:	200d883a 	mov	r6,r4
    6bcc:	2900152e 	bgeu	r5,r4,6c24 <__udivsi3+0x5c>
    6bd0:	28001416 	blt	r5,zero,6c24 <__udivsi3+0x5c>
    6bd4:	00800804 	movi	r2,32
    6bd8:	00c00044 	movi	r3,1
    6bdc:	00000206 	br	6be8 <__udivsi3+0x20>
    6be0:	10000e26 	beq	r2,zero,6c1c <__udivsi3+0x54>
    6be4:	28000516 	blt	r5,zero,6bfc <__udivsi3+0x34>
    6be8:	294b883a 	add	r5,r5,r5
    6bec:	10bfffc4 	addi	r2,r2,-1
    6bf0:	18c7883a 	add	r3,r3,r3
    6bf4:	293ffa36 	bltu	r5,r4,6be0 <_gp+0xffff7ac8>
    6bf8:	18000826 	beq	r3,zero,6c1c <__udivsi3+0x54>
    6bfc:	0005883a 	mov	r2,zero
    6c00:	31400236 	bltu	r6,r5,6c0c <__udivsi3+0x44>
    6c04:	314dc83a 	sub	r6,r6,r5
    6c08:	10c4b03a 	or	r2,r2,r3
    6c0c:	1806d07a 	srli	r3,r3,1
    6c10:	280ad07a 	srli	r5,r5,1
    6c14:	183ffa1e 	bne	r3,zero,6c00 <_gp+0xffff7ae8>
    6c18:	f800283a 	ret
    6c1c:	0005883a 	mov	r2,zero
    6c20:	f800283a 	ret
    6c24:	00c00044 	movi	r3,1
    6c28:	003ff406 	br	6bfc <_gp+0xffff7ae4>

00006c2c <__umodsi3>:
    6c2c:	2005883a 	mov	r2,r4
    6c30:	2900122e 	bgeu	r5,r4,6c7c <__umodsi3+0x50>
    6c34:	28001116 	blt	r5,zero,6c7c <__umodsi3+0x50>
    6c38:	01800804 	movi	r6,32
    6c3c:	00c00044 	movi	r3,1
    6c40:	00000206 	br	6c4c <__umodsi3+0x20>
    6c44:	30000c26 	beq	r6,zero,6c78 <__umodsi3+0x4c>
    6c48:	28000516 	blt	r5,zero,6c60 <__umodsi3+0x34>
    6c4c:	294b883a 	add	r5,r5,r5
    6c50:	31bfffc4 	addi	r6,r6,-1
    6c54:	18c7883a 	add	r3,r3,r3
    6c58:	293ffa36 	bltu	r5,r4,6c44 <_gp+0xffff7b2c>
    6c5c:	18000626 	beq	r3,zero,6c78 <__umodsi3+0x4c>
    6c60:	1806d07a 	srli	r3,r3,1
    6c64:	11400136 	bltu	r2,r5,6c6c <__umodsi3+0x40>
    6c68:	1145c83a 	sub	r2,r2,r5
    6c6c:	280ad07a 	srli	r5,r5,1
    6c70:	183ffb1e 	bne	r3,zero,6c60 <_gp+0xffff7b48>
    6c74:	f800283a 	ret
    6c78:	f800283a 	ret
    6c7c:	00c00044 	movi	r3,1
    6c80:	003ff706 	br	6c60 <_gp+0xffff7b48>

00006c84 <__mulsi3>:
    6c84:	0005883a 	mov	r2,zero
    6c88:	20000726 	beq	r4,zero,6ca8 <__mulsi3+0x24>
    6c8c:	20c0004c 	andi	r3,r4,1
    6c90:	2008d07a 	srli	r4,r4,1
    6c94:	18000126 	beq	r3,zero,6c9c <__mulsi3+0x18>
    6c98:	1145883a 	add	r2,r2,r5
    6c9c:	294b883a 	add	r5,r5,r5
    6ca0:	203ffa1e 	bne	r4,zero,6c8c <_gp+0xffff7b74>
    6ca4:	f800283a 	ret
    6ca8:	f800283a 	ret

00006cac <memcpy>:
    6cac:	2005883a 	mov	r2,r4
    6cb0:	2007883a 	mov	r3,r4
    6cb4:	218d883a 	add	r6,r4,r6
    6cb8:	19800526 	beq	r3,r6,6cd0 <memcpy+0x24>
    6cbc:	29000003 	ldbu	r4,0(r5)
    6cc0:	18c00044 	addi	r3,r3,1
    6cc4:	29400044 	addi	r5,r5,1
    6cc8:	193fffc5 	stb	r4,-1(r3)
    6ccc:	003ffa06 	br	6cb8 <_gp+0xffff7ba0>
    6cd0:	f800283a 	ret

00006cd4 <memset>:
    6cd4:	2005883a 	mov	r2,r4
    6cd8:	2007883a 	mov	r3,r4
    6cdc:	218d883a 	add	r6,r4,r6
    6ce0:	19800326 	beq	r3,r6,6cf0 <memset+0x1c>
    6ce4:	19400005 	stb	r5,0(r3)
    6ce8:	18c00044 	addi	r3,r3,1
    6cec:	003ffc06 	br	6ce0 <_gp+0xffff7bc8>
    6cf0:	f800283a 	ret

00006cf4 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
    6cf4:	0006d801 	jmpi	6d80 <alt_iic_isr_register>

00006cf8 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    6cf8:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    6cfc:	00bfff84 	movi	r2,-2
    6d00:	2084703a 	and	r2,r4,r2
    6d04:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
    6d08:	00c00044 	movi	r3,1
    6d0c:	d0a01517 	ldw	r2,-32684(gp)
    6d10:	194a983a 	sll	r5,r3,r5
    6d14:	288ab03a 	or	r5,r5,r2
    6d18:	d1601515 	stw	r5,-32684(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    6d1c:	d0a01517 	ldw	r2,-32684(gp)
    6d20:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    6d24:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
    6d28:	0005883a 	mov	r2,zero
    6d2c:	f800283a 	ret

00006d30 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    6d30:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    6d34:	00bfff84 	movi	r2,-2
    6d38:	2084703a 	and	r2,r4,r2
    6d3c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
    6d40:	00ffff84 	movi	r3,-2
    6d44:	d0a01517 	ldw	r2,-32684(gp)
    6d48:	194a183a 	rol	r5,r3,r5
    6d4c:	288a703a 	and	r5,r5,r2
    6d50:	d1601515 	stw	r5,-32684(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    6d54:	d0a01517 	ldw	r2,-32684(gp)
    6d58:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    6d5c:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
    6d60:	0005883a 	mov	r2,zero
    6d64:	f800283a 	ret

00006d68 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
    6d68:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
    6d6c:	00800044 	movi	r2,1
    6d70:	1144983a 	sll	r2,r2,r5
    6d74:	10c4703a 	and	r2,r2,r3
}
    6d78:	1004c03a 	cmpne	r2,r2,zero
    6d7c:	f800283a 	ret

00006d80 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
    6d80:	00c007c4 	movi	r3,31
    6d84:	19401616 	blt	r3,r5,6de0 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    6d88:	defffe04 	addi	sp,sp,-8
    6d8c:	dfc00115 	stw	ra,4(sp)
    6d90:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    6d94:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    6d98:	00ffff84 	movi	r3,-2
    6d9c:	80c6703a 	and	r3,r16,r3
    6da0:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    6da4:	280490fa 	slli	r2,r5,3
    6da8:	00c00034 	movhi	r3,0
    6dac:	18dd2104 	addi	r3,r3,29828
    6db0:	1885883a 	add	r2,r3,r2
    6db4:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
    6db8:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
    6dbc:	30000226 	beq	r6,zero,6dc8 <alt_iic_isr_register+0x48>
    6dc0:	0006cf80 	call	6cf8 <alt_ic_irq_enable>
    6dc4:	00000106 	br	6dcc <alt_iic_isr_register+0x4c>
    6dc8:	0006d300 	call	6d30 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    6dcc:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
    6dd0:	dfc00117 	ldw	ra,4(sp)
    6dd4:	dc000017 	ldw	r16,0(sp)
    6dd8:	dec00204 	addi	sp,sp,8
    6ddc:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
    6de0:	00bffa84 	movi	r2,-22
    6de4:	f800283a 	ret

00006de8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    6de8:	deffff04 	addi	sp,sp,-4
    6dec:	01000034 	movhi	r4,0
    6df0:	01400034 	movhi	r5,0
    6df4:	dfc00015 	stw	ra,0(sp)
    6df8:	211c4604 	addi	r4,r4,28952
    6dfc:	295c4d04 	addi	r5,r5,28980

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    6e00:	2140061e 	bne	r4,r5,6e1c <alt_load+0x34>
    6e04:	01000034 	movhi	r4,0
    6e08:	01400034 	movhi	r5,0
    6e0c:	21100804 	addi	r4,r4,16416
    6e10:	29500804 	addi	r5,r5,16416
    6e14:	2140121e 	bne	r4,r5,6e60 <alt_load+0x78>
    6e18:	00000b06 	br	6e48 <alt_load+0x60>
    6e1c:	00c00034 	movhi	r3,0
    6e20:	18dc4d04 	addi	r3,r3,28980
    6e24:	1907c83a 	sub	r3,r3,r4
    6e28:	0005883a 	mov	r2,zero
  {
    while( to != end )
    6e2c:	10fff526 	beq	r2,r3,6e04 <_gp+0xffff7cec>
    {
      *to++ = *from++;
    6e30:	114f883a 	add	r7,r2,r5
    6e34:	39c00017 	ldw	r7,0(r7)
    6e38:	110d883a 	add	r6,r2,r4
    6e3c:	10800104 	addi	r2,r2,4
    6e40:	31c00015 	stw	r7,0(r6)
    6e44:	003ff906 	br	6e2c <_gp+0xffff7d14>
    6e48:	01000034 	movhi	r4,0
    6e4c:	01400034 	movhi	r5,0
    6e50:	211c2304 	addi	r4,r4,28812
    6e54:	295c2304 	addi	r5,r5,28812

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    6e58:	2140101e 	bne	r4,r5,6e9c <alt_load+0xb4>
    6e5c:	00000b06 	br	6e8c <alt_load+0xa4>
    6e60:	00c00034 	movhi	r3,0
    6e64:	18d05304 	addi	r3,r3,16716
    6e68:	1907c83a 	sub	r3,r3,r4
    6e6c:	0005883a 	mov	r2,zero
  {
    while( to != end )
    6e70:	10fff526 	beq	r2,r3,6e48 <_gp+0xffff7d30>
    {
      *to++ = *from++;
    6e74:	114f883a 	add	r7,r2,r5
    6e78:	39c00017 	ldw	r7,0(r7)
    6e7c:	110d883a 	add	r6,r2,r4
    6e80:	10800104 	addi	r2,r2,4
    6e84:	31c00015 	stw	r7,0(r6)
    6e88:	003ff906 	br	6e70 <_gp+0xffff7d58>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    6e8c:	000707c0 	call	707c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    6e90:	dfc00017 	ldw	ra,0(sp)
    6e94:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    6e98:	00070801 	jmpi	7080 <alt_icache_flush_all>
    6e9c:	00c00034 	movhi	r3,0
    6ea0:	18dc4604 	addi	r3,r3,28952
    6ea4:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    6ea8:	0005883a 	mov	r2,zero
  {
    while( to != end )
    6eac:	18bff726 	beq	r3,r2,6e8c <_gp+0xffff7d74>
    {
      *to++ = *from++;
    6eb0:	114f883a 	add	r7,r2,r5
    6eb4:	39c00017 	ldw	r7,0(r7)
    6eb8:	110d883a 	add	r6,r2,r4
    6ebc:	10800104 	addi	r2,r2,4
    6ec0:	31c00015 	stw	r7,0(r6)
    6ec4:	003ff906 	br	6eac <_gp+0xffff7d94>

00006ec8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    6ec8:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    6ecc:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    6ed0:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    6ed4:	0006ef80 	call	6ef8 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    6ed8:	0006f180 	call	6f18 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    6edc:	d1a01617 	ldw	r6,-32680(gp)
    6ee0:	d1601717 	ldw	r5,-32676(gp)
    6ee4:	d1201817 	ldw	r4,-32672(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    6ee8:	dfc00017 	ldw	ra,0(sp)
    6eec:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    6ef0:	00041881 	jmpi	4188 <main>

00006ef4 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
    6ef4:	00070041 	jmpi	7004 <alt_busy_sleep>

00006ef8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    6ef8:	deffff04 	addi	sp,sp,-4
    6efc:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2, nios2);
    6f00:	00070840 	call	7084 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    6f04:	00800044 	movi	r2,1
    6f08:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    6f0c:	dfc00017 	ldw	ra,0(sp)
    6f10:	dec00104 	addi	sp,sp,4
    6f14:	f800283a 	ret

00006f18 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    6f18:	f800283a 	ret

00006f1c <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
    6f1c:	d8800017 	ldw	r2,0(sp)
    6f20:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
    6f24:	00c00044 	movi	r3,1

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
    6f28:	da400217 	ldw	r9,8(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
    6f2c:	194a983a 	sll	r5,r3,r5
int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
    6f30:	399d883a 	add	r14,r7,r6
  alt_u8 * read_end = read_data + read_length;
    6f34:	409f883a 	add	r15,r8,r2
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
    6f38:	21400535 	stwio	r5,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
    6f3c:	48c0008c 	andi	r3,r9,2
    6f40:	1800021e 	bne	r3,zero,6f4c <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
    6f44:	00c10004 	movi	r3,1024
    6f48:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
    6f4c:	20c00037 	ldwio	r3,0(r4)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
    6f50:	00c00044 	movi	r3,1
                           alt_u32 flags)
{
  const alt_u8 * write_end = write_data + write_length;
  alt_u8 * read_end = read_data + read_length;

  alt_u32 write_zeros = read_length;
    6f54:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    6f58:	22c00204 	addi	r11,r4,8
      if (write_data < write_end)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
      else if (write_zeros > 0)
      {
        write_zeros--;
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
    6f5c:	23000104 	addi	r12,r4,4
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    6f60:	59400037 	ldwio	r5,0(r11)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
    6f64:	2b40100c 	andi	r13,r5,64
    6f68:	2940200c 	andi	r5,r5,128
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
    6f6c:	68000126 	beq	r13,zero,6f74 <alt_avalon_spi_command+0x58>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
    6f70:	1800031e 	bne	r3,zero,6f80 <alt_avalon_spi_command+0x64>
    6f74:	283ffa26 	beq	r5,zero,6f60 <_gp+0xffff7e48>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
    6f78:	68000e26 	beq	r13,zero,6fb4 <alt_avalon_spi_command+0x98>
    6f7c:	00001e06 	br	6ff8 <alt_avalon_spi_command+0xdc>
    6f80:	00c00c0e 	bge	zero,r3,6fb4 <alt_avalon_spi_command+0x98>
    {
      credits--;
    6f84:	18ffffc4 	addi	r3,r3,-1

      if (write_data < write_end)
    6f88:	3b80052e 	bgeu	r7,r14,6fa0 <alt_avalon_spi_command+0x84>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
    6f8c:	3b400044 	addi	r13,r7,1
    6f90:	39c00003 	ldbu	r7,0(r7)
    6f94:	61c00035 	stwio	r7,0(r12)
    6f98:	680f883a 	mov	r7,r13
    6f9c:	00000506 	br	6fb4 <alt_avalon_spi_command+0x98>
      else if (write_zeros > 0)
    6fa0:	50000326 	beq	r10,zero,6fb0 <alt_avalon_spi_command+0x94>
      {
        write_zeros--;
    6fa4:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
    6fa8:	60000035 	stwio	zero,0(r12)
    6fac:	00000106 	br	6fb4 <alt_avalon_spi_command+0x98>
      }
      else
        credits = -1024;
    6fb0:	00ff0004 	movi	r3,-1024
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
    6fb4:	283fea26 	beq	r5,zero,6f60 <_gp+0xffff7e48>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
    6fb8:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
    6fbc:	30000226 	beq	r6,zero,6fc8 <alt_avalon_spi_command+0xac>
        read_ignore--;
    6fc0:	31bfffc4 	addi	r6,r6,-1
    6fc4:	00000206 	br	6fd0 <alt_avalon_spi_command+0xb4>
      else
        *read_data++ = (alt_u8)rxdata;
    6fc8:	41400005 	stb	r5,0(r8)
    6fcc:	42000044 	addi	r8,r8,1
      credits++;
    6fd0:	18c00044 	addi	r3,r3,1

      if (read_ignore == 0 && read_data == read_end)
    6fd4:	303fe21e 	bne	r6,zero,6f60 <_gp+0xffff7e48>
    6fd8:	43ffe11e 	bne	r8,r15,6f60 <_gp+0xffff7e48>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    6fdc:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
    6fe0:	18c0080c 	andi	r3,r3,32
    6fe4:	183ffd26 	beq	r3,zero,6fdc <_gp+0xffff7ec4>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
    6fe8:	4a40004c 	andi	r9,r9,1
    6fec:	4800041e 	bne	r9,zero,7000 <alt_avalon_spi_command+0xe4>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
    6ff0:	20000335 	stwio	zero,12(r4)

  return read_length;
    6ff4:	f800283a 	ret
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
    6ff8:	00ffef0e 	bge	zero,r3,6fb8 <_gp+0xffff7ea0>
    6ffc:	003fe106 	br	6f84 <_gp+0xffff7e6c>
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);

  return read_length;
}
    7000:	f800283a 	ret

00007004 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    7004:	01440034 	movhi	r5,4096
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
    7008:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    700c:	297fffc4 	addi	r5,r5,-1
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
    7010:	dc000015 	stw	r16,0(sp)
    7014:	dfc00115 	stw	ra,4(sp)
    7018:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    701c:	0006bc80 	call	6bc8 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
    7020:	10000e26 	beq	r2,zero,705c <alt_busy_sleep+0x58>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    7024:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    7028:	013c0034 	movhi	r4,61440
    702c:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    7030:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    7034:	21000044 	addi	r4,r4,1
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    7038:	297fffc4 	addi	r5,r5,-1
    703c:	283ffe1e 	bne	r5,zero,7038 <_gp+0xffff7f20>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
    7040:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    7044:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
    7048:	18bffb16 	blt	r3,r2,7038 <_gp+0xffff7f20>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
    704c:	802090fa 	slli	r16,r16,3
    7050:	843fffc4 	addi	r16,r16,-1
    7054:	803ffe1e 	bne	r16,zero,7050 <_gp+0xffff7f38>
    7058:	00000306 	br	7068 <alt_busy_sleep+0x64>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
    705c:	802090fa 	slli	r16,r16,3
    7060:	843fffc4 	addi	r16,r16,-1
    7064:	043ffe16 	blt	zero,r16,7060 <_gp+0xffff7f48>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
    7068:	0005883a 	mov	r2,zero
    706c:	dfc00117 	ldw	ra,4(sp)
    7070:	dc000017 	ldw	r16,0(sp)
    7074:	dec00204 	addi	sp,sp,8
    7078:	f800283a 	ret

0000707c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
    707c:	f800283a 	ret

00007080 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
    7080:	f800283a 	ret

00007084 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    7084:	000170fa 	wrctl	ienable,zero
    7088:	f800283a 	ret
